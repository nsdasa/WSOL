<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Pronunciation Analyzer - Formant-Free Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #1f2937;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 40px;
        }

        .word-display {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-radius: 15px;
        }

        .word-display h2 {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 10px;
        }

        .word-display p {
            font-size: 20px;
            color: #6b7280;
        }

        .upload-section {
            background: white;
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            transition: all 0.3s;
        }

        .upload-section:hover {
            border-color: #764ba2;
            background: #f9fafb;
        }

        .upload-section.has-file {
            border-color: #10b981;
            border-style: solid;
            background: #f0fdf4;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .file-loaded {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #f0fdf4;
            border-radius: 10px;
            border-left: 4px solid #10b981;
        }

        .file-loaded.show {
            display: block;
        }

        .file-loaded-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }

        .file-icon {
            width: 50px;
            height: 50px;
            background: #10b981;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .file-icon.user {
            background: #ef4444;
        }

        .play-btn {
            padding: 10px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .play-btn.user {
            background: #ef4444;
        }

        .play-btn:hover {
            transform: scale(1.05);
        }

        .user-recording-section {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #fef2f2;
            border-radius: 10px;
            border-left: 4px solid #ef4444;
        }

        .user-recording-section.show {
            display: block;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #1f2937;
            border: 2px solid #e5e7eb;
        }

        .btn.recording {
            background: #dc2626;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            justify-content: center;
            color: #dc2626;
            font-weight: 600;
            margin: 10px 0;
        }

        .recording-indicator.active {
            display: flex;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            background: #dc2626;
            border-radius: 50%;
            animation: pulse-dot 1.5s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
        }

        .viz-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            background: #f3f4f6;
            padding: 5px;
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .viz-tab {
            flex: 1;
            min-width: 150px;
            padding: 12px 15px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #6b7280;
        }

        .viz-tab:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .viz-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .scale-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .scale-control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .scale-control-group label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
        }

        .scale-toggle {
            display: flex;
            background: #e5e7eb;
            border-radius: 6px;
            padding: 2px;
        }

        .scale-toggle button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #6b7280;
        }

        .scale-toggle button:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .scale-toggle button.active {
            background: white;
            color: #667eea;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .canvas-container {
            background: #1f2937;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #vizCanvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 10px;
        }

        .results {
            display: none;
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-radius: 15px;
            border: 2px solid #86efac;
        }

        .results.show {
            display: block;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .score-display {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 30px;
            align-items: center;
            margin-bottom: 30px;
        }

        .score-circle {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-bg {
            fill: none;
            stroke: #e5e7eb;
            stroke-width: 8;
        }

        .score-fill {
            fill: none;
            stroke: #10b981;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .score-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #1f2937;
        }

        .score-info h3 {
            font-size: 28px;
            color: #059669;
            margin-bottom: 10px;
        }

        .breakdown {
            display: grid;
            gap: 12px;
            margin-bottom: 25px;
        }

        .breakdown-item {
            display: grid;
            grid-template-columns: 180px 1fr 60px;
            gap: 15px;
            align-items: center;
        }

        .breakdown-item .label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .progress-bar {
            height: 28px;
            background: #e5e7eb;
            border-radius: 14px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-size: 11px;
            font-weight: bold;
        }

        .mic-status {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .mic-status.ready {
            background: #d1fae5;
            color: #065f46;
        }

        .mic-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .filter-toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            background: #f0fdf4;
            border-left: 4px solid #10b981;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .filter-toggle-container.disabled {
            background: #f3f4f6;
            border-left-color: #9ca3af;
        }

        .filter-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .filter-label {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
            user-select: none;
        }

        .filter-info {
            font-size: 12px;
            color: #6b7280;
            margin-left: auto;
        }

        .debug-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f3f4f6;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .debug-panel.show {
            display: block;
        }

        .debug-line {
            padding: 2px 0;
            color: #374151;
        }

        .debug-line.error {
            color: #dc2626;
        }

        .debug-line.success {
            color: #059669;
        }

        .api-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: auto;
        }

        .api-status.configured {
            background: #d1fae5;
            color: #065f46;
        }

        .api-status.not-configured {
            background: #fee2e2;
            color: #991b1b;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            .score-display {
                grid-template-columns: 1fr;
            }

            .breakdown-item {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ Professional Pronunciation Analyzer</h1>
            <p>Advanced acoustic analysis with improved LPC formants, pitch tracking, and multi-feature scoring</p>
        </div>

        <div class="content">
            <div id="micStatus" class="mic-status ready" style="display: none;">
                ‚úÖ Microphone ready!
            </div>

            <div class="word-display">
                <h2 id="targetWord">Upload Audio File</h2>
                <p id="targetTranslation">Load a native speaker recording to begin</p>
            </div>

            <div class="upload-section" id="uploadSection">
                <div class="file-input-wrapper">
                    <input type="file" id="nativeAudioFile" accept="audio/*" />
                    <label for="nativeAudioFile" class="file-input-label">
                        <span>üìÅ</span>
                        <span>Upload Native Audio</span>
                    </label>
                </div>
            </div>

            <div class="file-loaded" id="fileLoaded">
                <div class="file-loaded-info">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="file-icon">üéµ</div>
                        <div>
                            <h4 id="fileName" style="color: #059669; margin-bottom: 5px;">audio.mp3</h4>
                            <p style="font-size: 13px; color: #6b7280;"><span id="fileDurationText">Duration: 0.0s</span></p>
                        </div>
                    </div>
                    <button id="playNative" class="play-btn">‚ñ∂Ô∏è Play Native</button>
                </div>
            </div>

            <div class="user-recording-section" id="userRecordingSection">
                <div class="file-loaded-info">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="file-icon user">üé§</div>
                        <div>
                            <h4 style="color: #dc2626; margin-bottom: 5px;">Your Recording</h4>
                            <p style="font-size: 13px; color: #6b7280;"><span id="userDurationText">Duration: 0.0s</span></p>
                        </div>
                    </div>
                    <button id="playUser" class="play-btn user">‚ñ∂Ô∏è Play Your Recording</button>
                </div>
            </div>

            <div class="filter-toggle-container" id="filterToggleContainer">
                <input type="checkbox" id="filterToggle" class="filter-checkbox" checked>
                <label for="filterToggle" class="filter-label">
                    üéöÔ∏è Apply Speech Filter (70-12000 Hz)
                </label>
                <span class="filter-info">Removes noise outside human speech range</span>
            </div>

            <div class="filter-toggle-container" id="dtwToggleContainer">
                <input type="checkbox" id="dtwToggle" class="filter-checkbox" checked>
                <label for="dtwToggle" class="filter-label">
                    üîÑ Use DTW (Dynamic Time Warping)
                </label>
                <span class="filter-info">Matches patterns regardless of speech speed - better for timing variations</span>
            </div>

            <!-- API Key Configuration -->
            <div class="filter-toggle-container" id="apiKeyContainer" style="background: #fef3c7; border-left-color: #f59e0b;">
                <details style="width: 100%;">
                    <summary style="cursor: pointer; font-weight: 600; color: #92400e; display: flex; align-items: center; gap: 10px;">
                        üîë AI Analysis API Key
                        <span id="apiStatus" class="api-status not-configured">Not Configured</span>
                    </summary>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #fbbf24;">
                        <p style="font-size: 12px; color: #78350f; margin-bottom: 10px;">
                            Enter your Anthropic API key to enable AI-powered pronunciation feedback. 
                            Your key is stored only in your browser's localStorage.
                        </p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                            <input type="password" id="apiKeyInput" placeholder="sk-ant-api03-..." 
                                   style="flex: 1; min-width: 200px; padding: 8px; border: 1px solid #fbbf24; border-radius: 4px; font-family: monospace; font-size: 12px;">
                            <button onclick="saveApiKey()" class="btn btn-secondary" style="padding: 8px 15px; font-size: 12px; background: #f59e0b;">Save Key</button>
                            <button onclick="clearApiKey()" class="btn btn-secondary" style="padding: 8px 15px; font-size: 12px;">Clear</button>
                        </div>
                    </div>
                </details>
            </div>

            <div class="controls">
                <button id="recordBtn" class="btn btn-secondary" disabled>
                    <span>üé§</span>
                    <span id="recordText">Record Your Voice</span>
                </button>
                <div class="file-input-wrapper">
                    <input type="file" id="userAudioFile" accept="audio/*" disabled />
                    <label for="userAudioFile" class="file-input-label" id="userUploadLabel" style="opacity: 0.5; cursor: not-allowed;">
                        <span>üìÅ</span>
                        <span>Upload Your Audio</span>
                    </label>
                </div>
                <button id="compareBtn" class="btn btn-primary" disabled>
                    <span>üìä</span>
                    <span>Analyze Pronunciation</span>
                </button>
                <button id="toggleDebug" class="btn btn-secondary">
                    <span>üêõ</span>
                    <span>Toggle Debug</span>
                </button>
                <button id="exportAnalysis" class="btn btn-secondary" disabled>
                    <span>üìÑ</span>
                    <span>Export Analysis Data</span>
                </button>
            </div>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="pulse-dot"></div>
                <span>Recording in progress...</span>
            </div>

            <div class="debug-panel" id="debugPanel">
                <strong>Debug Log:</strong>
                <div id="debugLog"></div>
            </div>

            <div class="debug-panel" id="analysisPanel" style="max-height: 400px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong>Detailed Analysis Output:</strong>
                    <button id="copyAnalysis" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">
                        üìã Copy to Clipboard
                    </button>
                </div>
                <div id="analysisOutput"></div>
            </div>

            <div class="viz-tabs">
                <button class="viz-tab active" data-viz="waveform">üìà Waveform</button>
                <button class="viz-tab" data-viz="spectrum">üìä Spectrum (FFT)</button>
                <button class="viz-tab" data-viz="spectrogram">üåà Spectrogram</button>
                <button class="viz-tab" data-viz="pitch">üéµ Pitch Contour</button>
                <button class="viz-tab" data-viz="intensity">üí™ Intensity</button>
                <button class="viz-tab" data-viz="mfcc">üéº MFCCs</button>
                <button class="viz-tab" data-viz="features">üìä All Features</button>
            </div>

            <div class="scale-controls" id="scaleControls" style="display: none;">
                <div class="scale-control-group" id="amplitudeScaleGroup" style="display: none;">
                    <label>Amplitude:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="linear" data-type="amplitude">Linear</button>
                        <button data-scale="db" data-type="amplitude">dB</button>
                    </div>
                </div>
                <div class="scale-control-group" id="waveformModeGroup" style="display: none;">
                    <label>Waveform:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="bipolar" data-type="waveform-mode">Bipolar</button>
                        <button data-scale="envelope" data-type="waveform-mode">Envelope</button>
                    </div>
                </div>
                <div class="scale-control-group" id="displayModeGroup" style="display: none;">
                    <label>Display:</label>
                    <div class="scale-toggle">
                        <button data-scale="separate" data-type="display-mode">Separate</button>
                        <button class="active" data-scale="overlay" data-type="display-mode">Overlay</button>
                    </div>
                </div>
                <div class="scale-control-group" id="spectrogramMagScaleGroup" style="display: none;">
                    <label>Magnitude:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="linear" data-type="spectrogram-mag">Linear</button>
                        <button data-scale="db" data-type="spectrogram-mag">dB</button>
                    </div>
                </div>
                <div class="scale-control-group" id="spectrogramFreqScaleGroup" style="display: none;">
                    <label>Frequency:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="linear" data-type="spectrogram-freq">Linear</button>
                        <button data-scale="log" data-type="spectrogram-freq">Log</button>
                        <button data-scale="mel" data-type="spectrogram-freq">Mel</button>
                    </div>
                </div>
                <div class="scale-control-group" id="melBinsGroup" style="display: none;">
                    <label>Mel Bins:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="80" data-type="mel-bins">80</button>
                        <button data-scale="100" data-type="mel-bins">100</button>
                    </div>
                </div>
                <div class="scale-control-group" id="peakFilterGroup" style="display: none;">
                    <label>Filter Mode:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="filterModeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="global">Global Peak %</option>
                            <option value="percentile">Percentile</option>
                            <option value="perbin">Per-Frequency Bin</option>
                            <option value="db">dB Threshold</option>
                            <option value="statistical">Statistical</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="filterValueGroup" style="display: none;">
                    <label id="filterValueLabel">Threshold:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="filterValueSlider" min="0" max="100" value="0" step="1"
                               style="width: 120px; cursor: pointer;">
                        <input type="number" id="filterValueInput" min="0" max="100" value="0" step="1"
                               style="width: 60px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span id="filterValueUnit" style="font-size: 11px; color: #6b7280;">%</span>
                    </div>
                </div>
                <div class="scale-control-group" id="zoomXGroup" style="display: none;">
                    <label>Zoom X:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="zoomXSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="zoomXInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="zoomYGroup" style="display: none;">
                    <label>Zoom Y:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="zoomYSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="zoomYInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="fftSizeGroup" style="display: none;">
                    <label>FFT Size:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="fftSizeSlider" min="0" max="5" value="1" step="1"
                               style="width: 100px; cursor: pointer;">
                        <select id="fftSizeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; width: 70px;">
                            <option value="256">256</option>
                            <option value="512" selected>512</option>
                            <option value="1024">1024</option>
                            <option value="2048">2048</option>
                            <option value="4096">4096</option>
                            <option value="8192">8192</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="hopSizeGroup" style="display: none;">
                    <label>Hop:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="hopSizeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; width: 70px;">
                            <option value="auto" selected>Auto</option>
                            <option value="64">64</option>
                            <option value="128">128</option>
                            <option value="256">256</option>
                            <option value="512">512</option>
                            <option value="1024">1024</option>
                            <option value="2048">2048</option>
                        </select>
                    </div>
                </div>
                
                <!-- Waveform Controls -->
                <div class="scale-control-group" id="waveformFilterModeGroup" style="display: none;">
                    <label>Filter:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="waveformFilterModeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="none">None</option>
                            <option value="threshold">Threshold</option>
                            <option value="noisegate">Noise Gate</option>
                            <option value="percentile">Percentile</option>
                            <option value="rms">RMS Smooth</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="waveformFilterValueGroup" style="display: none;">
                    <label id="waveformFilterValueLabel">Value:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="waveformFilterValueSlider" min="0" max="100" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="waveformFilterValueInput" min="0" max="100" value="1" step="0.1"
                               style="width: 55px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="waveformZoomXGroup" style="display: none;">
                    <label>Zoom X:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="waveformZoomXSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="waveformZoomXInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="waveformZoomYGroup" style="display: none;">
                    <label>Zoom Y:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="waveformZoomYSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="waveformZoomYInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="waveformTimeCropGroup" style="display: none;">
                    <label>Time:</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="waveformTimeStartInput" min="0" max="1" value="0" step="0.01"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">to</span>
                        <input type="number" id="waveformTimeEndInput" min="0" max="1" value="1" step="0.01"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="waveformDownsampleGroup" style="display: none;">
                    <label>Downsample:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="minmax" data-type="waveform-downsample">Min-Max</button>
                        <button data-scale="max" data-type="waveform-downsample">Peak</button>
                        <button data-scale="avg" data-type="waveform-downsample">Avg</button>
                    </div>
                </div>
                <div class="scale-control-group" id="waveformNormGroup" style="display: none;">
                    <label>Normalize:</label>
                    <div class="scale-toggle">
                        <button class="active" data-scale="independent" data-type="waveform-norm">Independent</button>
                        <button data-scale="shared" data-type="waveform-norm">Shared</button>
                    </div>
                </div>
                
                <!-- MFCC Controls -->
                <div class="scale-control-group" id="mfccNumFiltersGroup" style="display: none;">
                    <label>Mel Filters:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="mfccNumFiltersSlider" min="20" max="128" value="60" step="1"
                               style="width: 80px; cursor: pointer;">
                        <input type="number" id="mfccNumFiltersInput" min="20" max="128" value="60" step="1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="mfccCoeffGroup" style="display: none;">
                    <label>Coefficients:</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <span style="font-size: 11px; color: #6b7280;">c</span>
                        <input type="number" id="mfccCoeffStartInput" min="0" max="12" value="1" step="1"
                               style="width: 40px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">to c</span>
                        <input type="number" id="mfccCoeffEndInput" min="1" max="12" value="12" step="1"
                               style="width: 40px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="mfccDeltaGroup" style="display: none;">
                    <label>Derivatives:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="font-size: 11px; display: flex; align-items: center; gap: 3px;">
                            <input type="checkbox" id="mfccDeltaCheck"> Œî
                        </label>
                        <label style="font-size: 11px; display: flex; align-items: center; gap: 3px;">
                            <input type="checkbox" id="mfccDeltaDeltaCheck"> ŒîŒî
                        </label>
                    </div>
                </div>
                <div class="scale-control-group" id="mfccLifterGroup" style="display: none;">
                    <label>Lifter:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="mfccLifterSlider" min="0" max="22" value="0" step="1"
                               style="width: 80px; cursor: pointer;">
                        <input type="number" id="mfccLifterInput" min="0" max="22" value="0" step="1"
                               style="width: 45px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="mfccFilterModeGroup" style="display: none;">
                    <label>Filter:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="mfccFilterModeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="none">None</option>
                            <option value="percentile">Percentile</option>
                            <option value="statistical">Statistical</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="mfccFilterValueGroup" style="display: none;">
                    <label id="mfccFilterValueLabel">Value:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="mfccFilterValueSlider" min="0" max="100" value="0" step="1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="mfccFilterValueInput" min="0" max="100" value="0" step="1"
                               style="width: 55px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="mfccPerBinNormGroup" style="display: none;">
                    <label>Per-Bin Norm:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="mfccPerBinNormCheck">
                    </div>
                </div>
                <div class="scale-control-group" id="mfccZoomXGroup" style="display: none;">
                    <label>Zoom X:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="mfccZoomXSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="mfccZoomXInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="mfccZoomYGroup" style="display: none;">
                    <label>Zoom Y:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="mfccZoomYSlider" min="1" max="10" value="1" step="0.1"
                               style="width: 100px; cursor: pointer;">
                        <input type="number" id="mfccZoomYInput" min="1" max="10" value="1" step="0.1"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                        <span style="font-size: 11px; color: #6b7280;">√ó</span>
                    </div>
                </div>
                <div class="scale-control-group" id="mfccColormapGroup" style="display: none;">
                    <label>Colormap:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="mfccColormapSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="bluered">Blue-Red</option>
                            <option value="viridis">Viridis</option>
                            <option value="plasma">Plasma</option>
                            <option value="grayscale">Grayscale</option>
                            <option value="jet">Jet</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="mfccSymmetricGroup" style="display: none;">
                    <label>Center at 0:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="mfccSymmetricCheck" checked>
                    </div>
                </div>
                
                <!-- Pitch Contour Controls -->
                <div class="scale-control-group" id="pitchConfidenceGroup" style="display: none;">
                    <label>Confidence:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="pitchConfidenceSlider" min="0" max="0.8" value="0" step="0.05"
                               style="width: 80px; cursor: pointer;">
                        <input type="number" id="pitchConfidenceInput" min="0" max="0.8" value="0" step="0.05"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="pitchSmoothingGroup" style="display: none;">
                    <label>Smoothing:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="pitchSmoothingSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="median">Median</option>
                            <option value="moving-avg">Moving Avg</option>
                            <option value="savitzky-golay">Savitzky-Golay</option>
                            <option value="none">None (Raw)</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="pitchSmoothingWindowGroup" style="display: none;">
                    <label>Window:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="pitchSmoothingWindowSlider" min="3" max="15" value="5" step="2"
                               style="width: 60px; cursor: pointer;">
                        <input type="number" id="pitchSmoothingWindowInput" min="3" max="15" value="5" step="2"
                               style="width: 45px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                <div class="scale-control-group" id="pitchScaleGroup" style="display: none;">
                    <label>Scale:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="pitchScaleSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="linear">Linear (Hz)</option>
                            <option value="semitone">Semitone</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="pitchNormalizeGroup" style="display: none;">
                    <label>Normalize:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="pitchNormalizeSelect" style="padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                            <option value="none">None</option>
                            <option value="mean">To Mean</option>
                        </select>
                    </div>
                </div>
                <div class="scale-control-group" id="pitchShowConfidenceGroup" style="display: none;">
                    <label>Show Confidence:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="pitchShowConfidenceCheck">
                    </div>
                </div>
                <div class="scale-control-group" id="pitchShowUnvoicedGroup" style="display: none;">
                    <label>Show Gaps:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="pitchShowUnvoicedCheck" checked>
                    </div>
                </div>
                <div class="scale-control-group" id="pitchYRangeGroup" style="display: none;">
                    <label>Y Range:</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="number" id="pitchYMinInput" min="0" max="500" value="0" step="10"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;"
                               placeholder="Auto">
                        <span style="font-size: 11px; color: #6b7280;">-</span>
                        <input type="number" id="pitchYMaxInput" min="0" max="800" value="0" step="10"
                               style="width: 50px; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;"
                               placeholder="Auto">
                        <span style="font-size: 10px; color: #9ca3af;">Hz (0=auto)</span>
                    </div>
                </div>
            </div>

            <div id="rawDataExportContainer" style="display: none; margin-bottom: 15px; text-align: right;">
                <button id="exportRawData" class="btn btn-secondary" style="padding: 10px 20px;">
                    <span>üìä</span>
                    <span>Export Raw Data (JSON)</span>
                </button>
            </div>

            <!-- Export Options Modal -->
            <div id="exportModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
                <div style="background: white; padding: 25px; border-radius: 12px; max-width: 400px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2);">
                    <h3 style="margin: 0 0 15px 0; color: #374151;">Export Options</h3>
                    <p style="margin: 0 0 20px 0; color: #6b7280; font-size: 14px;">Choose what data to export:</p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="exportRawBtn" class="btn" style="padding: 12px 24px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            üì¶ Raw Data
                        </button>
                        <button id="exportFilteredBtn" class="btn" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            üéØ Filtered Peaks
                        </button>
                    </div>
                    <button id="exportCancelBtn" style="margin-top: 15px; padding: 8px 16px; background: transparent; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; color: #6b7280; font-size: 13px;">
                        Cancel
                    </button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="vizCanvas" width="1200" height="500"></canvas>
            </div>

            <div class="results" id="results">
                <div class="score-display">
                    <div class="score-circle">
                        <svg viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="45" class="score-bg"></circle>
                            <circle cx="50" cy="50" r="45" class="score-fill" id="scoreFill" 
                                    stroke-dasharray="283" stroke-dashoffset="283"></circle>
                        </svg>
                        <div class="score-text" id="scoreText">0</div>
                    </div>
                    <div class="score-info">
                        <h3 id="feedback">Analyzing...</h3>
                        <p id="detailedFeedback" style="font-size: 16px; color: #6b7280; line-height: 1.6;"></p>
                        <p id="methodIndicator" style="font-size: 14px; color: #9ca3af; margin-top: 10px; font-style: italic;"></p>
                    </div>
                </div>

                <div class="breakdown">
                    <div class="breakdown-item">
                        <span class="label">Pitch/Intonation (20%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="pitchBar" style="width: 0%"></div>
                        </div>
                        <span id="pitchScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">MFCCs (25%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="mfccBar" style="width: 0%"></div>
                        </div>
                        <span id="mfccScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">Envelope (15%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="envelopeBar" style="width: 0%"></div>
                        </div>
                        <span id="envelopeScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">Duration (10%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="durationBar" style="width: 0%"></div>
                        </div>
                        <span id="durationScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">Stress Position (10%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="stressPositionBar" style="width: 0%"></div>
                        </div>
                        <span id="stressPositionScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">Stress Pattern (10%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="stressBar" style="width: 0%"></div>
                        </div>
                        <span id="stressScore">0%</span>
                    </div>
                    <div class="breakdown-item">
                        <span class="label">Voice Quality (10%)</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="qualityBar" style="width: 0%"></div>
                        </div>
                        <span id="qualityScore">0%</span>
                    </div>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button id="tryAgain" class="btn btn-primary">
                        <span>üîÑ</span>
                        <span>Try Again</span>
                    </button>
                    <button id="aiAnalysisBtn" class="btn btn-secondary" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);" disabled>
                        <span>ü§ñ</span>
                        <span>AI Analysis</span>
                    </button>
                    <button id="copyBalancedPrompt" class="btn btn-secondary" style="background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);">
                        <span>üìã</span>
                        <span>Copy Balanced</span>
                    </button>
                    <button id="copyFullPrompt" class="btn btn-secondary" style="background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);">
                        <span>üìÑ</span>
                        <span>Copy Full</span>
                    </button>
                </div>
                
                <!-- AI Analysis Results -->
                <div id="aiAnalysisSection" style="display: none; margin-top: 20px;">
                    <div style="background: #d1fae5; border: 1px solid #10b981; padding: 15px; border-radius: 8px;">
                        <h4 style="margin: 0 0 10px 0; color: #059669;">ü§ñ AI Analysis</h4>
                        <div id="aiAnalysisContent" style="line-height: 1.6; color: #1f2937;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===================================================================
        // DEBUG LOGGER
        // ===================================================================
        const debugLog = {
            log: (message, type = 'info') => {
                console.log(message);
                const logDiv = document.getElementById('debugLog');
                if (logDiv) {
                    const line = document.createElement('div');
                    line.className = `debug-line ${type}`;
                    line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                    logDiv.appendChild(line);
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
            }
        };

        // ===================================================================
        // UTILITY FUNCTIONS
        // ===================================================================
        
        // Pearson correlation - statistically robust similarity measure
        function pearsonCorrelation(x, y) {
            const n = Math.min(x.length, y.length);
            if (n < 2) return 0;
            
            const x_ = x.slice(0, n);
            const y_ = y.slice(0, n);
            
            const meanX = x_.reduce((a, b) => a + b, 0) / n;
            const meanY = y_.reduce((a, b) => a + b, 0) / n;
            
            let num = 0, denX = 0, denY = 0;
            for (let i = 0; i < n; i++) {
                const dx = x_[i] - meanX;
                const dy = y_[i] - meanY;
                num += dx * dy;
                denX += dx * dx;
                denY += dy * dy;
            }
            
            const den = Math.sqrt(denX * denY);
            return den === 0 ? 0 : num / den;
        }
        
        // Extract RMS envelope from audio samples
        function extractEnvelope(samples, windowSize = 480, hopSize = 240) {
            const envelope = [];
            for (let i = 0; i < samples.length - windowSize; i += hopSize) {
                let sum = 0;
                for (let j = 0; j < windowSize; j++) {
                    sum += samples[i + j] * samples[i + j];
                }
                envelope.push(Math.sqrt(sum / windowSize));
            }
            return envelope;
        }
        
        // Resample array to target length
        function resampleArray(arr, targetLen) {
            if (arr.length === targetLen) return arr;
            if (arr.length === 0) return new Array(targetLen).fill(0);
            
            const result = [];
            for (let i = 0; i < targetLen; i++) {
                const srcIdx = (i / (targetLen - 1)) * (arr.length - 1);
                const lo = Math.floor(srcIdx);
                const hi = Math.min(lo + 1, arr.length - 1);
                const t = srcIdx - lo;
                result.push(arr[lo] * (1 - t) + arr[hi] * t);
            }
            return result;
        }

        // ===================================================================
        // API KEY MANAGEMENT
        // ===================================================================
        let anthropicApiKey = localStorage.getItem('anthropic_api_key') || null;
        
        function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (key && key.startsWith('sk-')) {
                anthropicApiKey = key;
                localStorage.setItem('anthropic_api_key', key);
                updateApiStatus(true);
                debugLog.log('API key saved to localStorage', 'success');
            } else {
                alert('Please enter a valid Anthropic API key (starts with sk-)');
            }
        }
        
        function clearApiKey() {
            anthropicApiKey = null;
            localStorage.removeItem('anthropic_api_key');
            document.getElementById('apiKeyInput').value = '';
            updateApiStatus(false);
            debugLog.log('API key cleared', 'info');
        }
        
        function updateApiStatus(configured) {
            const status = document.getElementById('apiStatus');
            const btn = document.getElementById('aiAnalysisBtn');
            if (configured) {
                status.textContent = 'API Configured ‚úì';
                status.className = 'api-status configured';
                if (btn) btn.disabled = false;
            } else {
                status.textContent = 'API Not Configured';
                status.className = 'api-status not-configured';
                if (btn) btn.disabled = true;
            }
        }

        // ===================================================================
        // GLOBAL STATE
        // ===================================================================
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let nativeBuffer = null;
        let userBuffer = null;
        let nativeAudioElement = null;
        let userAudioBlob = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let currentViz = 'waveform';
        let stream = null;
        let analysisResults = null;
        let detailedAnalysis = null;

        // Cache for computed spectra (to avoid recomputing on display mode switch)
        let spectrumCache = {
            nativeSpectrum: null,
            userSpectrum: null,
            nativeSpectrogram: null,
            userSpectrogram: null
        };

        // Scale preferences
        let scalePreferences = {
            amplitude: 'linear',
            waveformMode: 'bipolar',
            displayMode: 'overlay',
            spectrogramMag: 'linear',
            spectrogramFreq: 'linear',
            melBins: 80,
            filterMode: 'global',
            filterValue: 0,
            zoomX: 1,
            zoomY: 1,
            fftSize: 512,
            hopSize: 'auto',
            // Waveform filtering options
            waveformFilterMode: 'none',
            waveformThreshold: 0.01,
            waveformPercentile: 90,
            waveformRmsWindow: 64,
            waveformZoomX: 1,
            waveformZoomY: 1,
            waveformTimeStart: 0,
            waveformTimeEnd: 1,
            waveformDownsample: 'minmax',
            waveformNormalization: 'independent',
            // MFCC options
            mfccNumFilters: 60,
            mfccCoeffStart: 1,
            mfccCoeffEnd: 12,
            mfccShowDelta: false,
            mfccShowDeltaDelta: false,
            mfccLifter: 0,
            mfccFilterMode: 'none',
            mfccFilterValue: 0,
            mfccPerBinNorm: false,
            mfccZoomX: 1,
            mfccZoomY: 1,
            mfccColormap: 'bluered',
            mfccSymmetric: true,
            // Pitch options
            pitchConfidenceThreshold: 0,
            pitchSmoothingMode: 'median',
            pitchSmoothingWindow: 5,
            pitchScale: 'linear',
            pitchNormalize: 'none',
            pitchShowConfidence: false,
            pitchShowUnvoiced: true,
            pitchYMin: 0,
            pitchYMax: 0
        };
        
        // FFT size options mapping for slider
        const fftSizeOptions = [256, 512, 1024, 2048, 4096, 8192];

        let useFilter = true;
        let useDTW = true;

        // ===================================================================
        // UTILITY: SILENCE TRIMMING
        // ===================================================================
        function trimSilence(audioBuffer, fixedThreshold = 0.01) {
            const data = audioBuffer.getChannelData(0);
            const frameSize = 512;
            const sampleRate = audioBuffer.sampleRate;
            let start = 0;
            let end = data.length;
            
            debugLog.log(`Trimming silence: ${data.length} samples (${(data.length/sampleRate).toFixed(3)}s)`);
            
            const frameCount = Math.floor(data.length / frameSize);
            const rmsValues = [];
            
            for (let i = 0; i < frameCount; i++) {
                let rms = 0;
                const offset = i * frameSize;
                for (let j = 0; j < frameSize; j++) {
                    rms += data[offset + j] ** 2;
                }
                rms = Math.sqrt(rms / frameSize);
                rmsValues.push(rms);
            }
            
            const sortedRMS = [...rmsValues].sort((a, b) => a - b);
            const noiseFloor = sortedRMS[Math.floor(sortedRMS.length * 0.1)];
            const signalLevel = sortedRMS[Math.floor(sortedRMS.length * 0.9)];
            const dynamicThreshold = noiseFloor + (signalLevel - noiseFloor) * 0.2;
            const threshold = Math.max(fixedThreshold, dynamicThreshold);
            
            debugLog.log(`Threshold: fixed=${fixedThreshold.toFixed(4)}, dynamic=${dynamicThreshold.toFixed(4)}, using=${threshold.toFixed(4)}`);
            
            let consecutiveFrames = 0;
            const minSustainedFrames = 3;
            
            for (let i = 0; i < rmsValues.length; i++) {
                if (rmsValues[i] > threshold) {
                    consecutiveFrames++;
                    if (consecutiveFrames >= minSustainedFrames) {
                        start = Math.max(0, (i - consecutiveFrames) * frameSize);
                        debugLog.log(`Found start at frame ${i - consecutiveFrames}, sample ${start}`);
                        break;
                    }
                } else {
                    consecutiveFrames = 0;
                }
            }
            
            consecutiveFrames = 0;
            for (let i = rmsValues.length - 1; i >= 0; i--) {
                if (rmsValues[i] > threshold) {
                    consecutiveFrames++;
                    if (consecutiveFrames >= minSustainedFrames) {
                        end = Math.min(data.length, (i + consecutiveFrames + 1) * frameSize);
                        debugLog.log(`Found end at frame ${i + consecutiveFrames}, sample ${end}`);
                        break;
                    }
                } else {
                    consecutiveFrames = 0;
                }
            }
            
            if (start >= end) {
                debugLog.log('No trimming needed', 'info');
                return audioBuffer;
            }
            
            const trimmedLength = end - start;
            const trimmedBuffer = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                trimmedLength,
                sampleRate
            );
            
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const sourceData = audioBuffer.getChannelData(channel);
                const destData = trimmedBuffer.getChannelData(channel);
                for (let i = 0; i < trimmedLength; i++) {
                    destData[i] = sourceData[start + i];
                }
            }
            
            debugLog.log(`Trimmed: ${(data.length/sampleRate).toFixed(3)}s ‚Üí ${(trimmedLength/sampleRate).toFixed(3)}s`, 'success');
            
            return trimmedBuffer;
        }

        function medianFilter(array, windowSize = 5) {
            const result = [];
            const half = Math.floor(windowSize / 2);
            
            for (let i = 0; i < array.length; i++) {
                const window = [];
                for (let j = Math.max(0, i - half); j <= Math.min(array.length - 1, i + half); j++) {
                    window.push(array[j]);
                }
                window.sort((a, b) => a - b);
                result.push(window[Math.floor(window.length / 2)]);
            }
            
            return result;
        }

        // ===================================================================
        // IMPROVED LPC
        // ===================================================================
        class ImprovedLPC {
            static computeLPCSpectrum(lpcCoeffs, numPoints, sampleRate) {
                const spectrum = new Array(numPoints);
                
                for (let k = 0; k < numPoints; k++) {
                    const freq = (k * sampleRate) / (2 * numPoints);
                    const omega = (2 * Math.PI * freq) / sampleRate;
                    
                    let real = 1.0;
                    let imag = 0.0;
                    
                    for (let i = 1; i < lpcCoeffs.length; i++) {
                        const angle = omega * i;
                        real += lpcCoeffs[i] * Math.cos(angle);
                        imag += lpcCoeffs[i] * Math.sin(angle);
                    }
                    
                    // Use POWER spectrum (magnitude squared) for better peak prominence
                    const magSquared = real * real + imag * imag + 1e-10;
                    spectrum[k] = 1.0 / magSquared;
                }
                
                return spectrum;
            }
            
            static findSpectralPeaks(spectrum, sampleRate, minFreq = 90, maxFreq = 5000, numFormants = 4) {
                const numPoints = spectrum.length;
                const freqPerBin = sampleRate / (2 * numPoints);
                const minBin = Math.ceil(minFreq / freqPerBin);
                const maxBin = Math.floor(maxFreq / freqPerBin);

                // Find global max for dynamic threshold
                let globalMax = 0;
                for (let i = minBin; i < maxBin; i++) {
                    if (spectrum[i] > globalMax) globalMax = spectrum[i];
                }

                const peaks = [];
                const visited = new Array(spectrum.length).fill(false);

                // Multiple passes with decreasing threshold - start MUCH lower
                for (let threshold of [0.05, 0.02, 0.01, 0.005, 0.001]) {
                    if (peaks.length >= numFormants * 3) break;

                    for (let i = minBin + 1; i < maxBin - 1; i++) {
                        if (visited[i] || spectrum[i] < globalMax * threshold) continue;

                        // Simple local maximum check - just ¬±1 bin
                        if (spectrum[i] > spectrum[i-1] && spectrum[i] > spectrum[i+1]) {

                            // Log-domain parabolic interpolation for sub-bin accuracy
                            const y1 = Math.log(spectrum[i-1] + 1e-10);
                            const y2 = Math.log(spectrum[i] + 1e-10);
                            const y3 = Math.log(spectrum[i+1] + 1e-10);

                            let offset = 0;
                            const denom = y1 - 2*y2 + y3;
                            if (Math.abs(denom) > 1e-10) {
                                offset = 0.5 * (y1 - y3) / denom;
                                offset = Math.max(-0.5, Math.min(0.5, offset)); // Clamp
                            }
                            const refinedFreq = (i + offset) * freqPerBin;

                            peaks.push({
                                freq: refinedFreq,
                                magnitude: spectrum[i],
                                bandwidth: this.estimateBandwidth(spectrum, i, freqPerBin)
                            });

                            // Mark nearby bins as visited - smaller window
                            for (let j = i - 3; j <= i + 3; j++) {
                                if (j >= 0 && j < spectrum.length) visited[j] = true;
                            }
                        }
                    }
                }

                // If still not enough peaks, just take the strongest bins
                if (peaks.length < 3) {
                    const magnitudes = [];
                    for (let i = minBin; i < maxBin; i++) {
                        if (!visited[i]) {
                            magnitudes.push({ 
                                freq: i * freqPerBin, 
                                magnitude: spectrum[i],
                                bandwidth: 100
                            });
                        }
                    }
                    magnitudes.sort((a, b) => b.magnitude - a.magnitude);
                    
                    // Add top bins as peaks
                    for (const m of magnitudes.slice(0, 10)) {
                        if (peaks.length >= numFormants * 3) break;
                        // Check spacing from existing peaks
                        let tooClose = false;
                        for (const p of peaks) {
                            if (Math.abs(m.freq - p.freq) < 100) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) peaks.push(m);
                    }
                }

                // Sort by magnitude (strongest peaks first)
                peaks.sort((a, b) => b.magnitude - a.magnitude);

                // Select best candidates with minimum spacing
                const selected = [];
                const minSpacing = 120; // Hz minimum between formants - reduced from 150

                for (const peak of peaks) {
                    if (selected.length >= numFormants * 2) break;
                    
                    // Check spacing from all already-selected peaks
                    let tooClose = false;
                    for (const sel of selected) {
                        if (Math.abs(peak.freq - sel.freq) < minSpacing) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        selected.push(peak);
                    }
                }

                // Sort selected peaks by frequency for formant assignment
                selected.sort((a, b) => a.freq - b.freq);

                return selected;
            }
            
            static estimateBandwidth(spectrum, peakIndex, freqPerBin) {
                if (peakIndex <= 0 || peakIndex >= spectrum.length - 1) {
                    return 100;
                }
                
                const peakMag = spectrum[peakIndex];
                const halfPower = peakMag / Math.sqrt(2);
                
                let leftIdx = peakIndex;
                while (leftIdx > 0 && spectrum[leftIdx] > halfPower) {
                    leftIdx--;
                }
                
                let rightIdx = peakIndex;
                while (rightIdx < spectrum.length - 1 && spectrum[rightIdx] > halfPower) {
                    rightIdx++;
                }
                
                const bandwidth = Math.max(50, (rightIdx - leftIdx) * freqPerBin);
                return bandwidth;
            }
            
            static autocorrelation(signal, maxLag) {
                const result = new Array(maxLag + 1).fill(0);
                const n = signal.length;
                
                for (let lag = 0; lag <= maxLag; lag++) {
                    let sum = 0;
                    for (let i = 0; i < n - lag; i++) {
                        sum += signal[i] * signal[i + lag];
                    }
                    result[lag] = sum / (n - lag);
                }
                
                return result;
            }
            
            static levinsonDurbin(autocorr, order) {
                const lpc = new Array(order + 1).fill(0);
                lpc[0] = 1;
                
                const error = new Array(order + 1).fill(0);
                error[0] = autocorr[0];
                
                const k = new Array(order).fill(0);
                
                for (let i = 1; i <= order; i++) {
                    let lambda = autocorr[i];
                    
                    for (let j = 1; j < i; j++) {
                        lambda -= lpc[j] * autocorr[i - j];
                    }
                    
                    lambda /= error[i - 1];
                    k[i - 1] = -lambda;
                    
                    const tmpLPC = lpc.slice();
                    lpc[i] = -lambda;
                    
                    for (let j = 1; j < i; j++) {
                        lpc[j] = tmpLPC[j] - lambda * tmpLPC[i - j];
                    }
                    
                    error[i] = error[i - 1] * (1 - lambda * lambda);
                }
                
                return { lpc, error: error[order], reflectionCoeffs: k };
            }
            
            // ===============================================
            // POLYNOMIAL ROOT-FINDING FOR FORMANTS
            // This is the mathematically correct method used by Praat
            // ===============================================
            
            // Complex number helper functions
            static complexMultiply(a, b) {
                return {
                    real: a.real * b.real - a.imag * b.imag,
                    imag: a.real * b.imag + a.imag * b.real
                };
            }
            
            static complexDivide(a, b) {
                const denom = b.real * b.real + b.imag * b.imag;
                if (denom < 1e-20) return { real: 0, imag: 0 };
                return {
                    real: (a.real * b.real + a.imag * b.imag) / denom,
                    imag: (a.imag * b.real - a.real * b.imag) / denom
                };
            }
            
            static complexSubtract(a, b) {
                return {
                    real: a.real - b.real,
                    imag: a.imag - b.imag
                };
            }
            
            static complexAbs(z) {
                return Math.sqrt(z.real * z.real + z.imag * z.imag);
            }
            
            static complexAngle(z) {
                return Math.atan2(z.imag, z.real);
            }
            
            // Evaluate polynomial at complex point z
            // coeffs[0] is the highest degree term (z^n), coeffs[n] is constant
            static evaluatePolynomial(coeffs, z) {
                let result = { real: coeffs[0], imag: 0 };
                for (let i = 1; i < coeffs.length; i++) {
                    result = this.complexMultiply(result, z);
                    result.real += coeffs[i];
                }
                return result;
            }
            
            // Durand-Kerner method for finding polynomial roots
            // This iteratively finds all roots simultaneously
            static findPolynomialRoots(coeffs, maxIterations = 200, tolerance = 1e-10) {
                const n = coeffs.length - 1; // Degree
                if (n <= 0) return [];
                
                // Normalize so leading coefficient is 1
                const a0 = coeffs[0];
                if (Math.abs(a0) < 1e-15) return [];
                const normalizedCoeffs = coeffs.map(c => c / a0);
                
                // Initial guesses: use Aberth-style initialization
                // Estimate root radius from coefficients
                let maxCoeff = 0;
                for (let i = 1; i < normalizedCoeffs.length; i++) {
                    maxCoeff = Math.max(maxCoeff, Math.abs(normalizedCoeffs[i]));
                }
                const radius = 1 + maxCoeff; // Upper bound on root magnitude
                
                const roots = [];
                for (let i = 0; i < n; i++) {
                    // Spread initial guesses on circle, with slight variations
                    const angle = (2 * Math.PI * i) / n + 0.3;
                    const r = radius * (0.4 + 0.2 * (i % 3)); // Vary radius
                    roots.push({
                        real: r * Math.cos(angle),
                        imag: r * Math.sin(angle)
                    });
                }
                
                // Iterate Durand-Kerner with Aberth correction
                for (let iter = 0; iter < maxIterations; iter++) {
                    let maxDelta = 0;
                    
                    for (let i = 0; i < n; i++) {
                        // Evaluate polynomial at root[i]
                        const pz = this.evaluatePolynomial(normalizedCoeffs, roots[i]);
                        
                        // Compute product of (root[i] - root[j]) for j != i
                        let product = { real: 1, imag: 0 };
                        for (let j = 0; j < n; j++) {
                            if (i !== j) {
                                const diff = this.complexSubtract(roots[i], roots[j]);
                                // Avoid division by zero
                                if (this.complexAbs(diff) < 1e-12) {
                                    diff.real += 1e-8;
                                    diff.imag += 1e-8;
                                }
                                product = this.complexMultiply(product, diff);
                            }
                        }
                        
                        // Avoid division by zero
                        if (this.complexAbs(product) < 1e-15) {
                            continue;
                        }
                        
                        // Update: root[i] = root[i] - p(root[i]) / product
                        const delta = this.complexDivide(pz, product);
                        roots[i] = this.complexSubtract(roots[i], delta);
                        
                        maxDelta = Math.max(maxDelta, this.complexAbs(delta));
                    }
                    
                    if (maxDelta < tolerance) {
                        break;
                    }
                }
                
                return roots;
            }
            
            // Alternative: Laguerre's method for finding one root at a time
            // More robust for ill-conditioned polynomials
            static laguerreRoot(coeffs, initialGuess, maxIter = 50) {
                const n = coeffs.length - 1;
                let x = { ...initialGuess };
                
                for (let iter = 0; iter < maxIter; iter++) {
                    const p = this.evaluatePolynomial(coeffs, x);
                    if (this.complexAbs(p) < 1e-14) break;
                    
                    // Compute p'(x) and p''(x)
                    let dp = { real: 0, imag: 0 };
                    let ddp = { real: 0, imag: 0 };
                    
                    for (let i = 0; i < n; i++) {
                        const coeff = coeffs[i] * (n - i);
                        const power = n - i - 1;
                        if (power >= 0) {
                            let term = { real: coeff, imag: 0 };
                            for (let j = 0; j < power; j++) {
                                term = this.complexMultiply(term, x);
                            }
                            dp.real += term.real;
                            dp.imag += term.imag;
                        }
                    }
                    
                    for (let i = 0; i < n - 1; i++) {
                        const coeff = coeffs[i] * (n - i) * (n - i - 1);
                        const power = n - i - 2;
                        if (power >= 0) {
                            let term = { real: coeff, imag: 0 };
                            for (let j = 0; j < power; j++) {
                                term = this.complexMultiply(term, x);
                            }
                            ddp.real += term.real;
                            ddp.imag += term.imag;
                        }
                    }
                    
                    // G = p'/p, H = G^2 - p''/p
                    const G = this.complexDivide(dp, p);
                    const G2 = this.complexMultiply(G, G);
                    const H = this.complexSubtract(G2, this.complexDivide(ddp, p));
                    
                    // Laguerre's formula
                    const nC = { real: n, imag: 0 };
                    const n1 = { real: n - 1, imag: 0 };
                    const nH = this.complexMultiply(nC, H);
                    const G2term = this.complexMultiply(G, G);
                    const disc = this.complexSubtract(this.complexMultiply(n1, nH), this.complexMultiply(n1, G2term));
                    
                    // sqrt of discriminant (simplified)
                    const discMag = this.complexAbs(disc);
                    const discAngle = this.complexAngle(disc);
                    const sqrtDisc = {
                        real: Math.sqrt(discMag) * Math.cos(discAngle / 2),
                        imag: Math.sqrt(discMag) * Math.sin(discAngle / 2)
                    };
                    
                    // Choose sign to maximize denominator
                    const denom1 = { real: G.real + sqrtDisc.real, imag: G.imag + sqrtDisc.imag };
                    const denom2 = { real: G.real - sqrtDisc.real, imag: G.imag - sqrtDisc.imag };
                    const denom = this.complexAbs(denom1) > this.complexAbs(denom2) ? denom1 : denom2;
                    
                    if (this.complexAbs(denom) < 1e-15) break;
                    
                    const a = this.complexDivide(nC, denom);
                    x = this.complexSubtract(x, a);
                    
                    if (this.complexAbs(a) < 1e-10) break;
                }
                
                return x;
            }
            
            // Find all roots using Laguerre + deflation
            static findRootsLaguerre(coeffs) {
                const n = coeffs.length - 1;
                if (n <= 0) return [];
                
                const roots = [];
                let currentCoeffs = coeffs.slice();
                
                for (let i = 0; i < n; i++) {
                    // Initial guess
                    const guess = { real: 0.5, imag: 0.5 };
                    const root = this.laguerreRoot(currentCoeffs, guess);
                    roots.push(root);
                    
                    // Deflate polynomial by dividing out (x - root)
                    const newCoeffs = [currentCoeffs[0]];
                    for (let j = 1; j < currentCoeffs.length; j++) {
                        const prev = newCoeffs[j - 1];
                        const term = this.complexMultiply(prev, root);
                        newCoeffs.push(currentCoeffs[j] + term.real); // Approximate for real coeffs
                    }
                    currentCoeffs = newCoeffs.slice(0, -1);
                }
                
                // Polish roots with original polynomial
                for (let i = 0; i < roots.length; i++) {
                    roots[i] = this.laguerreRoot(coeffs, roots[i], 20);
                }
                
                return roots;
            }
            
            // Extract formants from LPC polynomial roots
            static extractFormantsFromRoots(lpcCoeffs, sampleRate) {
                // LPC polynomial is A(z) = 1 + a1*z^-1 + a2*z^-2 + ...
                // We want roots of z^n * A(z) = z^n + a1*z^(n-1) + ... + an
                // So we reverse and use the coefficients directly
                const n = lpcCoeffs.length - 1;
                
                // Build polynomial: z^n + a1*z^(n-1) + ... + an
                // coeffs[0] = 1 (z^n), coeffs[1] = a1, ..., coeffs[n] = an
                const polyCoeffs = lpcCoeffs.slice(); // [1, a1, a2, ..., an]
                
                // Try Durand-Kerner first
                let roots = this.findPolynomialRoots(polyCoeffs);
                
                // If that didn't work well, try Laguerre
                if (roots.length < n / 2) {
                    roots = this.findRootsLaguerre(polyCoeffs);
                }
                
                // Extract formant candidates from roots
                const formantCandidates = [];
                let debugRoots = [];
                let rejectedCount = { tooSmall: 0, tooLarge: 0, negative: 0, freqRange: 0, bwRange: 0 };
                
                for (const root of roots) {
                    const r = this.complexAbs(root);
                    const theta = this.complexAngle(root);
                    const frequency = (Math.abs(theta) * sampleRate) / (2 * Math.PI);
                    const bandwidth = r > 0.01 ? (-Math.log(r) * sampleRate) / Math.PI : 10000;
                    
                    debugRoots.push({r: r.toFixed(3), theta: theta.toFixed(3), freq: Math.round(frequency), bw: Math.round(bandwidth)});
                    
                    // Track why roots are rejected
                    if (r <= 0.3) { rejectedCount.tooSmall++; continue; }
                    if (r >= 0.995) { rejectedCount.tooLarge++; continue; }
                    if (theta <= 0.01) { rejectedCount.negative++; continue; }
                    if (frequency < 90 || frequency > 5500) { rejectedCount.freqRange++; continue; }
                    if (bandwidth >= 1500) { rejectedCount.bwRange++; continue; }
                    
                    formantCandidates.push({
                        freq: frequency,
                        bandwidth: bandwidth,
                        magnitude: r
                    });
                }
                
                // Log debug info
                debugLog.log(`Polynomial degree: ${n}, found ${roots.length} roots`);
                if (debugRoots.length > 0) {
                    debugLog.log(`Sample roots: ${debugRoots.slice(0, 4).map(r => 
                        `r=${r.r},Œ∏=${r.theta}‚Üí${r.freq}Hz(bw${r.bw})`).join(' | ')}`);
                }
                debugLog.log(`Rejected: tooSmall=${rejectedCount.tooSmall}, tooLarge=${rejectedCount.tooLarge}, neg=${rejectedCount.negative}, freq=${rejectedCount.freqRange}, bw=${rejectedCount.bwRange}`);
                
                // Sort by frequency
                formantCandidates.sort((a, b) => a.freq - b.freq);
                
                return formantCandidates;
            }
            
            static extractFormants(audioBuffer, options = {}) {
                const {
                    frameSize = 2048,
                    hopSize = 512,
                    // LPC order: 12-14 works well for formant detection
                    // Too high causes over-smoothing, too low misses formants
                    lpcOrder = 14,
                    preEmphasisAlpha = 0.97
                } = options;
                
                const data = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                const formantTracks = [];
                
                let voicedCount = 0;
                let unvoicedCount = 0;
                
                const detailedFrames = [];
                
                // Compute adaptive energy threshold based on signal statistics
                let maxEnergy = 0;
                let energySum = 0;
                let energyCount = 0;
                
                for (let i = 0; i < data.length - frameSize; i += hopSize * 4) { // Sample every 4th frame for speed
                    const frame = Array.from(data.slice(i, i + frameSize));
                    const windowed = this.applyHammingWindow(frame);
                    const energy = this.computeEnergy(windowed);
                    if (energy > maxEnergy) maxEnergy = energy;
                    energySum += energy;
                    energyCount++;
                }
                
                const avgEnergy = energySum / energyCount;
                // Use 10% of average energy as threshold, with a minimum floor
                const energyThreshold = Math.max(avgEnergy * 0.1, 0.001);
                
                debugLog.log(`Extracting formants: ${data.length} samples, ${sampleRate}Hz`);
                debugLog.log(`Method: LPC spectrum peak-picking (improved)`);
                debugLog.log(`Adaptive energy threshold: ${energyThreshold.toFixed(6)} (avg: ${avgEnergy.toFixed(6)}, max: ${maxEnergy.toFixed(6)})`);
                
                for (let i = 0; i < data.length - frameSize; i += hopSize) {
                    const frame = Array.from(data.slice(i, i + frameSize));
                    
                    const windowed = this.applyHammingWindow(frame);
                    
                    // Compute energy BEFORE pre-emphasis (pre-emphasis reduces voiced speech energy)
                    const energy = this.computeEnergy(windowed);
                    const zcr = this.computeZCR(windowed);
                    
                    const emphasized = this.preEmphasis(windowed, preEmphasisAlpha);
                    
                    // Use adaptive energy threshold instead of fixed value
                    const isVoiced = energy > energyThreshold && zcr < 0.5;
                    
                    const frameData = {
                        frameIndex: Math.floor(i / hopSize),
                        time: i / sampleRate,
                        energy: energy,
                        zcr: zcr,
                        isVoiced: isVoiced
                    };
                    
                    if (!isVoiced) {
                        unvoicedCount++;
                        formantTracks.push({
                            time: i / sampleRate,
                            f1: formantTracks.length > 0 ? formantTracks[formantTracks.length - 1].f1 : 500,
                            f2: formantTracks.length > 0 ? formantTracks[formantTracks.length - 1].f2 : 1500,
                            f3: formantTracks.length > 0 ? formantTracks[formantTracks.length - 1].f3 : 2500,
                            voiced: false
                        });
                        
                        frameData.formants = null;
                        frameData.reason = 'unvoiced';
                        detailedFrames.push(frameData);
                        continue;
                    }
                    
                    voicedCount++;
                    
                    const autocorr = this.autocorrelation(emphasized, lpcOrder);
                    const { lpc } = this.levinsonDurbin(autocorr, lpcOrder);
                    
                    // Validate LPC coefficients
                    let lpcValid = true;
                    for (let k = 0; k < lpc.length; k++) {
                        if (!isFinite(lpc[k]) || Math.abs(lpc[k]) > 100) {
                            lpcValid = false;
                            break;
                        }
                    }
                    
                    if (!lpcValid) {
                        unvoicedCount++;
                        voicedCount--;
                        formantTracks.push({
                            time: i / sampleRate,
                            f1: 0, f2: 0, f3: 0,
                            voiced: false
                        });
                        frameData.formants = null;
                        frameData.reason = 'invalid LPC coefficients';
                        detailedFrames.push(frameData);
                        continue;
                    }
                    
                    // Compute LPC spectrum and find peaks
                    const spectrum = this.computeLPCSpectrum(lpc, 1024, sampleRate);
                    
                    // DEBUG: Log spectrum stats for first voiced frame
                    if (voicedCount === 1) {
                        let minSpec = Infinity, maxSpec = 0, sumSpec = 0;
                        for (let k = 0; k < spectrum.length; k++) {
                            if (spectrum[k] < minSpec) minSpec = spectrum[k];
                            if (spectrum[k] > maxSpec) maxSpec = spectrum[k];
                            sumSpec += spectrum[k];
                        }
                        debugLog.log(`LPC Spectrum stats - min: ${minSpec.toFixed(4)}, max: ${maxSpec.toFixed(4)}, avg: ${(sumSpec/spectrum.length).toFixed(4)}, range: ${(maxSpec/minSpec).toFixed(1)}x`);
                    }
                    
                    const peaks = this.findSpectralPeaks(spectrum, sampleRate, 90, 5000, 8);
                    
                    // DEBUG: Log for first voiced frame
                    if (voicedCount === 1) {
                        debugLog.log(`LPC spectrum peaks found: ${peaks.length}`);
                        if (peaks.length > 0) {
                            debugLog.log(`Peak frequencies: ${peaks.map(p => Math.round(p.freq) + 'Hz').join(', ')}`);
                        }
                    }
                    
                    // Select formants with proper range constraints
                    let f1 = null, f2 = null, f3 = null;
                    let hasValidFormants = false;
                    
                    // Need at least 2 peaks for F1 and F2
                    if (peaks.length >= 2) {
                        // F1: First peak in typical F1 range (200-1200 Hz)
                        // Skip peaks below 200Hz as they're likely F0
                        for (const peak of peaks) {
                            if (peak.freq >= 200 && peak.freq <= 1200) {
                                f1 = peak.freq;
                                break;
                            }
                        }
                        
                        // If no peak in strict F1 range, take first peak above 150 Hz
                        if (!f1) {
                            for (const peak of peaks) {
                                if (peak.freq >= 150 && peak.freq <= 1500) {
                                    f1 = peak.freq;
                                    break;
                                }
                            }
                        }
                        
                        if (f1) {
                            // F2: Next peak separated from F1, in F2 range (600-3200 Hz)
                            for (const peak of peaks) {
                                if (peak.freq > f1 + 150 && peak.freq >= 500 && peak.freq <= 3500) {
                                    f2 = peak.freq;
                                    break;
                                }
                            }
                            
                            // Fallback: any peak sufficiently separated from F1
                            if (!f2) {
                                for (const peak of peaks) {
                                    if (peak.freq > f1 + 100) {
                                        f2 = peak.freq;
                                        break;
                                    }
                                }
                            }
                            
                            if (f2) {
                                // F3: Next peak separated from F2
                                for (const peak of peaks) {
                                    if (peak.freq > f2 + 150 && peak.freq <= 4500) {
                                        f3 = peak.freq;
                                        break;
                                    }
                                }
                                
                                // If no F3 found, estimate based on F2
                                if (!f3) {
                                    f3 = Math.min(f2 * 1.4 + 600, 4000);
                                }
                                
                                // Valid if F2 > F1
                                if (f2 > f1) {
                                    hasValidFormants = true;
                                }
                            }
                        }
                    }
                    
                    // Last resort: if we have any 2 peaks above 150Hz, use them
                    if (!hasValidFormants && peaks.length >= 2) {
                        const validPeaks = peaks.filter(p => p.freq >= 150);
                        if (validPeaks.length >= 2) {
                            f1 = validPeaks[0].freq;
                            f2 = validPeaks[1].freq;
                            f3 = validPeaks.length >= 3 ? validPeaks[2].freq : f2 * 1.5 + 500;
                            
                            if (f2 > f1) {
                                hasValidFormants = true;
                            }
                        }
                    }
                    
                    // If we couldn't find valid formants, mark as unvoiced
                    if (!hasValidFormants) {
                        unvoicedCount++;
                        voicedCount--; // Correct the earlier increment
                        formantTracks.push({
                            time: i / sampleRate,
                            f1: 0,
                            f2: 0,
                            f3: 0,
                            voiced: false
                        });
                        
                        frameData.formants = null;
                        frameData.reason = 'no valid formant peaks';
                        frameData.peaksFound = peaks.length;
                        frameData.peakFreqs = peaks.slice(0, 5).map(p => Math.round(p.freq));
                        detailedFrames.push(frameData);
                        continue;
                    }
                    
                    // Apply smoothing for valid formants
                    if (formantTracks.length > 0) {
                        const prev = formantTracks[formantTracks.length - 1];
                        if (prev.voiced) {
                            const f1Jump = Math.abs(f1 - prev.f1);
                            const f2Jump = Math.abs(f2 - prev.f2);
                            const f3Jump = Math.abs(f3 - prev.f3);
                            
                            if (f1Jump > 300) f1 = prev.f1 * 0.7 + f1 * 0.3;
                            if (f2Jump > 500) f2 = prev.f2 * 0.7 + f2 * 0.3;
                            if (f3Jump > 600) f3 = prev.f3 * 0.7 + f3 * 0.3;
                        }
                    }
                    
                    frameData.formants = {
                        f1: Math.round(f1),
                        f2: Math.round(f2),
                        f3: Math.round(f3)
                    };
                    
                    detailedFrames.push(frameData);
                    
                    formantTracks.push({
                        time: i / sampleRate,
                        f1: f1,
                        f2: f2,
                        f3: f3,
                        voiced: true,
                        peaks: peaks
                    });
                }
                
                const f1Smooth = this.medianFilter(formantTracks.map(f => f.f1), 5);
                const f2Smooth = this.medianFilter(formantTracks.map(f => f.f2), 5);
                const f3Smooth = this.medianFilter(formantTracks.map(f => f.f3), 5);
                
                debugLog.log(`Extracted ${formantTracks.length} formant frames (${voicedCount} voiced, ${unvoicedCount} unvoiced)`, 'success');
                
                const result = formantTracks.map((track, i) => ({
                    time: track.time,
                    f1: f1Smooth[i],
                    f2: f2Smooth[i],
                    f3: f3Smooth[i],
                    voiced: track.voiced
                }));
                
                result.detailedFrames = detailedFrames;
                result.summary = {
                    totalFrames: formantTracks.length,
                    voicedFrames: voicedCount,
                    unvoicedFrames: unvoicedCount,
                    voicedPercentage: ((voicedCount / formantTracks.length) * 100).toFixed(1),
                    avgF1: (f1Smooth.reduce((a,b) => a+b, 0) / f1Smooth.length).toFixed(1),
                    avgF2: (f2Smooth.reduce((a,b) => a+b, 0) / f2Smooth.length).toFixed(1),
                    avgF3: (f3Smooth.reduce((a,b) => a+b, 0) / f3Smooth.length).toFixed(1)
                };
                
                return result;
            }
            
            static applyHammingWindow(signal) {
                return signal.map((sample, i) =>
                    sample * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (signal.length - 1)))
                );
            }
            
            static preEmphasis(signal, alpha = 0.97) {
                const result = new Array(signal.length);
                result[0] = signal[0];
                for (let i = 1; i < signal.length; i++) {
                    result[i] = signal[i] - alpha * signal[i - 1];
                }
                return result;
            }
            
            static computeEnergy(signal) {
                let sum = 0;
                for (let i = 0; i < signal.length; i++) {
                    sum += signal[i] * signal[i];
                }
                return Math.sqrt(sum / signal.length);
            }
            
            static computeZCR(signal) {
                let crossings = 0;
                for (let i = 1; i < signal.length; i++) {
                    if ((signal[i - 1] >= 0 && signal[i] < 0) ||
                        (signal[i - 1] < 0 && signal[i] >= 0)) {
                        crossings++;
                    }
                }
                return crossings / signal.length;
            }
            
            static medianFilter(array, windowSize = 5) {
                const result = [];
                const half = Math.floor(windowSize / 2);
                
                for (let i = 0; i < array.length; i++) {
                    const window = [];
                    for (let j = Math.max(0, i - half); j <= Math.min(array.length - 1, i + half); j++) {
                        window.push(array[j]);
                    }
                    window.sort((a, b) => a - b);
                    result.push(window[Math.floor(window.length / 2)]);
                }
                
                return result;
            }
        }

        // ===================================================================
        // ACOUSTIC ANALYSIS ENGINE
        // ===================================================================
        class AcousticAnalyzer {
            constructor(audioBuffer) {
                this.buffer = audioBuffer;
                this.data = audioBuffer.getChannelData(0);
                this.sampleRate = audioBuffer.sampleRate;
            }
            
            extractFormants() {
                debugLog.log('Starting formant extraction...');
                return ImprovedLPC.extractFormants(this.buffer);
            }
            
            extractPitch() {
                const frameSize = 2048;
                const hopSize = 128;    // Fine temporal resolution for single words
                const minPitch = 75;
                const maxPitch = 500;
                const pitchTrack = [];
                const detailedFrames = [];
                
                debugLog.log(`Starting pitch extraction (frame=${frameSize}, hop=${hopSize})...`);
                
                for (let i = 0; i < this.data.length - frameSize; i += hopSize) {
                    const frame = this.data.slice(i, i + frameSize);
                    const result = this.estimatePitchDetailed(Array.from(frame), minPitch, maxPitch);
                    
                    pitchTrack.push({
                        time: i / this.sampleRate,
                        pitch: result.pitch,
                        confidence: result.confidence
                    });
                    
                    detailedFrames.push({
                        frameIndex: Math.floor(i / hopSize),
                        time: i / this.sampleRate,
                        pitch: result.pitch,
                        confidence: result.confidence,
                        bestLag: result.bestLag,
                        maxCorrelation: result.maxCorr,
                        isVoiced: result.pitch > 0
                    });
                }
                
                // Initialize cleaned array from raw pitch values
                const cleaned = pitchTrack.map(p => p.pitch);
                
                // NEW: Pass 0 - Handle first frame specially by looking forward
                if (cleaned.length > 2 && cleaned[0] > 0) {
                    const next = cleaned[1] || cleaned[2];
                    if (next > 0) {
                        const half = cleaned[0] / 2;
                        const double = cleaned[0] * 2;
                        
                        const currentDist = Math.abs(cleaned[0] - next);
                        const halfDist = Math.abs(half - next);
                        const doubleDist = Math.abs(double - next);
                        
                        if (halfDist < currentDist && half >= minPitch) {
                            debugLog.log(`Octave correction at frame 0: ${cleaned[0].toFixed(1)} ‚Üí ${half.toFixed(1)} Hz`);
                            cleaned[0] = half;
                        } else if (doubleDist < currentDist && double <= maxPitch) {
                            debugLog.log(`Octave correction at frame 0: ${cleaned[0].toFixed(1)} ‚Üí ${double.toFixed(1)} Hz`);
                            cleaned[0] = double;
                        }
                    }
                }

                // Pass 1: Remove octave errors (comparing with neighbors)
                for (let i = 1; i < cleaned.length - 1; i++) {
                    if (cleaned[i] === 0) continue;
                    
                    const prev = cleaned[i - 1] > 0 ? cleaned[i - 1] : cleaned[i];
                    const next = cleaned[i + 1] > 0 ? cleaned[i + 1] : cleaned[i];
                    
                    const context = [prev, next].sort((a, b) => a - b);
                    const medianContext = context[Math.floor(context.length / 2)];
                    
                    if (cleaned[i] > medianContext * 1.5 || cleaned[i] < medianContext * 0.67) {
                        const half = cleaned[i] / 2;
                        const double = cleaned[i] * 2;
                        
                        const currentDist = Math.abs(cleaned[i] - medianContext);
                        const halfDist = Math.abs(half - medianContext);
                        const doubleDist = Math.abs(double - medianContext);
                        
                        if (halfDist < currentDist && half >= minPitch) {
                            debugLog.log(`Octave correction at frame ${i}: ${cleaned[i].toFixed(1)} ‚Üí ${half.toFixed(1)} Hz`);
                            cleaned[i] = half;
                        } else if (doubleDist < currentDist && double <= maxPitch) {
                            debugLog.log(`Octave correction at frame ${i}: ${cleaned[i].toFixed(1)} ‚Üí ${double.toFixed(1)} Hz`);
                            cleaned[i] = double;
                        }
                    }
                }

                // Pass 2: Aggressive outlier removal BEFORE median filtering
                for (let i = 1; i < cleaned.length; i++) {
                    if (cleaned[i] === 0 || cleaned[i-1] === 0) continue;
                    
                    const ratio = cleaned[i] / cleaned[i-1];
                    if (ratio > 1.5 || ratio < 0.67) {
                        if (i < cleaned.length - 1 && cleaned[i+1] > 0) {
                            cleaned[i] = (cleaned[i-1] + cleaned[i+1]) / 2;
                            debugLog.log(`Interpolated outlier at frame ${i}: was ${pitchTrack[i].pitch.toFixed(1)}, now ${cleaned[i].toFixed(1)}`);
                        } else {
                            cleaned[i] = cleaned[i-1];
                        }
                    }
                }
                
                // Now apply median smoothing
                const smoothed = medianFilter(cleaned, 5);
                
                // Pass 3: One final pass for any remaining outliers after smoothing
                for (let i = 1; i < smoothed.length; i++) {
                    if (smoothed[i] === 0 || smoothed[i-1] === 0) continue;
                    
                    const ratio = smoothed[i] / smoothed[i-1];
                    if (ratio > 1.5 || ratio < 0.67) {
                        if (i < smoothed.length - 1 && smoothed[i+1] > 0) {
                            smoothed[i] = (smoothed[i-1] + smoothed[i+1]) / 2;
                            debugLog.log(`Final interpolation at frame ${i}`);
                        } else {
                            smoothed[i] = smoothed[i-1];
                        }
                    }
                }
                
                debugLog.log(`Extracted ${pitchTrack.length} pitch frames`, 'success');
                
                const result = pitchTrack.map((p, i) => ({
                    time: p.time,
                    pitch: smoothed[i],
                    confidence: p.confidence
                }));
                
                result.detailedFrames = detailedFrames;
                const voicedPitches = smoothed.filter(p => p > 0);
                result.summary = {
                    totalFrames: pitchTrack.length,
                    voicedFrames: voicedPitches.length,
                    unvoicedFrames: pitchTrack.length - voicedPitches.length,
                    avgPitch: voicedPitches.length > 0 ? 
                        (voicedPitches.reduce((a,b) => a+b, 0) / voicedPitches.length).toFixed(1) : 0,
                    minPitch: voicedPitches.length > 0 ? Math.min(...voicedPitches).toFixed(1) : 0,
                    maxPitch: voicedPitches.length > 0 ? Math.max(...voicedPitches).toFixed(1) : 0
                };
                
                return result;
            }
            
            estimatePitchDetailed(frame, minPitch, maxPitch) {
                const minLag = Math.floor(this.sampleRate / maxPitch);
                const maxLag = Math.floor(this.sampleRate / minPitch);
                
                let maxCorr = -Infinity;
                let bestLag = 0;
                
                for (let lag = minLag; lag < maxLag; lag++) {
                    let corr = 0;
                    let energy1 = 0;
                    let energy2 = 0;
                    
                    for (let i = 0; i < frame.length - lag; i++) {
                        corr += frame[i] * frame[i + lag];
                        energy1 += frame[i] * frame[i];
                        energy2 += frame[i + lag] * frame[i + lag];
                    }
                    
                    // Proper normalized autocorrelation
                    corr /= Math.sqrt(energy1 * energy2 + 1e-10);
                    
                    if (corr > maxCorr) {
                        maxCorr = corr;
                        bestLag = lag;
                    }
                }
                
                if (maxCorr < 0.2) {
                    return { pitch: 0, confidence: maxCorr, bestLag: 0, maxCorr: maxCorr };
                }
                
                return {
                    pitch: this.sampleRate / bestLag,
                    confidence: maxCorr,
                    bestLag: bestLag,
                    maxCorr: maxCorr
                };
            }
            
            extractIntensity() {
                const frameSize = 2048;
                const hopSize = 512;
                const intensity = [];
                
                for (let i = 0; i < this.data.length - frameSize; i += hopSize) {
                    let sum = 0;
                    for (let j = 0; j < frameSize; j++) {
                        sum += this.data[i + j] ** 2;
                    }
                    intensity.push({
                        time: i / this.sampleRate,
                        intensity: Math.sqrt(sum / frameSize)
                    });
                }
                
                return intensity;
            }
            
            extractZCR() {
                const frameSize = 2048;
                const hopSize = 512;
                const zcr = [];
                
                for (let i = 0; i < this.data.length - frameSize; i += hopSize) {
                    let crossings = 0;
                    for (let j = 1; j < frameSize; j++) {
                        if ((this.data[i + j - 1] >= 0 && this.data[i + j] < 0) ||
                            (this.data[i + j - 1] < 0 && this.data[i + j] >= 0)) {
                            crossings++;
                        }
                    }
                    zcr.push({
                        time: i / this.sampleRate,
                        zcr: crossings / frameSize
                    });
                }
                
                return zcr;
            }
            
            extractSpectralTilt() {
                const frameSize = 1024;
                const hopSize = 512;
                const tilt = [];
                
                for (let i = 0; i < this.data.length - frameSize; i += hopSize) {
                    const frame = Array.from(this.data.slice(i, i + frameSize));
                    const windowed = ImprovedLPC.applyHammingWindow(frame);
                    const spectrum = this.computeFFT(windowed);
                    
                    const lowCutoff = Math.floor(spectrum.length * 0.3);
                    let lowEnergy = 0;
                    let highEnergy = 0;
                    
                    for (let j = 0; j < lowCutoff; j++) {
                        lowEnergy += spectrum[j];
                    }
                    for (let j = lowCutoff; j < spectrum.length; j++) {
                        highEnergy += spectrum[j];
                    }
                    
                    const tiltValue = lowEnergy / (highEnergy + 1e-10);
                    
                    tilt.push({
                        time: i / this.sampleRate,
                        tilt: tiltValue
                    });
                }
                
                return tilt;
            }
            
            // ===================================================================
            // OPTIMIZED MFCC EXTRACTION FOR SINGLE-WORD PRONUNCIATION
            // ===================================================================
            
            extractMFCCs(numCoeffs = 13, numFilters = 60) {
                // Optimized parameters for single-word pronunciation analysis
                const frameSize = 2048;      // ~46ms at 44.1kHz - excellent frequency resolution
                const hopSize = 128;         // ~2.9ms - fine temporal resolution for transitions
                const lowFreq = 100;         // Cut DC/rumble, focus on speech
                const highFreq = Math.min(8000, this.sampleRate / 2);  // Speech bandwidth
                const preEmphasis = 0.97;    // Boost high frequencies for consonants
                const lifterCoeff = 22;      // Cepstral liftering parameter
                
                debugLog.log(`Starting optimized MFCC extraction (frame=${frameSize}, hop=${hopSize}, filters=${numFilters})...`);
                
                // Pre-compute mel filterbank with frequency limits
                const melFilters = this.createMelFilterbank(frameSize, numFilters, lowFreq, highFreq);
                
                // Pre-compute Hamming window
                const hammingWindow = new Float64Array(frameSize);
                for (let i = 0; i < frameSize; i++) {
                    hammingWindow[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (frameSize - 1));
                }
                
                // Pre-compute liftering coefficients
                const lifter = new Float64Array(numCoeffs);
                for (let n = 0; n < numCoeffs; n++) {
                    lifter[n] = 1 + (lifterCoeff / 2) * Math.sin(Math.PI * n / lifterCoeff);
                }
                
                const mfccs = [];
                
                for (let i = 0; i < this.data.length - frameSize; i += hopSize) {
                    // Extract frame
                    const frame = new Float64Array(frameSize);
                    
                    // Apply pre-emphasis filter (boost high frequencies)
                    for (let j = 0; j < frameSize; j++) {
                        const currentSample = this.data[i + j];
                        if (j === 0 && i > 0) {
                            frame[j] = currentSample - preEmphasis * this.data[i - 1];
                        } else if (j === 0) {
                            frame[j] = currentSample;
                        } else {
                            frame[j] = currentSample - preEmphasis * this.data[i + j - 1];
                        }
                    }
                    
                    // Apply Hamming window
                    for (let j = 0; j < frameSize; j++) {
                        frame[j] *= hammingWindow[j];
                    }
                    
                    // Compute power spectrum
                    const spectrum = this.computeFFT(Array.from(frame));
                    const powerSpectrum = spectrum.map(x => x * x);
                    
                    // Apply mel filterbank
                    const melEnergies = new Float64Array(numFilters);
                    for (let f = 0; f < numFilters; f++) {
                        let energy = 0;
                        for (let k = 0; k < melFilters[f].length; k++) {
                            const bin = melFilters[f][k].bin;
                            if (bin < powerSpectrum.length) {
                                energy += powerSpectrum[bin] * melFilters[f][k].weight;
                            }
                        }
                        // Take log (add small value to avoid log(0))
                        melEnergies[f] = Math.log(energy + 1e-10);
                    }
                    
                    // Apply DCT-II to get MFCCs
                    const coeffs = new Float64Array(numCoeffs);
                    const scale = Math.sqrt(2 / numFilters);
                    for (let n = 0; n < numCoeffs; n++) {
                        let sum = 0;
                        for (let m = 0; m < numFilters; m++) {
                            sum += melEnergies[m] * Math.cos(Math.PI * n * (m + 0.5) / numFilters);
                        }
                        // Apply liftering to reduce dominance of higher coefficients
                        coeffs[n] = sum * scale * lifter[n];
                    }
                    
                    mfccs.push({
                        time: i / this.sampleRate,
                        coeffs: Array.from(coeffs)
                    });
                }
                
                // Apply Cepstral Mean Normalization (CMN) - removes channel/speaker bias
                // But store original means for AI analysis
                let originalMeans = null;
                if (mfccs.length > 0) {
                    const means = new Float64Array(numCoeffs);
                    for (const frame of mfccs) {
                        for (let c = 0; c < numCoeffs; c++) {
                            means[c] += frame.coeffs[c];
                        }
                    }
                    for (let c = 0; c < numCoeffs; c++) {
                        means[c] /= mfccs.length;
                    }
                    // Store original means before normalization
                    originalMeans = Array.from(means);
                    
                    // Subtract mean (skip c0 which is energy - keep it unnormalized)
                    for (const frame of mfccs) {
                        for (let c = 1; c < numCoeffs; c++) {
                            frame.coeffs[c] -= means[c];
                        }
                    }
                    debugLog.log(`Applied CMN normalization`, 'info');
                }
                
                // Attach original means to the result for AI analysis
                mfccs.originalMeans = originalMeans;
                
                debugLog.log(`Extracted ${mfccs.length} MFCC frames`, 'success');
                return mfccs;
            }
            
            // Extract delta (velocity) coefficients - captures temporal dynamics
            extractDeltaMFCCs(mfccs, windowSize = 2) {
                if (mfccs.length < 2 * windowSize + 1) {
                    debugLog.log('Not enough frames for delta extraction', 'warn');
                    return mfccs.map(f => ({ time: f.time, coeffs: new Array(f.coeffs.length).fill(0) }));
                }
                
                const deltas = [];
                const numCoeffs = mfccs[0].coeffs.length;
                
                for (let i = 0; i < mfccs.length; i++) {
                    const delta = new Float64Array(numCoeffs);
                    let norm = 0;
                    
                    for (let j = 1; j <= windowSize; j++) {
                        const prevIdx = Math.max(0, i - j);
                        const nextIdx = Math.min(mfccs.length - 1, i + j);
                        
                        for (let c = 0; c < numCoeffs; c++) {
                            delta[c] += j * (mfccs[nextIdx].coeffs[c] - mfccs[prevIdx].coeffs[c]);
                        }
                        norm += 2 * j * j;
                    }
                    
                    deltas.push({
                        time: mfccs[i].time,
                        coeffs: Array.from(delta).map(d => d / norm)
                    });
                }
                
                debugLog.log(`Extracted ${deltas.length} delta-MFCC frames`, 'success');
                return deltas;
            }
            
            // Extract delta-delta (acceleration) coefficients - captures rate of change
            extractDeltaDeltaMFCCs(mfccs, windowSize = 2) {
                const deltas = this.extractDeltaMFCCs(mfccs, windowSize);
                const deltaDeltas = this.extractDeltaMFCCs(deltas, windowSize);
                debugLog.log(`Extracted ${deltaDeltas.length} delta-delta-MFCC frames`, 'success');
                return deltaDeltas;
            }
            
            // Get full MFCC feature set (static + delta + delta-delta = 39 features)
            extractFullMFCCFeatures(numCoeffs = 13, numFilters = 60) {
                const staticMfccs = this.extractMFCCs(numCoeffs, numFilters);
                const deltaMfccs = this.extractDeltaMFCCs(staticMfccs);
                const deltaDeltaMfccs = this.extractDeltaDeltaMFCCs(staticMfccs);
                
                // Combine into full feature vectors
                const fullFeatures = staticMfccs.map((frame, i) => ({
                    time: frame.time,
                    static: frame.coeffs,
                    delta: deltaMfccs[i].coeffs,
                    deltaDelta: deltaDeltaMfccs[i].coeffs,
                    // Combined 39-dimensional feature vector
                    coeffs: [...frame.coeffs, ...deltaMfccs[i].coeffs, ...deltaDeltaMfccs[i].coeffs]
                }));
                
                debugLog.log(`Full MFCC features: ${fullFeatures.length} frames √ó ${fullFeatures[0]?.coeffs.length || 0} dimensions`, 'success');
                return fullFeatures;
            }
            
            createMelFilterbank(frameSize, numFilters, lowFreq = 100, highFreq = 8000) {
                const fftSize = frameSize;
                highFreq = Math.min(highFreq, this.sampleRate / 2);
                
                // Convert Hz to Mel (O'Shaughnessy formula)
                const hzToMel = (hz) => 2595 * Math.log10(1 + hz / 700);
                const melToHz = (mel) => 700 * (Math.pow(10, mel / 2595) - 1);
                
                const lowMel = hzToMel(lowFreq);
                const highMel = hzToMel(highFreq);
                
                // Create equally spaced points in mel scale
                const melPoints = [];
                for (let i = 0; i <= numFilters + 1; i++) {
                    melPoints.push(lowMel + (highMel - lowMel) * i / (numFilters + 1));
                }
                
                // Convert back to Hz and then to FFT bin
                const binPoints = melPoints.map(mel => {
                    const hz = melToHz(mel);
                    return Math.floor((fftSize + 1) * hz / this.sampleRate);
                });
                
                // Create triangular filters with area normalization
                const filters = [];
                for (let f = 0; f < numFilters; f++) {
                    const filter = [];
                    const start = binPoints[f];
                    const center = binPoints[f + 1];
                    const end = binPoints[f + 2];
                    
                    // Skip degenerate filters
                    if (center <= start || end <= center) continue;
                    
                    // Compute filter area for normalization
                    const area = (end - start) / 2;
                    const norm = area > 0 ? 1 / area : 1;
                    
                    // Rising edge
                    for (let k = start; k < center; k++) {
                        const weight = ((k - start) / (center - start)) * norm;
                        filter.push({ bin: k, weight: weight });
                    }
                    
                    // Falling edge
                    for (let k = center; k <= end; k++) {
                        const weight = ((end - k) / (end - center)) * norm;
                        if (weight > 0) {
                            filter.push({ bin: k, weight: weight });
                        }
                    }
                    
                    filters.push(filter);
                }
                
                // Pad with empty filters if some were degenerate
                while (filters.length < numFilters) {
                    filters.push([]);
                }
                
                return filters;
            }
            
            computeFFT(signal) {
                const n = signal.length;
                
                // Pad to next power of 2 if needed
                let paddedLength = 1;
                while (paddedLength < n) paddedLength <<= 1;
                
                // Create complex arrays (real and imaginary parts)
                const real = new Float64Array(paddedLength);
                const imag = new Float64Array(paddedLength);
                
                // Copy signal to real part, pad with zeros
                for (let i = 0; i < n; i++) {
                    real[i] = signal[i];
                }
                
                // Bit-reversal permutation
                const bits = Math.log2(paddedLength);
                for (let i = 0; i < paddedLength; i++) {
                    const j = this.reverseBits(i, bits);
                    if (j > i) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                }
                
                // Cooley-Tukey iterative FFT
                for (let size = 2; size <= paddedLength; size *= 2) {
                    const halfSize = size / 2;
                    const angleStep = -2 * Math.PI / size;
                    
                    for (let i = 0; i < paddedLength; i += size) {
                        for (let j = 0; j < halfSize; j++) {
                            const angle = angleStep * j;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            
                            const idx1 = i + j;
                            const idx2 = i + j + halfSize;
                            
                            const tReal = real[idx2] * cos - imag[idx2] * sin;
                            const tImag = real[idx2] * sin + imag[idx2] * cos;
                            
                            real[idx2] = real[idx1] - tReal;
                            imag[idx2] = imag[idx1] - tImag;
                            real[idx1] = real[idx1] + tReal;
                            imag[idx1] = imag[idx1] + tImag;
                        }
                    }
                }
                
                // Compute magnitudes (only need first half due to symmetry)
                const magnitude = new Array(n / 2);
                for (let k = 0; k < n / 2; k++) {
                    magnitude[k] = Math.sqrt(real[k] * real[k] + imag[k] * imag[k]);
                }
                
                return magnitude;
            }
            
            reverseBits(x, bits) {
                let result = 0;
                for (let i = 0; i < bits; i++) {
                    result = (result << 1) | (x & 1);
                    x >>= 1;
                }
                return result;
            }
        }

        // ===================================================================
        // DTW
        // ===================================================================
        class DTW {
            static compute1D(seq1, seq2, window = 20) {
                const n = seq1.length;
                const m = seq2.length;
                
                const cost = Array(n + 1).fill(0).map(() => Array(m + 1).fill(Infinity));
                cost[0][0] = 0;
                
                const effectiveWindow = window > 0 ? window : Math.max(n, m);
                
                for (let i = 1; i <= n; i++) {
                    const jStart = Math.max(1, Math.floor(i * m / n) - effectiveWindow);
                    const jEnd = Math.min(m, Math.floor(i * m / n) + effectiveWindow);
                    
                    for (let j = jStart; j <= jEnd; j++) {
                        const distance = Math.abs(seq1[i-1] - seq2[j-1]);
                        
                        const cost1 = cost[i-1][j];
                        const cost2 = cost[i][j-1];
                        const cost3 = cost[i-1][j-1];
                        
                        cost[i][j] = distance + Math.min(cost1, cost2, cost3);
                    }
                }
                
                const totalDistance = cost[n][m];
                const pathLength = n + m;
                const normalizedDistance = totalDistance / pathLength;
                
                return {
                    distance: totalDistance,
                    normalizedDistance: normalizedDistance,
                    cost: cost
                };
            }
            
            static computeMultiDim(seq1, seq2, weights = {f1: 1.0, f2: 0.8, f3: 0.6}, window = 20) {
                const n = seq1.length;
                const m = seq2.length;
                
                debugLog.log(`DTW.computeMultiDim: n=${n}, m=${m}`);
                
                // CRITICAL: Validate that all elements exist and have required properties
                for (let i = 0; i < n; i++) {
                    if (!seq1[i]) {
                        debugLog.log(`ERROR: seq1[${i}] is ${seq1[i]}`, 'error');
                        throw new Error(`seq1[${i}] is undefined or null`);
                    }
                    if (typeof seq1[i].f1 !== 'number' || typeof seq1[i].f2 !== 'number' || typeof seq1[i].f3 !== 'number') {
                        debugLog.log(`ERROR: seq1[${i}] missing formants: f1=${seq1[i].f1}, f2=${seq1[i].f2}, f3=${seq1[i].f3}`, 'error');
                        throw new Error(`seq1[${i}] has invalid formant data`);
                    }
                }
                
                for (let i = 0; i < m; i++) {
                    if (!seq2[i]) {
                        debugLog.log(`ERROR: seq2[${i}] is ${seq2[i]}`, 'error');
                        throw new Error(`seq2[${i}] is undefined or null`);
                    }
                    if (typeof seq2[i].f1 !== 'number' || typeof seq2[i].f2 !== 'number' || typeof seq2[i].f3 !== 'number') {
                        debugLog.log(`ERROR: seq2[${i}] missing formants: f1=${seq2[i].f1}, f2=${seq2[i].f2}, f3=${seq2[i].f3}`, 'error');
                        throw new Error(`seq2[${i}] has invalid formant data`);
                    }
                }
                
                const cost = Array(n + 1).fill(0).map(() => Array(m + 1).fill(Infinity));
                cost[0][0] = 0;
                
                const effectiveWindow = window > 0 ? window : Math.max(n, m);
                
                const weightedDistance = (p1, p2) => {
                    const d1 = weights.f1 * (p1.f1 - p2.f1);
                    const d2 = weights.f2 * (p1.f2 - p2.f2);
                    const d3 = weights.f3 * (p1.f3 - p2.f3);
                    return Math.sqrt(d1*d1 + d2*d2 + d3*d3);
                };
                
                for (let i = 1; i <= n; i++) {
                    const jStart = Math.max(1, Math.floor(i * m / n) - effectiveWindow);
                    const jEnd = Math.min(m, Math.floor(i * m / n) + effectiveWindow);
                    
                    for (let j = jStart; j <= jEnd; j++) {
                        const distance = weightedDistance(seq1[i-1], seq2[j-1]);
                        
                        cost[i][j] = distance + Math.min(
                            cost[i-1][j],
                            cost[i][j-1],
                            cost[i-1][j-1]
                        );
                    }
                }
                
                const totalDistance = cost[n][m];
                const pathLength = n + m;
                const normalizedDistance = totalDistance / pathLength;
                
                return {
                    distance: totalDistance,
                    normalizedDistance: normalizedDistance
                };
            }
        }

        // ===================================================================
        // PRONUNCIATION COMPARATOR
        // ===================================================================
        class PronunciationComparator {
            compare(nativeBuffer, userBuffer) {
                debugLog.log('Starting comparison analysis...');
                
                const nativeAnalyzer = new AcousticAnalyzer(nativeBuffer);
                const userAnalyzer = new AcousticAnalyzer(userBuffer);
                
                const nativePitch = nativeAnalyzer.extractPitch();
                const userPitch = userAnalyzer.extractPitch();
                
                const nativeIntensity = nativeAnalyzer.extractIntensity();
                const userIntensity = userAnalyzer.extractIntensity();
                
                const nativeZCR = nativeAnalyzer.extractZCR();
                const userZCR = userAnalyzer.extractZCR();
                
                const nativeTilt = nativeAnalyzer.extractSpectralTilt();
                const userTilt = userAnalyzer.extractSpectralTilt();
                
                const numMelFilters = scalePreferences.mfccNumFilters;
                const nativeMFCCs = nativeAnalyzer.extractMFCCs(13, numMelFilters);
                const userMFCCs = userAnalyzer.extractMFCCs(13, numMelFilters);
                
                // Extract delta MFCCs for temporal dynamics analysis
                const nativeDeltaMFCCs = nativeAnalyzer.extractDeltaMFCCs(nativeMFCCs);
                const userDeltaMFCCs = userAnalyzer.extractDeltaMFCCs(userMFCCs);
                
                // Extract envelope correlation
                const nativeData = nativeBuffer.getChannelData(0);
                const userData = userBuffer.getChannelData(0);
                const nativeEnvelope = extractEnvelope(nativeData);
                const userEnvelope = extractEnvelope(userData);
                const envelopeResult = this.compareEnvelope(nativeEnvelope, userEnvelope);
                
                const pitchResult = this.comparePitchDetailed(nativePitch, userPitch);
                const durationResult = this.compareDurationDetailed(nativeBuffer, userBuffer);
                const spectralResult = this.compareSpectralDetailed(nativeBuffer, userBuffer);
                const qualityResult = this.compareQualityDetailed(nativeZCR, userZCR, nativeTilt, userTilt);
                const stressResult = this.compareStressPattern(nativeIntensity, userIntensity);
                const mfccResult = this.compareMFCCs(nativeMFCCs, userMFCCs);
                const deltaMfccResult = this.compareMFCCs(nativeDeltaMFCCs, userDeltaMFCCs);
                
                const pitchScore = pitchResult.score;
                const durationScore = durationResult.score;
                const spectralScore = spectralResult.score;
                const qualityScore = qualityResult.score;
                const stressScore = stressResult.score;
                const stressPositionScore = stressResult.positionScore || stressScore;
                // Combine static MFCC (70%) and delta MFCC (30%) for comprehensive phonetic scoring
                const mfccScore = mfccResult.score * 0.7 + deltaMfccResult.score * 0.3;
                const envelopeScore = envelopeResult.score;
                
                debugLog.log(`Scores - P:${pitchScore.toFixed(0)} M:${mfccScore.toFixed(0)} (static:${mfccResult.score.toFixed(0)} delta:${deltaMfccResult.score.toFixed(0)}) E:${envelopeScore.toFixed(0)} D:${durationScore.toFixed(0)} StPos:${stressPositionScore.toFixed(0)} StPat:${stressScore.toFixed(0)} Q:${qualityScore.toFixed(0)}`, 'success');
                
                // Recalibrated weights with envelope and stress position
                const weights = {
                    pitch: 0.20,
                    mfcc: 0.25,
                    envelope: 0.15,
                    duration: 0.10,
                    stressPosition: 0.10,
                    stress: 0.10,
                    quality: 0.10
                };
                
                const overallScore = Math.round(
                    pitchScore * weights.pitch +
                    mfccScore * weights.mfcc +
                    envelopeScore * weights.envelope +
                    durationScore * weights.duration +
                    stressPositionScore * weights.stressPosition +
                    stressScore * weights.stress +
                    qualityScore * weights.quality
                );
                
                const detailedReport = {
                    metadata: {
                        timestamp: new Date().toISOString(),
                        nativeDuration: nativeBuffer.duration,
                        userDuration: userBuffer.duration,
                        nativeSampleRate: nativeBuffer.sampleRate,
                        userSampleRate: userBuffer.sampleRate
                    },
                    mfcc: {
                        numMelFilters: numMelFilters,
                        staticComparison: mfccResult.details,
                        deltaComparison: deltaMfccResult.details,
                        staticScore: mfccResult.score,
                        deltaScore: deltaMfccResult.score,
                        combinedScore: mfccScore,
                        interpretation: {
                            staticMeaning: 'Captures vowel/consonant quality (what sounds are produced)',
                            deltaMeaning: 'Captures transitions between sounds (how smoothly sounds change)',
                            lowDeltaScore: deltaMfccResult.score < 60 ? 
                                'User transitions between sounds are abrupt or unclear' : null
                        }
                    },
                    pitch: {
                        native: {
                            summary: nativePitch.summary,
                            sampleFrames: nativePitch.detailedFrames ? nativePitch.detailedFrames.slice(0, 10) : []
                        },
                        user: {
                            summary: userPitch.summary,
                            sampleFrames: userPitch.detailedFrames ? userPitch.detailedFrames.slice(0, 10) : []
                        },
                        comparison: pitchResult.details
                    },
                    duration: durationResult.details,
                    envelope: envelopeResult.details,
                    quality: qualityResult.details,
                    scoring: {
                        weights: weights,
                        rawScores: {
                            pitch: pitchScore,
                            mfcc: mfccScore,
                            envelope: envelopeScore,
                            duration: durationScore,
                            stressPosition: stressPositionScore,
                            stress: stressScore,
                            quality: qualityScore
                        },
                        weightedScores: {
                            pitch: pitchScore * weights.pitch,
                            mfcc: mfccScore * weights.mfcc,
                            envelope: envelopeScore * weights.envelope,
                            duration: durationScore * weights.duration,
                            stressPosition: stressPositionScore * weights.stressPosition,
                            stress: stressScore * weights.stress,
                            quality: qualityScore * weights.quality
                        },
                        overallScore: overallScore
                    }
                };
                
                const result = {
                    score: overallScore,
                    breakdown: {
                        pitch: Math.round(pitchScore),
                        mfcc: Math.round(mfccScore),
                        envelope: Math.round(envelopeScore),
                        duration: Math.round(durationScore),
                        stressPosition: Math.round(stressPositionScore),
                        stress: Math.round(stressScore),
                        quality: Math.round(qualityScore)
                    },
                    features: {
                        nativeMFCCs,
                        userMFCCs,
                        nativeDeltaMFCCs,
                        userDeltaMFCCs,
                        nativePitch,
                        userPitch,
                        nativeIntensity,
                        userIntensity,
                        nativeEnvelope,
                        userEnvelope
                    },
                    feedback: this.generateFeedback(overallScore, {
                        pitch: pitchScore,
                        mfcc: mfccScore,
                        envelope: envelopeScore,
                        duration: durationScore,
                        stressPosition: stressPositionScore
                    }),
                    detailedReport: detailedReport
                };
                
                return result;
            }
            
            compareMFCCs(native, user) {
                if (!native || !user || native.length === 0 || user.length === 0) {
                    return {
                        score: 50,
                        details: { reason: 'Insufficient MFCC data' }
                    };
                }
                
                let score, method;
                const numCoeffs = native[0].coeffs.length;
                
                // Compute coefficient-wise statistics for detailed analysis
                const coeffStats = [];
                for (let c = 1; c < numCoeffs; c++) {
                    const nativeVals = native.map(f => f.coeffs[c]);
                    const userVals = user.map(f => f.coeffs[c]);
                    
                    const nativeMean = nativeVals.reduce((a, b) => a + b, 0) / nativeVals.length;
                    const userMean = userVals.reduce((a, b) => a + b, 0) / userVals.length;
                    
                    const nativeStd = Math.sqrt(nativeVals.reduce((a, b) => a + (b - nativeMean) ** 2, 0) / nativeVals.length);
                    const userStd = Math.sqrt(userVals.reduce((a, b) => a + (b - userMean) ** 2, 0) / userVals.length);
                    
                    coeffStats.push({
                        coeff: c,
                        nativeMean: nativeMean,
                        userMean: userMean,
                        meanDiff: Math.abs(nativeMean - userMean),
                        nativeStd: nativeStd,
                        userStd: userStd
                    });
                }
                
                if (useDTW) {
                    // Use DTW on MFCC sequences
                    const n = native.length;
                    const m = user.length;
                    
                    // Create cost matrix
                    const cost = Array(n + 1).fill(0).map(() => Array(m + 1).fill(Infinity));
                    cost[0][0] = 0;
                    
                    // Adaptive window based on length ratio
                    const window = Math.max(20, Math.floor(Math.max(n, m) * 0.2));
                    
                    for (let i = 1; i <= n; i++) {
                        const jStart = Math.max(1, Math.floor(i * m / n) - window);
                        const jEnd = Math.min(m, Math.floor(i * m / n) + window);
                        
                        for (let j = jStart; j <= jEnd; j++) {
                            // Weighted Euclidean distance between MFCC vectors (skip c0 which is energy)
                            // Weight lower coefficients (which capture more perceptual info) more heavily
                            let dist = 0;
                            for (let c = 1; c < numCoeffs; c++) {
                                const weight = 1 / Math.sqrt(c); // Lower coeffs weighted more
                                const diff = native[i-1].coeffs[c] - user[j-1].coeffs[c];
                                dist += weight * diff * diff;
                            }
                            dist = Math.sqrt(dist);
                            
                            cost[i][j] = dist + Math.min(
                                cost[i-1][j],
                                cost[i][j-1],
                                cost[i-1][j-1]
                            );
                        }
                    }
                    
                    const totalDist = cost[n][m];
                    const pathLength = n + m;
                    const normalizedDist = totalDist / pathLength;
                    
                    // Convert to score (adjusted for weighted distances)
                    score = Math.max(0, 100 * (1 - normalizedDist / 8));
                    method = 'DTW-Weighted';
                    
                } else {
                    // Point-by-point comparison with interpolation
                    const targetLen = Math.max(native.length, user.length);
                    let totalDist = 0;
                    
                    for (let i = 0; i < targetLen; i++) {
                        const nIdx = Math.min(native.length - 1, Math.floor(i * native.length / targetLen));
                        const uIdx = Math.min(user.length - 1, Math.floor(i * user.length / targetLen));
                        
                        let frameDist = 0;
                        for (let c = 1; c < numCoeffs; c++) {
                            const weight = 1 / Math.sqrt(c);
                            const diff = native[nIdx].coeffs[c] - user[uIdx].coeffs[c];
                            frameDist += weight * diff * diff;
                        }
                        totalDist += Math.sqrt(frameDist);
                    }
                    
                    const avgDist = totalDist / targetLen;
                    score = Math.max(0, 100 * (1 - avgDist / 8));
                    method = 'Interpolated-Weighted';
                }
                
                // Identify problematic coefficients (for AI feedback)
                const problematicCoeffs = coeffStats
                    .filter(s => s.meanDiff > 5) // Threshold for significant difference
                    .sort((a, b) => b.meanDiff - a.meanDiff)
                    .slice(0, 3);
                
                return {
                    score: Math.min(100, Math.max(0, score)),
                    details: {
                        nativeFrames: native.length,
                        userFrames: user.length,
                        method: method,
                        coefficientStats: coeffStats,
                        problematicCoeffs: problematicCoeffs,
                        frameTimeResolution: native.length > 1 ? 
                            ((native[native.length-1].time - native[0].time) / (native.length - 1) * 1000).toFixed(1) + 'ms' : 
                            'N/A'
                    }
                };
            }
            
            compareFormantsDetailed(native, user) {
                // CRITICAL: Add extensive validation
                debugLog.log(`compareFormantsDetailed: native.length=${native.length}, user.length=${user.length}`);
                
                if (!Array.isArray(native) || !Array.isArray(user)) {
                    debugLog.log('ERROR: native or user is not an array', 'error');
                    return {
                        score: 50,
                        details: {
                            reason: 'Invalid formant data (not arrays)',
                            method: useDTW ? 'DTW (error)' : 'Point-by-point (error)'
                        }
                    };
                }
                
                // Filter to voiced frames with valid f1, f2, f3
                // CRITICAL: Check that properties exist AND are numbers
                const nativeVoiced = native.filter(f => 
                    f && 
                    f.voiced === true && 
                    typeof f.f1 === 'number' && !isNaN(f.f1) &&
                    typeof f.f2 === 'number' && !isNaN(f.f2) &&
                    typeof f.f3 === 'number' && !isNaN(f.f3)
                );
                
                const userVoiced = user.filter(f => 
                    f && 
                    f.voiced === true && 
                    typeof f.f1 === 'number' && !isNaN(f.f1) &&
                    typeof f.f2 === 'number' && !isNaN(f.f2) &&
                    typeof f.f3 === 'number' && !isNaN(f.f3)
                );
                
                debugLog.log(`Filtered: nativeVoiced=${nativeVoiced.length}, userVoiced=${userVoiced.length}`);
                
                if (nativeVoiced.length === 0 || userVoiced.length === 0) {
                    debugLog.log(`No valid voiced frames`, 'error');
                    return {
                        score: 50,
                        details: {
                            validFrames: 0,
                            totalFrames: Math.min(native.length, user.length),
                            avgError: 'N/A',
                            reason: 'No voiced frames with valid formants',
                            sampleErrors: [],
                            method: useDTW ? 'DTW (no data)' : 'Point-by-point (no data)'
                        }
                    };
                }
                
                // Log first few frames for debugging
                debugLog.log(`First native voiced frame: f1=${nativeVoiced[0].f1}, f2=${nativeVoiced[0].f2}, f3=${nativeVoiced[0].f3}`);
                debugLog.log(`First user voiced frame: f1=${userVoiced[0].f1}, f2=${userVoiced[0].f2}, f3=${userVoiced[0].f3}`);
                
                let score, avgError, calculation, method;
                const frameErrors = [];
                
                if (useDTW) {
                    debugLog.log(`Using DTW for formant comparison`);
                    
                    try {
                        const dtwResult = DTW.computeMultiDim(
                            nativeVoiced,
                            userVoiced,
                            {f1: 1.0, f2: 0.8, f3: 0.6},
                            20
                        );
                        
                        const avgF1 = nativeVoiced.reduce((sum, f) => sum + f.f1, 0) / nativeVoiced.length;
                        const avgF2 = nativeVoiced.reduce((sum, f) => sum + f.f2, 0) / nativeVoiced.length;
                        const avgF3 = nativeVoiced.reduce((sum, f) => sum + f.f3, 0) / nativeVoiced.length;
                        const avgFormant = (avgF1 + avgF2 + avgF3) / 3;
                        
                        const relativeError = dtwResult.normalizedDistance / avgFormant;
                        score = Math.max(0, 100 * (1 - relativeError * 5));
                        avgError = relativeError;
                        calculation = `DTW distance: ${dtwResult.normalizedDistance.toFixed(2)}, relative error: ${relativeError.toFixed(4)}`;
                        method = 'DTW (tempo-invariant)';
                        
                        frameErrors.push({
                            note: 'DTW compares overall patterns',
                            native: {
                                avgF1: Math.round(avgF1),
                                avgF2: Math.round(avgF2),
                                avgF3: Math.round(avgF3)
                            },
                            user: {
                                avgF1: Math.round(userVoiced.reduce((sum, f) => sum + f.f1, 0) / userVoiced.length),
                                avgF2: Math.round(userVoiced.reduce((sum, f) => sum + f.f2, 0) / userVoiced.length),
                                avgF3: Math.round(userVoiced.reduce((sum, f) => sum + f.f3, 0) / userVoiced.length)
                            },
                            dtwDistance: dtwResult.normalizedDistance.toFixed(3)
                        });
                        
                    } catch (error) {
                        debugLog.log(`DTW failed: ${error.message}`, 'error');
                        
                        // Fallback to point-by-point
                        const minLen = Math.min(nativeVoiced.length, userVoiced.length);
                        let totalError = 0;
                        
                        for (let i = 0; i < minLen; i++) {
                            const f1Error = Math.abs(nativeVoiced[i].f1 - userVoiced[i].f1) / nativeVoiced[i].f1;
                            const f2Error = Math.abs(nativeVoiced[i].f2 - userVoiced[i].f2) / nativeVoiced[i].f2;
                            const f3Error = Math.abs(nativeVoiced[i].f3 - userVoiced[i].f3) / nativeVoiced[i].f3;
                            totalError += (f1Error + f2Error + f3Error) / 3;
                        }
                        
                        avgError = totalError / minLen;
                        score = Math.max(0, 100 * (1 - avgError));
                        calculation = `Fallback after DTW error`;
                        method = 'Point-by-point (DTW failed)';
                    }
                    
                } else {
                    const minLen = Math.min(nativeVoiced.length, userVoiced.length);
                    let totalError = 0;
                    let validFrames = 0;
                    
                    debugLog.log(`Using point-by-point for formant comparison (${minLen} frames)`);
                    
                    for (let i = 0; i < minLen; i++) {
                        // Already filtered, but double-check
                        if (!nativeVoiced[i] || !userVoiced[i]) {
                            debugLog.log(`Skipping frame ${i}: undefined`, 'error');
                            continue;
                        }
                        
                        const f1Error = Math.abs(nativeVoiced[i].f1 - userVoiced[i].f1) / nativeVoiced[i].f1;
                        const f2Error = Math.abs(nativeVoiced[i].f2 - userVoiced[i].f2) / nativeVoiced[i].f2;
                        const f3Error = Math.abs(nativeVoiced[i].f3 - userVoiced[i].f3) / nativeVoiced[i].f3;
                        
                        const frameAvgError = (f1Error + f2Error + f3Error) / 3;
                        totalError += frameAvgError;
                        validFrames++;
                        
                        if (frameErrors.length < 5) {
                            frameErrors.push({
                                frameIndex: i,
                                time: nativeVoiced[i].time.toFixed(3),
                                native: {
                                    f1: Math.round(nativeVoiced[i].f1),
                                    f2: Math.round(nativeVoiced[i].f2),
                                    f3: Math.round(nativeVoiced[i].f3)
                                },
                                user: {
                                    f1: Math.round(userVoiced[i].f1),
                                    f2: Math.round(userVoiced[i].f2),
                                    f3: Math.round(userVoiced[i].f3)
                                },
                                errors: {
                                    f1: (f1Error * 100).toFixed(1) + '%',
                                    f2: (f2Error * 100).toFixed(1) + '%',
                                    f3: (f3Error * 100).toFixed(1) + '%',
                                    avg: (frameAvgError * 100).toFixed(1) + '%'
                                }
                            });
                        }
                    }
                    
                    avgError = totalError / validFrames;
                    score = Math.max(0, 100 * (1 - avgError));
                    calculation = `Score = 100 √ó (1 - ${avgError.toFixed(4)}) = ${score.toFixed(1)}`;
                    method = 'Point-by-point';
                }
                
                debugLog.log(`Formant score (${method}): ${score.toFixed(1)}%`, 'success');
                
                return {
                    score: score,
                    details: {
                        validFrames: useDTW ? nativeVoiced.length : Math.min(nativeVoiced.length, userVoiced.length),
                        totalFrames: Math.min(native.length, user.length),
                        avgError: (avgError * 100).toFixed(2) + '%',
                        sampleErrors: frameErrors,
                        calculation: calculation,
                        method: method
                    }
                };
            }
            
            comparePitchDetailed(native, user) {
                const nativePitches = native.filter(p => p.pitch > 0).map(p => p.pitch);
                const userPitches = user.filter(p => p.pitch > 0).map(p => p.pitch);
                
                if (nativePitches.length === 0 || userPitches.length === 0) {
                    return {
                        score: 50,
                        details: {
                            reason: 'Insufficient voiced frames',
                            nativeVoiced: nativePitches.length,
                            userVoiced: userPitches.length,
                            method: useDTW ? 'DTW (no data)' : 'Point-by-point (no data)'
                        }
                    };
                }
                
                let score, calculation, method;
                
                if (useDTW) {
                    const nativeMean = nativePitches.reduce((a, b) => a + b, 0) / nativePitches.length;
                    const userMean = userPitches.reduce((a, b) => a + b, 0) / userPitches.length;
                    
                    const nativeNorm = nativePitches.map(p => p / nativeMean);
                    const userNorm = userPitches.map(p => p / userMean);
                    
                    const dtwResult = DTW.compute1D(nativeNorm, userNorm, 20);
                    
                    // More lenient scoring: use factor of 2 instead of 3
                    // This gives 0% only when distance >= 0.5 instead of >= 0.33
                    score = Math.max(0, 100 * (1 - dtwResult.normalizedDistance * 2));
                    calculation = `DTW distance: ${dtwResult.normalizedDistance.toFixed(4)}`;
                    method = 'DTW (tempo-invariant)';
                    
                } else {
                    const nativeMean = nativePitches.reduce((a, b) => a + b, 0) / nativePitches.length;
                    const userMean = userPitches.reduce((a, b) => a + b, 0) / userPitches.length;
                    
                    const nativeNorm = native.map(p => p.pitch > 0 ? p.pitch / nativeMean : 0);
                    const userNorm = user.map(p => p.pitch > 0 ? p.pitch / userMean : 0);
                    
                    const minLen = Math.min(nativeNorm.length, userNorm.length);
                    let correlation = 0;
                    
                    for (let i = 0; i < minLen; i++) {
                        if (nativeNorm[i] > 0 && userNorm[i] > 0) {
                            const diff = Math.abs(nativeNorm[i] - userNorm[i]) / nativeNorm[i];
                            correlation += 1 - Math.min(diff, 1);
                        }
                    }
                    
                    score = Math.max(0, 100 * correlation / minLen);
                    calculation = `Correlation = ${score.toFixed(1)}%`;
                    method = 'Point-by-point';
                }
                
                const nativeMean = nativePitches.reduce((a, b) => a + b, 0) / nativePitches.length;
                const userMean = userPitches.reduce((a, b) => a + b, 0) / userPitches.length;
                
                return {
                    score: score,
                    details: {
                        nativeMean: nativeMean.toFixed(1) + ' Hz',
                        userMean: userMean.toFixed(1) + ' Hz',
                        pitchDifference: ((userMean - nativeMean) / nativeMean * 100).toFixed(1) + '%',
                        validPoints: nativePitches.length,
                        totalPoints: Math.max(native.length, user.length),
                        calculation: calculation,
                        method: method
                    }
                };
            }
            
            compareDurationDetailed(native, user) {
                // Use deviation-based scoring - penalizes proportionally to deviation from 1.0
                const ratio = user.duration / native.duration;
                const deviation = Math.abs(1 - ratio);
                const score = Math.max(0, 100 - deviation * 100);
                
                return {
                    score: score,
                    details: {
                        nativeDuration: native.duration.toFixed(3) + 's',
                        userDuration: user.duration.toFixed(3) + 's',
                        difference: Math.abs(native.duration - user.duration).toFixed(3) + 's',
                        ratio: ratio.toFixed(3),
                        deviation: (deviation * 100).toFixed(1) + '%',
                        calculation: `Score = 100 - |1 - ${ratio.toFixed(3)}| √ó 100 = ${score.toFixed(1)}%`
                    }
                };
            }
            
            // Compare envelope (loudness contour) correlation
            compareEnvelope(nativeEnvelope, userEnvelope) {
                if (!nativeEnvelope || !userEnvelope || nativeEnvelope.length < 5 || userEnvelope.length < 5) {
                    return {
                        score: 50,
                        details: { reason: 'Insufficient envelope data' }
                    };
                }
                
                // Resample to common length and normalize
                const targetLen = 50;
                const nativeResampled = resampleArray(nativeEnvelope, targetLen);
                const userResampled = resampleArray(userEnvelope, targetLen);
                
                // Normalize to 0-1 range
                const nativeMax = Math.max(...nativeResampled) || 1;
                const userMax = Math.max(...userResampled) || 1;
                const nativeNorm = nativeResampled.map(v => v / nativeMax);
                const userNorm = userResampled.map(v => v / userMax);
                
                // Use Pearson correlation
                const correlation = pearsonCorrelation(nativeNorm, userNorm);
                const score = Math.max(0, correlation * 100);
                
                return {
                    score: score,
                    details: {
                        correlation: correlation.toFixed(4),
                        nativeLength: nativeEnvelope.length,
                        userLength: userEnvelope.length,
                        calculation: `Score = Pearson correlation √ó 100 = ${score.toFixed(1)}%`
                    }
                };
            }
            
            compareSpectralDetailed(native, user) {
                const nativeData = native.getChannelData(0);
                const userData = user.getChannelData(0);
                
                const minLen = Math.min(nativeData.length, userData.length);
                const nativeResampled = this.resample(nativeData, minLen);
                const userResampled = this.resample(userData, minLen);
                
                let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;
                
                for (let i = 0; i < minLen; i++) {
                    sumXY += nativeResampled[i] * userResampled[i];
                    sumX += nativeResampled[i];
                    sumY += userResampled[i];
                    sumX2 += nativeResampled[i] ** 2;
                    sumY2 += userResampled[i] ** 2;
                }
                
                const num = sumXY - (sumX * sumY / minLen);
                const den = Math.sqrt((sumX2 - sumX ** 2 / minLen) * (sumY2 - sumY ** 2 / minLen));
                
                if (den === 0) {
                    return {
                        score: 0,
                        details: { reason: 'Division by zero' }
                    };
                }
                
                const corr = num / den;
                const score = Math.max(0, (corr + 1) * 50);
                
                return {
                    score: score,
                    details: {
                        samplePoints: minLen,
                        pearsonCorrelation: corr.toFixed(4),
                        calculation: `Score = (r + 1) √ó 50 = ${score.toFixed(1)}%`
                    }
                };
            }
            
            compareQualityDetailed(nativeZCR, userZCR, nativeTilt, userTilt) {
                let zcrScore, tiltScore, method;
                
                if (useDTW) {
                    const nativeZCRVals = nativeZCR.map(z => z.zcr);
                    const userZCRVals = userZCR.map(z => z.zcr);
                    const nativeTiltVals = nativeTilt.map(t => t.tilt);
                    const userTiltVals = userTilt.map(t => t.tilt);
                    
                    const zcrDTW = DTW.compute1D(nativeZCRVals, userZCRVals, 20);
                    zcrScore = Math.max(0, 100 * (1 - zcrDTW.normalizedDistance * 20));
                    
                    const tiltDTW = DTW.compute1D(nativeTiltVals, userTiltVals, 20);
                    tiltScore = Math.max(0, 100 * (1 - tiltDTW.normalizedDistance * 10));
                    
                    method = 'DTW (tempo-invariant)';
                } else {
                    zcrScore = this.compareTrack(
                        nativeZCR.map(z => z.zcr),
                        userZCR.map(z => z.zcr)
                    );
                    
                    tiltScore = this.compareTrack(
                        nativeTilt.map(t => t.tilt),
                        userTilt.map(t => t.tilt)
                    );
                    
                    method = 'Point-by-point';
                }
                
                const score = (zcrScore + tiltScore) / 2;
                
                return {
                    score: score,
                    details: {
                        zcrScore: zcrScore.toFixed(1) + '%',
                        tiltScore: tiltScore.toFixed(1) + '%',
                        avgNativeZCR: (nativeZCR.reduce((a,b) => a + b.zcr, 0) / nativeZCR.length).toFixed(4),
                        avgUserZCR: (userZCR.reduce((a,b) => a + b.zcr, 0) / userZCR.length).toFixed(4),
                        calculation: `Average = ${score.toFixed(1)}%`,
                        method: method
                    }
                };
            }
            
            // NEW: Stress pattern scoring for syllable rhythm
            compareStressPattern(nativeIntensity, userIntensity) {
                // Find intensity peaks (syllable stress)
                const findPeaks = (track, minHeight = 0.3) => {
                    const peaks = [];
                    const values = track.map(p => p.intensity);
                    if (values.length < 10) return peaks;
                    
                    const maxVal = Math.max(...values);
                    if (maxVal === 0) return peaks;

                    for (let i = 5; i < values.length - 5; i++) {
                        if (values[i] > maxVal * minHeight &&
                            values[i] > values[i-1] && values[i] > values[i+1] &&
                            values[i] > values[i-2] && values[i] > values[i+2] &&
                            values[i] > values[i-3] && values[i] > values[i+3]) {
                            peaks.push({
                                time: track[i].time,
                                height: values[i] / maxVal,
                                index: i
                            });
                        }
                    }
                    return peaks;
                };

                const nativePeaks = findPeaks(nativeIntensity, 0.35);
                const userPeaks = findPeaks(userIntensity, 0.35);

                if (nativePeaks.length === 0 || userPeaks.length === 0) {
                    return { 
                        score: 50, 
                        positionScore: 50,
                        details: { reason: 'Insufficient stress peaks' } 
                    };
                }

                // Calculate stress POSITION score - where is the strongest stress?
                const nativeValues = nativeIntensity.map(p => p.intensity);
                const userValues = userIntensity.map(p => p.intensity);
                
                const nativeStrongest = nativePeaks.reduce((a, b) => a.height > b.height ? a : b);
                const userStrongest = userPeaks.reduce((a, b) => a.height > b.height ? a : b);
                
                const nativePos = nativeStrongest.index / nativeValues.length;
                const userPos = userStrongest.index / userValues.length;
                const posDiff = Math.abs(nativePos - userPos);
                
                // Score: 100 if same position, loses 20 points per 10% position difference
                const positionScore = Math.max(0, 100 - posDiff * 200);

                // Match peaks by time (with tolerance)
                let matched = 0;
                const nativeDuration = nativeIntensity.length > 0 ? 
                    nativeIntensity[nativeIntensity.length - 1].time : 1;
                const tolerance = Math.max(0.1, nativeDuration * 0.15); // 15% of duration

                for (const np of nativePeaks) {
                    for (const up of userPeaks) {
                        if (Math.abs(np.time - up.time) < tolerance) {
                            // Relative height should be similar
                            const heightDiff = Math.abs(np.height - up.height);
                            if (heightDiff < 0.4) matched++;
                            break;
                        }
                    }
                }

                // Penalize for wrong number of syllables
                const countPenalty = Math.abs(nativePeaks.length - userPeaks.length) * 10;
                const score = Math.max(0, Math.min(100, (matched / nativePeaks.length) * 100 - countPenalty));
                
                return {
                    score: Math.round(score),
                    positionScore: Math.round(positionScore),
                    details: {
                        nativePeaks: nativePeaks.length,
                        userPeaks: userPeaks.length,
                        matched: matched,
                        nativeStressPos: (nativePos * 100).toFixed(1) + '%',
                        userStressPos: (userPos * 100).toFixed(1) + '%',
                        positionDiff: (posDiff * 100).toFixed(1) + '%',
                        calculation: `Pattern: ${matched}/${nativePeaks.length} matched, Position: ${positionScore.toFixed(0)}%`
                    }
                };
            }
            
            compareTrack(track1, track2) {
                const minLen = Math.min(track1.length, track2.length);
                let sum = 0;
                
                for (let i = 0; i < minLen; i++) {
                    const diff = Math.abs(track1[i] - track2[i]);
                    sum += 1 / (1 + diff);
                }
                
                return (sum / minLen) * 100;
            }
            
            resample(data, targetLen) {
                const result = new Float32Array(targetLen);
                const ratio = data.length / targetLen;
                
                for (let i = 0; i < targetLen; i++) {
                    const srcIdx = i * ratio;
                    const idx1 = Math.floor(srcIdx);
                    const idx2 = Math.min(idx1 + 1, data.length - 1);
                    const frac = srcIdx - idx1;
                    
                    result[i] = data[idx1] * (1 - frac) + data[idx2] * frac;
                }
                
                return result;
            }
            
            generateFeedback(score, breakdown) {
                const issues = [];
                
                if (breakdown.pitch < 70) {
                    issues.push("Pay attention to pitch patterns and intonation");
                }
                if (breakdown.mfcc < 70) {
                    issues.push("Focus on vowel and consonant quality");
                }
                if (breakdown.envelope < 70) {
                    issues.push("Practice the loudness contour - your amplitude pattern differs");
                }
                if (breakdown.duration < 70) {
                    if (breakdown.duration < 50) {
                        issues.push("Significant timing difference - match the rhythm and pace");
                    } else {
                        issues.push("Adjust your speaking speed to match the native timing");
                    }
                }
                if (breakdown.stressPosition < 70) {
                    issues.push("Move the main stress emphasis to the correct position in the word");
                }
                
                if (score >= 85) {
                    return "Excellent pronunciation! üéâ " + (issues.length > 0 ? issues.join('. ') + '.' : '');
                } else if (score >= 70) {
                    return "Great job! üëç " + issues.join('. ') + '.';
                } else if (score >= 55) {
                    return "Good effort! üìö " + issues.join('. ') + '.';
                } else {
                    return "Keep practicing! üéØ " + issues.join('. ') + '.';
                }
            }
        }

        // ===================================================================
        // VISUALIZER
        // ===================================================================
        class Visualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }
            
            drawAxes(x, y, width, height, xLabel, yLabel, yMin, yMax, yUnit = '') {
                // Draw main axes
                this.ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
                this.ctx.lineWidth = 2;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x, y + height);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y + height);
                this.ctx.lineTo(x + width, y + height);
                this.ctx.stroke();
                
                // Draw Y-axis labels and grid
                this.ctx.fillStyle = 'rgba(209, 213, 219, 0.9)';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'right';
                
                const numYTicks = 5;
                const range = yMax - yMin;
                
                // Calculate nice tick values
                const rawStep = range / (numYTicks - 1);
                const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
                const normalizedStep = rawStep / magnitude;
                
                let niceStep;
                if (normalizedStep <= 1) niceStep = 1;
                else if (normalizedStep <= 2) niceStep = 2;
                else if (normalizedStep <= 5) niceStep = 5;
                else niceStep = 10;
                
                const step = niceStep * magnitude;
                
                // Calculate nice min/max that encompass data range
                const niceMin = Math.floor(yMin / step) * step;
                const niceMax = Math.ceil(yMax / step) * step;
                
                // Draw ticks
                for (let value = niceMin; value <= niceMax; value += step) {
                    if (value < yMin || value > yMax) continue;
                    
                    const normalizedPos = (value - yMin) / (yMax - yMin);
                    const yPos = y + height - (normalizedPos * height);
                    
                    // Grid line
                    this.ctx.strokeStyle = 'rgba(75, 85, 99, 0.15)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, yPos);
                    this.ctx.lineTo(x + width, yPos);
                    this.ctx.stroke();
                    
                    // Tick label
                    this.ctx.fillStyle = 'rgba(209, 213, 219, 0.9)';
                    const labelValue = Math.round(value);
                    this.ctx.fillText(labelValue + yUnit, x - 8, yPos + 4);
                }
                
                // Draw axis labels
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 13px sans-serif';
                this.ctx.textAlign = 'center';
                
                // X-axis label
                if (xLabel) {
                    this.ctx.fillText(xLabel, x + width / 2, y + height + 30);
                }
                
                // Y-axis label (rotated)
                this.ctx.save();
                this.ctx.translate(x - 50, y + height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText(yLabel, 0, 0);
                this.ctx.restore();
            }
            
            drawWaveform(nativeBuffer, userBuffer) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const useOverlay = scalePreferences.displayMode === 'overlay';
                const useDB = scalePreferences.amplitude === 'db';
                
                const nativePeak = this.findPeakAmplitude(nativeBuffer);
                const userPeak = this.findPeakAmplitude(userBuffer);
                
                // Handle shared vs independent normalization
                let effectiveNativePeak = nativePeak;
                let effectiveUserPeak = userPeak;
                if (scalePreferences.waveformNormalization === 'shared') {
                    const sharedPeak = Math.max(nativePeak, userPeak);
                    effectiveNativePeak = sharedPeak;
                    effectiveUserPeak = sharedPeak;
                }
                
                const targetAmplitude = 0.9;
                
                // Calculate displayed time range
                const timeStart = scalePreferences.waveformTimeStart;
                const timeEnd = scalePreferences.waveformTimeEnd;
                const zoomX = scalePreferences.waveformZoomX;
                const baseDuration = Math.max(nativeBuffer.duration, userBuffer.duration);
                const croppedDuration = baseDuration * (timeEnd - timeStart);
                const displayedDuration = croppedDuration / zoomX;
                const displayedStart = baseDuration * timeStart;
                
                if (useOverlay) {
                    const plotWidth = width - 100;
                    const plotHeight = height - 80;
                    const offsetX = 60;
                    const offsetY = 10;
                    
                    let yMin, yMax, yUnit;
                    if (useDB) {
                        yMin = -60;
                        yMax = 0;
                        yUnit = 'dB';
                    } else {
                        yMin = -targetAmplitude;
                        yMax = targetAmplitude;
                        yUnit = '';
                    }
                    
                    this.drawAxes(offsetX, offsetY, plotWidth, plotHeight, 'Time (seconds)', 'Amplitude', yMin, yMax, yUnit);
                    
                    this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                    this.ctx.lineWidth = 1.5;
                    this.drawWaveformData(nativeBuffer, offsetX, offsetY, plotWidth, plotHeight, effectiveNativePeak, targetAmplitude);
                    
                    this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
                    this.ctx.lineWidth = 1.5;
                    this.drawWaveformData(userBuffer, offsetX, offsetY, plotWidth, plotHeight, effectiveUserPeak, targetAmplitude);
                    
                    this.ctx.fillStyle = '#3B82F6';
                    this.ctx.font = 'bold 12px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`‚ñ† Native (peak=${nativePeak.toFixed(3)})`, offsetX, offsetY - 5);
                    
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.fillText(`‚ñ† You (peak=${userPeak.toFixed(3)})`, offsetX + 220, offsetY - 5);
                    
                    this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    for (let i = 0; i <= 4; i++) {
                        const x = offsetX + (i / 4) * plotWidth;
                        const time = displayedStart + (i / 4) * displayedDuration;
                        this.ctx.fillText(time.toFixed(2), x, height - 10);
                    }
                } else {
                    const plotWidth = width - 100;
                    const plotHeight = (height - 80) / 2;
                    const offsetX = 60;
                    
                    let yMin, yMax, yUnit;
                    if (useDB) {
                        yMin = -60;
                        yMax = 0;
                        yUnit = 'dB';
                    } else {
                        yMin = -targetAmplitude;
                        yMax = targetAmplitude;
                        yUnit = '';
                    }
                    
                    this.drawAxes(offsetX, 10, plotWidth, plotHeight, '', 'Amplitude', yMin, yMax, yUnit);
                    this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                    this.ctx.lineWidth = 1.5;
                    this.drawWaveformData(nativeBuffer, offsetX, 10, plotWidth, plotHeight, effectiveNativePeak, targetAmplitude);
                    
                    this.ctx.fillStyle = '#3B82F6';
                    this.ctx.font = 'bold 13px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`Native Speaker`, offsetX, 25);
                    
                    const offsetY = plotHeight + 50;
                    this.drawAxes(offsetX, offsetY, plotWidth, plotHeight, 'Time (seconds)', 'Amplitude', yMin, yMax, yUnit);
                    this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
                    this.drawWaveformData(userBuffer, offsetX, offsetY, plotWidth, plotHeight, effectiveUserPeak, targetAmplitude);
                    
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.fillText(`Your Recording`, offsetX, offsetY + 15);
                    
                    this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    for (let i = 0; i <= 4; i++) {
                        const x = offsetX + (i / 4) * plotWidth;
                        const time = displayedStart + (i / 4) * displayedDuration;
                        this.ctx.fillText(time.toFixed(2), x, height - 10);
                    }
                }
            }
            
            findPeakAmplitude(buffer) {
                const data = buffer.getChannelData(0);
                let peak = 0;
                for (let i = 0; i < data.length; i++) {
                    const abs = Math.abs(data[i]);
                    if (abs > peak) peak = abs;
                }
                return Math.max(peak, 0.01);
            }
            
            drawWaveformData(buffer, x, y, width, height, peakAmplitude, targetAmplitude) {
                const rawData = buffer.getChannelData(0);
                const sampleRate = buffer.sampleRate;
                
                // Apply time cropping
                const timeStart = scalePreferences.waveformTimeStart;
                const timeEnd = scalePreferences.waveformTimeEnd;
                const startSample = Math.floor(timeStart * rawData.length);
                const endSample = Math.floor(timeEnd * rawData.length);
                const croppedData = rawData.slice(startSample, endSample);
                
                // Apply zoom X (focus on portion of time)
                const zoomX = scalePreferences.waveformZoomX;
                const zoomLength = Math.floor(croppedData.length / zoomX);
                const data = croppedData.slice(0, zoomLength);
                
                const step = Math.ceil(data.length / width);
                const centerY = y + height / 2;
                
                const useDB = scalePreferences.amplitude === 'db';
                const useBipolar = scalePreferences.waveformMode === 'bipolar';
                const zoomY = scalePreferences.waveformZoomY;
                const filterMode = scalePreferences.waveformFilterMode;
                const downsampleMode = scalePreferences.waveformDownsample;
                
                // Apply RMS smoothing if selected
                let processedData = data;
                if (filterMode === 'rms') {
                    const windowSize = Math.floor(scalePreferences.waveformRmsWindow);
                    processedData = new Float32Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                        let rms = 0;
                        const start = Math.max(0, i - Math.floor(windowSize / 2));
                        const end = Math.min(data.length, i + Math.floor(windowSize / 2));
                        for (let j = start; j < end; j++) {
                            rms += data[j] * data[j];
                        }
                        rms = Math.sqrt(rms / (end - start));
                        processedData[i] = data[i] >= 0 ? rms : -rms;
                    }
                }
                
                // Calculate percentile threshold if needed
                let percentileThreshold = 0;
                if (filterMode === 'percentile') {
                    const absValues = Array.from(processedData).map(v => Math.abs(v)).sort((a, b) => a - b);
                    const percentileIdx = Math.floor(absValues.length * (1 - scalePreferences.waveformPercentile / 100));
                    percentileThreshold = absValues[Math.max(0, percentileIdx)];
                }
                
                const scaleFactor = useDB ? 1.0 : (targetAmplitude / peakAmplitude);
                
                this.ctx.beginPath();
                let firstPoint = true;
                
                for (let i = 0; i < width; i++) {
                    const startIdx = i * step;
                    const endIdx = Math.min((i + 1) * step, processedData.length);
                    
                    // Get sample values based on downsample mode
                    let minVal = 0, maxVal = 0, avgVal = 0, peakVal = 0;
                    let count = 0;
                    
                    for (let j = startIdx; j < endIdx; j++) {
                        let sample = processedData[j];
                        
                        // Apply filtering
                        if (filterMode === 'threshold' || filterMode === 'noisegate') {
                            const threshold = scalePreferences.waveformThreshold;
                            if (Math.abs(sample) < threshold) {
                                sample = 0;
                            }
                        } else if (filterMode === 'percentile') {
                            if (Math.abs(sample) < percentileThreshold) {
                                sample = 0;
                            }
                        }
                        
                        if (sample < minVal) minVal = sample;
                        if (sample > maxVal) maxVal = sample;
                        if (Math.abs(sample) > Math.abs(peakVal)) peakVal = sample;
                        avgVal += sample;
                        count++;
                    }
                    
                    if (count > 0) avgVal /= count;
                    
                    // Apply zoom Y
                    minVal *= zoomY;
                    maxVal *= zoomY;
                    avgVal *= zoomY;
                    peakVal *= zoomY;
                    
                    // Clip values
                    minVal = Math.max(-1, Math.min(1, minVal));
                    maxVal = Math.max(-1, Math.min(1, maxVal));
                    avgVal = Math.max(-1, Math.min(1, avgVal));
                    peakVal = Math.max(-1, Math.min(1, peakVal));
                    
                    if (useBipolar && !useDB) {
                        // Draw min-max range
                        let drawMin, drawMax;
                        if (downsampleMode === 'minmax') {
                            drawMin = minVal;
                            drawMax = maxVal;
                        } else if (downsampleMode === 'max') {
                            drawMin = peakVal >= 0 ? 0 : peakVal;
                            drawMax = peakVal >= 0 ? peakVal : 0;
                        } else { // avg
                            drawMin = avgVal >= 0 ? 0 : avgVal;
                            drawMax = avgVal >= 0 ? avgVal : 0;
                        }
                        
                        const scaledMin = drawMin * scaleFactor;
                        const scaledMax = drawMax * scaleFactor;
                        
                        const plotYMin = centerY - scaledMin * (height / 2);
                        const plotYMax = centerY - scaledMax * (height / 2);
                        
                        this.ctx.moveTo(x + i, plotYMax);
                        this.ctx.lineTo(x + i, plotYMin);
                    } else {
                        // Envelope mode
                        let absVal;
                        if (downsampleMode === 'minmax' || downsampleMode === 'max') {
                            absVal = Math.max(Math.abs(minVal), Math.abs(maxVal));
                        } else {
                            absVal = Math.abs(avgVal);
                        }
                        
                        let plotY;
                        if (useDB) {
                            const db = 20 * Math.log10(Math.max(absVal, 1e-6));
                            const normalizedDB = Math.max(0, (db + 60) / 60);
                            plotY = centerY - normalizedDB * (height / 2);
                        } else {
                            const scaledVal = absVal * scaleFactor;
                            plotY = centerY - scaledVal * (height / 2);
                        }
                        
                        if (firstPoint) {
                            this.ctx.moveTo(x + i, plotY);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(x + i, plotY);
                        }
                    }
                }
                this.ctx.stroke();
            }
            
            drawSpectrogram(nativeBuffer, userBuffer) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const plotWidth = width - 100;
                const plotHeight = (height - 100) / 3; // 3 panels now
                const offsetX = 60;
                
                // Calculate max frequency based on zoom
                const baseMaxFreq = 8000;
                const maxFreq = baseMaxFreq / scalePreferences.zoomX;
                
                // Compute spectrogram data for both
                const nativeData = this.computeSpectrogramData(nativeBuffer, plotWidth, maxFreq);
                const userData = this.computeSpectrogramData(userBuffer, plotWidth, maxFreq);
                
                // Draw native spectrogram
                this.drawSpectrogramFromData(nativeData, offsetX, 10, plotWidth, plotHeight, maxFreq);
                this.ctx.fillStyle = '#3B82F6';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Native Speaker', offsetX, 22);
                
                // Draw Y-axis frequency labels for native
                this.drawFrequencyYAxis(offsetX, 10, plotHeight, maxFreq);
                
                // Draw user spectrogram
                const userOffsetY = plotHeight + 40;
                this.drawSpectrogramFromData(userData, offsetX, userOffsetY, plotWidth, plotHeight, maxFreq);
                this.ctx.fillStyle = '#EF4444';
                this.ctx.fillText('Your Recording', offsetX, userOffsetY + 12);
                
                // Draw Y-axis frequency labels for user
                this.drawFrequencyYAxis(offsetX, userOffsetY, plotHeight, maxFreq);
                
                // Draw difference spectrogram
                const diffOffsetY = plotHeight * 2 + 70;
                this.drawSpectrogramDifference(nativeData, userData, offsetX, diffOffsetY, plotWidth, plotHeight);
                this.ctx.fillStyle = '#10B981';
                this.ctx.fillText('Difference (Native - User)', offsetX, diffOffsetY + 12);
                
                // Draw Y-axis frequency labels for difference
                this.drawFrequencyYAxis(offsetX, diffOffsetY, plotHeight, maxFreq);
                
                // Legend for difference
                const legendX = width - 35;
                const legendY = diffOffsetY + 20;
                const legendHeight = plotHeight - 30;
                
                for (let i = 0; i < legendHeight; i++) {
                    const normalized = 1 - i / legendHeight;
                    this.ctx.fillStyle = this.differenceToColor(normalized);
                    this.ctx.fillRect(legendX, legendY + i, 12, 1);
                }
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '9px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('+', legendX + 15, legendY + 5);
                this.ctx.fillText('0', legendX + 15, legendY + legendHeight / 2 + 3);
                this.ctx.fillText('-', legendX + 15, legendY + legendHeight);
            }
            
            drawFrequencyYAxis(x, y, height, maxFreq) {
                this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                this.ctx.font = '9px sans-serif';
                this.ctx.textAlign = 'right';
                
                const useMel = scalePreferences.spectrogramFreq === 'mel';
                const numLabels = 5;
                
                if (useMel) {
                    // For mel scale, show Hz values at mel-spaced intervals
                    const maxMel = this.hzToMel(maxFreq);
                    for (let i = 0; i <= numLabels; i++) {
                        const mel = (i / numLabels) * maxMel;
                        const freq = this.melToHz(mel);
                        const yPos = y + height - (i / numLabels) * height;
                        const label = freq >= 1000 ? (freq / 1000).toFixed(1) + 'k' : Math.round(freq).toString();
                        this.ctx.fillText(label, x - 5, yPos + 3);
                    }
                } else {
                    for (let i = 0; i <= numLabels; i++) {
                        const freq = (i / numLabels) * maxFreq;
                        const yPos = y + height - (i / numLabels) * height;
                        const label = freq >= 1000 ? (freq / 1000).toFixed(1) + 'k' : Math.round(freq).toString();
                        this.ctx.fillText(label, x - 5, yPos + 3);
                    }
                }
            }
            
            // Mel scale conversion functions
            hzToMel(hz) {
                return 2595 * Math.log10(1 + hz / 700);
            }
            
            melToHz(mel) {
                return 700 * (Math.pow(10, mel / 2595) - 1);
            }
            
            // Create mel filterbank
            createMelFilterbank(numFilters, fftSize, sampleRate, minFreq = 0, maxFreq = 8000) {
                const minMel = this.hzToMel(minFreq);
                const maxMel = this.hzToMel(maxFreq);
                
                // Create numFilters + 2 points evenly spaced in mel scale
                const melPoints = [];
                for (let i = 0; i < numFilters + 2; i++) {
                    melPoints.push(minMel + (maxMel - minMel) * i / (numFilters + 1));
                }
                
                // Convert back to Hz
                const hzPoints = melPoints.map(mel => this.melToHz(mel));
                
                // Convert to FFT bin indices
                const binPoints = hzPoints.map(hz => Math.floor((fftSize + 1) * hz / sampleRate));
                
                // Create triangular filters
                const filterbank = [];
                for (let i = 1; i < numFilters + 1; i++) {
                    const filter = new Array(Math.floor(fftSize / 2)).fill(0);
                    
                    // Rising edge
                    for (let j = binPoints[i - 1]; j < binPoints[i]; j++) {
                        if (j >= 0 && j < filter.length) {
                            filter[j] = (j - binPoints[i - 1]) / (binPoints[i] - binPoints[i - 1]);
                        }
                    }
                    
                    // Falling edge
                    for (let j = binPoints[i]; j < binPoints[i + 1]; j++) {
                        if (j >= 0 && j < filter.length) {
                            filter[j] = (binPoints[i + 1] - j) / (binPoints[i + 1] - binPoints[i]);
                        }
                    }
                    
                    filterbank.push(filter);
                }
                
                return filterbank;
            }
            
            // Apply mel filterbank to spectrum
            applyMelFilterbank(spectrum, filterbank) {
                return filterbank.map(filter => {
                    let sum = 0;
                    for (let i = 0; i < filter.length && i < spectrum.length; i++) {
                        sum += spectrum[i] * filter[i];
                    }
                    return sum;
                });
            }
            
            computeSpectrogramData(buffer, targetWidth, maxFreq = 8000) {
                const data = buffer.getChannelData(0);
                const fftSize = scalePreferences.fftSize;
                
                // Calculate hop size - use user setting or default to fftSize/4
                let hopSize;
                if (scalePreferences.hopSize === 'auto') {
                    hopSize = Math.floor(fftSize / 4);
                } else {
                    hopSize = parseInt(scalePreferences.hopSize);
                    // Ensure hop size doesn't exceed FFT size
                    if (hopSize > fftSize) {
                        hopSize = Math.floor(fftSize / 4);
                    }
                }
                
                const numFrames = Math.floor((data.length - fftSize) / hopSize);
                const sampleRate = buffer.sampleRate;
                const maxBin = Math.floor((maxFreq / sampleRate) * (fftSize / 2));
                
                if (numFrames <= 0) {
                    debugLog.log(`Audio too short for FFT size ${fftSize}`, 'error');
                    return [];
                }
                
                const useDBMag = scalePreferences.spectrogramMag === 'db';
                const useMel = scalePreferences.spectrogramFreq === 'mel';
                
                // Create mel filterbank if needed
                const numMelBins = scalePreferences.melBins;
                let melFilterbank = null;
                if (useMel) {
                    melFilterbank = this.createMelFilterbank(numMelBins, fftSize, sampleRate, 0, maxFreq);
                }
                
                const spectrogramData = [];
                
                for (let i = 0; i < numFrames; i++) {
                    const start = i * hopSize;
                    const frame = Array.from(data.slice(start, start + fftSize));
                    const windowed = frame.map((sample, idx) =>
                        sample * (0.54 - 0.46 * Math.cos(2 * Math.PI * idx / (fftSize - 1)))
                    );
                    
                    const spectrum = this.computeFFT(windowed);
                    let frameData;
                    
                    if (useMel) {
                        // Apply mel filterbank
                        const melSpectrum = this.applyMelFilterbank(spectrum, melFilterbank);
                        
                        let maxMag = 1;
                        if (!useDBMag) {
                            maxMag = Math.max(...melSpectrum);
                        }
                        
                        frameData = melSpectrum.map(mag => {
                            if (useDBMag) {
                                const db = 20 * Math.log10(mag + 1e-10);
                                return Math.max(0, Math.min(1, (db + 60) / 60));
                            } else {
                                return mag / (maxMag + 1e-10);
                            }
                        });
                    } else {
                        // Standard linear/log bins
                        frameData = [];
                        
                        let maxMag = 1;
                        if (!useDBMag) {
                            maxMag = Math.max(...spectrum.slice(0, maxBin));
                        }
                        
                        for (let bin = 0; bin < maxBin; bin++) {
                            let normalized;
                            if (useDBMag) {
                                const db = 20 * Math.log10(spectrum[bin] + 1e-10);
                                normalized = Math.max(0, Math.min(1, (db + 60) / 60));
                            } else {
                                normalized = spectrum[bin] / (maxMag + 1e-10);
                            }
                            frameData.push(normalized);
                        }
                    }
                    
                    spectrogramData.push(frameData);
                }
                
                return spectrogramData;
            }
            
            drawSpectrogramFromData(spectrogramData, x, y, width, height, maxFreq = 8000) {
                if (!spectrogramData || spectrogramData.length === 0) return;
                
                const numFrames = spectrogramData.length;
                const numBins = spectrogramData[0].length;
                const frameWidth = width / numFrames;
                const binHeight = height / numBins;
                
                const useLogFreq = scalePreferences.spectrogramFreq === 'log';
                const yZoom = scalePreferences.zoomY;
                
                const filterMode = scalePreferences.filterMode;
                const filterValue = scalePreferences.filterValue;
                
                // Pre-calculate thresholds based on filter mode
                let globalThreshold = 0;
                let binThresholds = null;
                
                if (filterMode === 'perbin') {
                    // Calculate max for each frequency bin across all time frames
                    binThresholds = new Array(numBins).fill(0);
                    for (let bin = 0; bin < numBins; bin++) {
                        let binMax = 0;
                        for (let i = 0; i < numFrames; i++) {
                            if (spectrogramData[i][bin] > binMax) {
                                binMax = spectrogramData[i][bin];
                            }
                        }
                        binThresholds[bin] = binMax * (filterValue / 100);
                    }
                } else {
                    // Flatten all values for global calculations
                    const allValues = [];
                    for (let i = 0; i < numFrames; i++) {
                        for (let bin = 0; bin < numBins; bin++) {
                            allValues.push(spectrogramData[i][bin]);
                        }
                    }
                    
                    switch (filterMode) {
                        case 'global': {
                            const globalMax = Math.max(...allValues);
                            globalThreshold = globalMax * (filterValue / 100);
                            break;
                        }
                        case 'percentile': {
                            if (filterValue < 100) {
                                const sorted = [...allValues].sort((a, b) => a - b);
                                const percentileIndex = Math.floor(sorted.length * (1 - filterValue / 100));
                                globalThreshold = sorted[Math.min(percentileIndex, sorted.length - 1)];
                            } else {
                                globalThreshold = 0;
                            }
                            break;
                        }
                        case 'db': {
                            globalThreshold = Math.pow(10, filterValue / 20);
                            break;
                        }
                        case 'statistical': {
                            const mean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                            const variance = allValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / allValues.length;
                            const stdDev = Math.sqrt(variance);
                            globalThreshold = mean + (filterValue * stdDev);
                            break;
                        }
                    }
                }
                
                for (let i = 0; i < numFrames; i++) {
                    for (let bin = 0; bin < numBins; bin++) {
                        let normalized = spectrogramData[i][bin];
                        
                        // Apply filter based on mode
                        if (filterMode === 'perbin') {
                            if (normalized < binThresholds[bin]) {
                                normalized = 0;
                            }
                        } else {
                            if (normalized < globalThreshold) {
                                normalized = 0;
                            }
                        }
                        
                        // Apply Y zoom - boost intensity and clip
                        normalized = Math.min(normalized * yZoom, 1);
                        
                        this.ctx.fillStyle = this.intensityToColor(normalized);
                        
                        let yPos;
                        if (useLogFreq) {
                            const normalizedFreq = Math.log10(bin + 1) / Math.log10(numBins);
                            yPos = y + height - (normalizedFreq * height);
                        } else {
                            yPos = y + height - ((bin + 1) * binHeight);
                        }
                        
                        this.ctx.fillRect(x + (i * frameWidth), yPos, frameWidth + 1, binHeight + 1);
                    }
                }
            }
            
            drawSpectrogramDifference(nativeData, userData, x, y, width, height) {
                if (!nativeData || !userData || nativeData.length === 0 || userData.length === 0) return;
                
                // Resample to same length
                const numFrames = Math.min(nativeData.length, userData.length, Math.floor(width));
                const numBins = nativeData[0].length;
                const frameWidth = width / numFrames;
                const binHeight = height / numBins;
                
                for (let i = 0; i < numFrames; i++) {
                    const nativeIdx = Math.floor(i * nativeData.length / numFrames);
                    const userIdx = Math.floor(i * userData.length / numFrames);
                    
                    for (let bin = 0; bin < numBins; bin++) {
                        const nativeVal = nativeData[nativeIdx][bin];
                        const userVal = userData[userIdx][bin];
                        const diff = (nativeVal - userVal + 1) / 2; // Map -1..1 to 0..1
                        
                        this.ctx.fillStyle = this.differenceToColor(diff);
                        const yPos = y + height - ((bin + 1) * binHeight);
                        this.ctx.fillRect(x + (i * frameWidth), yPos, frameWidth + 1, binHeight + 1);
                    }
                }
            }
            
            differenceToColor(normalized) {
                // Blue (user stronger) -> White (same) -> Red (native stronger)
                if (normalized < 0.5) {
                    const t = normalized * 2;
                    const r = Math.floor(t * 255);
                    const g = Math.floor(t * 255);
                    const b = 255;
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    const t = (normalized - 0.5) * 2;
                    const r = 255;
                    const g = Math.floor((1 - t) * 255);
                    const b = Math.floor((1 - t) * 255);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            
            drawSpectrogramData(buffer, x, y, width, height) {
                const data = buffer.getChannelData(0);
                const fftSize = 512;
                const hopSize = 128;
                const numFrames = Math.floor((data.length - fftSize) / hopSize);
                const maxFreq = 8000;
                const sampleRate = buffer.sampleRate;
                const maxBin = Math.floor((maxFreq / sampleRate) * (fftSize / 2));
                
                const useDBMag = scalePreferences.spectrogramMag === 'db';
                const useLogFreq = scalePreferences.spectrogramFreq === 'log';
                
                const frameWidth = width / numFrames;
                
                for (let i = 0; i < numFrames; i++) {
                    const start = i * hopSize;
                    const frame = Array.from(data.slice(start, start + fftSize));
                    
                    const windowed = frame.map((sample, idx) =>
                        sample * (0.54 - 0.46 * Math.cos(2 * Math.PI * idx / (fftSize - 1)))
                    );
                    
                    const spectrum = this.computeFFT(windowed);
                    
                    let maxMag = 1;
                    if (!useDBMag) {
                        maxMag = Math.max(...spectrum.slice(0, maxBin));
                    }
                    
                    for (let bin = 0; bin < maxBin; bin++) {
                        const magnitude = spectrum[bin];
                        
                        let normalized;
                        if (useDBMag) {
                            const db = 20 * Math.log10(magnitude + 1e-10);
                            normalized = Math.max(0, Math.min(1, (db + 60) / 60));
                        } else {
                            normalized = magnitude / (maxMag + 1e-10);
                        }
                        
                        let yPos;
                        if (useLogFreq) {
                            const freq = (bin / maxBin) * maxFreq;
                            const minFreqLog = Math.log10(Math.max(1, 20));
                            const maxFreqLog = Math.log10(maxFreq);
                            const freqLog = Math.log10(Math.max(freq, 20));
                            const normalizedFreq = (freqLog - minFreqLog) / (maxFreqLog - minFreqLog);
                            yPos = y + height - (normalizedFreq * height);
                        } else {
                            const binHeight = height / maxBin;
                            yPos = y + height - ((bin + 1) * binHeight);
                        }
                        
                        this.ctx.fillStyle = this.intensityToColor(normalized);
                        
                        if (useLogFreq) {
                            const nextFreq = ((bin + 1) / maxBin) * maxFreq;
                            const nextFreqLog = Math.log10(Math.max(nextFreq, 20));
                            const minFreqLog = Math.log10(20);
                            const maxFreqLog = Math.log10(maxFreq);
                            const nextNormalizedFreq = (nextFreqLog - minFreqLog) / (maxFreqLog - minFreqLog);
                            const nextYPos = y + height - (nextNormalizedFreq * height);
                            const barHeight = Math.abs(yPos - nextYPos) + 1;
                            
                            this.ctx.fillRect(
                                x + (i * frameWidth),
                                nextYPos,
                                frameWidth + 1,
                                barHeight
                            );
                        } else {
                            const binHeight = height / maxBin;
                            this.ctx.fillRect(
                                x + (i * frameWidth),
                                yPos,
                                frameWidth + 1,
                                binHeight + 1
                            );
                        }
                    }
                }
            }
            
            intensityToColor(intensity) {
                const r = Math.floor(intensity * 255);
                const g = Math.floor(Math.sin(intensity * Math.PI) * 255);
                const b = Math.floor((1 - intensity) * 255);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            drawSpectrum(nativeBuffer, userBuffer) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const useOverlay = scalePreferences.displayMode === 'overlay';
                
                // Use cached spectra or compute and cache
                if (!spectrumCache.nativeSpectrum) {
                    spectrumCache.nativeSpectrum = this.computeAverageSpectrum(nativeBuffer);
                    debugLog.log('Computed and cached native spectrum');
                }
                if (!spectrumCache.userSpectrum) {
                    spectrumCache.userSpectrum = this.computeAverageSpectrum(userBuffer);
                    debugLog.log('Computed and cached user spectrum');
                }
                
                const nativeSpectrum = spectrumCache.nativeSpectrum;
                const userSpectrum = spectrumCache.userSpectrum;
                
                // Apply zoom - reduce displayed frequency range
                const baseMaxFreq = 5000;
                const maxFreq = baseMaxFreq / scalePreferences.zoomX;
                
                if (useOverlay) {
                    const plotWidth = width - 100;
                    const plotHeight = height - 80;
                    const offsetX = 60;
                    const offsetY = 10;
                    
                    this.drawAxes(offsetX, offsetY, plotWidth, plotHeight, 'Frequency (Hz)', 'Magnitude', 0, 1, '');
                    
                    this.drawSpectrumData(nativeSpectrum, nativeBuffer.sampleRate, offsetX, offsetY, plotWidth, plotHeight, maxFreq, '#3B82F6');
                    this.drawSpectrumData(userSpectrum, userBuffer.sampleRate, offsetX, offsetY, plotWidth, plotHeight, maxFreq, '#EF4444');
                    
                    this.ctx.fillStyle = '#3B82F6';
                    this.ctx.font = 'bold 12px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('‚ñ† Native Speaker', offsetX, offsetY - 5);
                    
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.fillText('‚ñ† Your Recording', offsetX + 150, offsetY - 5);
                    
                    // Draw frequency labels based on zoomed range
                    this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    for (let i = 0; i <= 5; i++) {
                        const freq = (i / 5) * maxFreq;
                        const x = offsetX + (i / 5) * plotWidth;
                        const label = freq >= 1000 ? (freq / 1000).toFixed(1) + 'k' : Math.round(freq).toString();
                        this.ctx.fillText(label, x, height - 10);
                    }
                } else {
                    const plotWidth = width - 100;
                    const plotHeight = (height - 80) / 2;
                    const offsetX = 60;
                    
                    this.ctx.fillStyle = '#3B82F6';
                    this.ctx.font = 'bold 13px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('Native Speaker Spectrum', offsetX, 25);
                    
                    this.drawAxes(offsetX, 10, plotWidth, plotHeight, '', 'Magnitude', 0, 1, '');
                    this.drawSpectrumData(nativeSpectrum, nativeBuffer.sampleRate, offsetX, 10, plotWidth, plotHeight, maxFreq, '#3B82F6');
                    
                    const offsetY = plotHeight + 50;
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.fillText('Your Recording Spectrum', offsetX, offsetY + 15);
                    
                    this.drawAxes(offsetX, offsetY, plotWidth, plotHeight, 'Frequency (Hz)', 'Magnitude', 0, 1, '');
                    this.drawSpectrumData(userSpectrum, userBuffer.sampleRate, offsetX, offsetY, plotWidth, plotHeight, maxFreq, '#EF4444');
                    
                    // Draw frequency labels based on zoomed range
                    this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'center';
                    for (let i = 0; i <= 5; i++) {
                        const freq = (i / 5) * maxFreq;
                        const x = offsetX + (i / 5) * plotWidth;
                        const label = freq >= 1000 ? (freq / 1000).toFixed(1) + 'k' : Math.round(freq).toString();
                        this.ctx.fillText(label, x, height - 10);
                    }
                }
            }
            
            computeAverageSpectrum(buffer) {
                const data = buffer.getChannelData(0);
                const fftSize = scalePreferences.fftSize;
                
                // Calculate hop size - use user setting or default to fftSize/4
                let hopSize;
                if (scalePreferences.hopSize === 'auto') {
                    hopSize = Math.floor(fftSize / 4);
                } else {
                    hopSize = parseInt(scalePreferences.hopSize);
                    if (hopSize > fftSize) {
                        hopSize = Math.floor(fftSize / 4);
                    }
                }
                
                const numFrames = Math.floor((data.length - fftSize) / hopSize);
                
                if (numFrames <= 0) {
                    debugLog.log(`Audio too short for FFT size ${fftSize}`, 'error');
                    return new Array(fftSize / 2).fill(0);
                }
                
                let avgSpectrum = null;
                
                for (let i = 0; i < numFrames; i++) {
                    const start = i * hopSize;
                    const frame = Array.from(data.slice(start, start + fftSize));
                    
                    const windowed = frame.map((sample, idx) =>
                        sample * (0.54 - 0.46 * Math.cos(2 * Math.PI * idx / (fftSize - 1)))
                    );
                    
                    const spectrum = this.computeFFT(windowed);
                    
                    if (!avgSpectrum) {
                        avgSpectrum = new Array(spectrum.length).fill(0);
                    }
                    
                    for (let j = 0; j < spectrum.length; j++) {
                        avgSpectrum[j] += spectrum[j];
                    }
                }
                
                for (let j = 0; j < avgSpectrum.length; j++) {
                    avgSpectrum[j] /= numFrames;
                }
                
                const max = Math.max(...avgSpectrum);
                for (let j = 0; j < avgSpectrum.length; j++) {
                    avgSpectrum[j] /= (max + 1e-10);
                }
                
                return avgSpectrum;
            }
            
            drawSpectrumData(spectrum, sampleRate, x, y, width, height, maxFreq, color) {
                const freqPerBin = sampleRate / (2 * spectrum.length);
                const maxBin = Math.min(spectrum.length, Math.floor(maxFreq / freqPerBin));
                
                // Get values in range for filtering
                const values = spectrum.slice(0, maxBin);
                
                // Calculate threshold based on filter mode
                let threshold = 0;
                const filterMode = scalePreferences.filterMode;
                const filterValue = scalePreferences.filterValue;
                
                switch (filterMode) {
                    case 'global':
                    case 'perbin': {
                        // For spectrum view, per-bin acts like global since it's one frame
                        const maxMag = Math.max(...values);
                        threshold = maxMag * (filterValue / 100);
                        break;
                    }
                    case 'percentile': {
                        if (filterValue < 100) {
                            const sorted = [...values].sort((a, b) => a - b);
                            const percentileIndex = Math.floor(sorted.length * (1 - filterValue / 100));
                            threshold = sorted[Math.min(percentileIndex, sorted.length - 1)];
                        } else {
                            threshold = 0;
                        }
                        break;
                    }
                    case 'db': {
                        // Convert dB to linear threshold
                        threshold = Math.pow(10, filterValue / 20);
                        break;
                    }
                    case 'statistical': {
                        const mean = values.reduce((a, b) => a + b, 0) / values.length;
                        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                        const stdDev = Math.sqrt(variance);
                        threshold = mean + (filterValue * stdDev);
                        break;
                    }
                }
                
                // Apply Y zoom
                const yZoom = scalePreferences.zoomY;
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                for (let bin = 0; bin < maxBin; bin++) {
                    const freq = bin * freqPerBin;
                    let magnitude = spectrum[bin];
                    
                    // Apply filter - values below threshold go to 0
                    if (magnitude < threshold) {
                        magnitude = 0;
                    }
                    
                    // Apply Y zoom - scale magnitude and clip at top
                    magnitude = Math.min(magnitude * yZoom, 1);
                    
                    const xPos = x + (freq / maxFreq) * width;
                    const yPos = y + height - (magnitude * height);
                    
                    if (bin === 0) {
                        this.ctx.moveTo(xPos, yPos);
                    } else {
                        this.ctx.lineTo(xPos, yPos);
                    }
                }
                
                this.ctx.stroke();
            }
            
            computeFFT(signal) {
                const n = signal.length;
                
                // Pad to next power of 2 if needed
                let paddedLength = 1;
                while (paddedLength < n) paddedLength <<= 1;
                
                // Create complex arrays (real and imaginary parts)
                const real = new Float64Array(paddedLength);
                const imag = new Float64Array(paddedLength);
                
                // Copy signal to real part, pad with zeros
                for (let i = 0; i < n; i++) {
                    real[i] = signal[i];
                }
                
                // Bit-reversal permutation
                const bits = Math.log2(paddedLength);
                for (let i = 0; i < paddedLength; i++) {
                    const j = this.reverseBits(i, bits);
                    if (j > i) {
                        [real[i], real[j]] = [real[j], real[i]];
                        [imag[i], imag[j]] = [imag[j], imag[i]];
                    }
                }
                
                // Cooley-Tukey iterative FFT
                for (let size = 2; size <= paddedLength; size *= 2) {
                    const halfSize = size / 2;
                    const angleStep = -2 * Math.PI / size;
                    
                    for (let i = 0; i < paddedLength; i += size) {
                        for (let j = 0; j < halfSize; j++) {
                            const angle = angleStep * j;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            
                            const idx1 = i + j;
                            const idx2 = i + j + halfSize;
                            
                            const tReal = real[idx2] * cos - imag[idx2] * sin;
                            const tImag = real[idx2] * sin + imag[idx2] * cos;
                            
                            real[idx2] = real[idx1] - tReal;
                            imag[idx2] = imag[idx1] - tImag;
                            real[idx1] = real[idx1] + tReal;
                            imag[idx1] = imag[idx1] + tImag;
                        }
                    }
                }
                
                // Compute magnitudes (only need first half due to symmetry)
                const magnitude = new Array(n / 2);
                for (let k = 0; k < n / 2; k++) {
                    magnitude[k] = Math.sqrt(real[k] * real[k] + imag[k] * imag[k]);
                }
                
                return magnitude;
            }
            
            reverseBits(x, bits) {
                let result = 0;
                for (let i = 0; i < bits; i++) {
                    result = (result << 1) | (x & 1);
                    x >>= 1;
                }
                return result;
            }
            
            drawFormants(results) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const native = results.features.nativeFormants;
                const user = results.features.userFormants;
                
                const plotWidth = width - 100;
                const plotHeight = (height - 100) / 3;
                const offsetX = 60;
                
                // Auto-calculate ranges for each formant to use 90% of vertical space
                const getFormantRange = (formant) => {
                    const allValues = [
                        ...native.filter(f => f.voiced).map(f => f[formant]),
                        ...user.filter(f => f.voiced).map(f => f[formant])
                    ];
                    
                    if (allValues.length === 0) {
                        // Fallback to standard ranges
                        if (formant === 'f1') return { min: 200, max: 1200 };
                        if (formant === 'f2') return { min: 500, max: 3500 };
                        if (formant === 'f3') return { min: 1500, max: 4500 };
                    }
                    
                    const min = Math.min(...allValues);
                    const max = Math.max(...allValues);
                    const range = max - min;
                    
                    // Add 10% padding on each side so peaks reach 90% of space
                    const padding = range * 0.111; // (1/0.9 - 1) ‚âà 0.111
                    
                    return {
                        min: Math.max(0, Math.round(min - padding)),
                        max: Math.round(max + padding)
                    };
                };
                
                const f1Range = getFormantRange('f1');
                const f2Range = getFormantRange('f2');
                const f3Range = getFormantRange('f3');
                
                // F1 plot
                this.drawAxes(offsetX, 20, plotWidth, plotHeight, '', 'F1 (Hz)', f1Range.min, f1Range.max, '');
                this.drawFormantTrack(native, user, 'f1', offsetX, 20, plotWidth, plotHeight, f1Range.min, f1Range.max);
                
                // F2 plot
                const y2 = 20 + plotHeight + 30;
                this.drawAxes(offsetX, y2, plotWidth, plotHeight, '', 'F2 (Hz)', f2Range.min, f2Range.max, '');
                this.drawFormantTrack(native, user, 'f2', offsetX, y2, plotWidth, plotHeight, f2Range.min, f2Range.max);
                
                // F3 plot
                const y3 = y2 + plotHeight + 30;
                this.drawAxes(offsetX, y3, plotWidth, plotHeight, 'Time (seconds)', 'F3 (Hz)', f3Range.min, f3Range.max, '');
                this.drawFormantTrack(native, user, 'f3', offsetX, y3, plotWidth, plotHeight, f3Range.min, f3Range.max);
                
                // Legend
                this.ctx.fillStyle = '#3B82F6';
                this.ctx.font = 'bold 13px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('‚ñ† Native Speaker', offsetX, 12);
                this.ctx.fillStyle = '#EF4444';
                this.ctx.fillText('‚ñ† Your Recording', offsetX + 150, 12);
                
                // Add range info for debugging/clarity
                this.ctx.fillStyle = 'rgba(156, 163, 175, 0.7)';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`Range: ${f1Range.min}-${f1Range.max} Hz`, width - 10, 20 + plotHeight / 2);
                this.ctx.fillText(`Range: ${f2Range.min}-${f2Range.max} Hz`, width - 10, y2 + plotHeight / 2);
                this.ctx.fillText(`Range: ${f3Range.min}-${f3Range.max} Hz`, width - 10, y3 + plotHeight / 2);
            }
            
            drawFormantTrack(native, user, formant, x, y, width, height, minFreq, maxFreq) {
                const maxTime = Math.max(
                    native[native.length - 1].time,
                    user[user.length - 1].time
                );
                
                this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                let pathStarted = false;
                native.forEach((point, i) => {
                    const plotX = x + (point.time / maxTime) * width;
                    const plotY = y + height - ((point[formant] - minFreq) / (maxFreq - minFreq)) * height;
                    
                    if (point.voiced) {
                        if (!pathStarted) {
                            this.ctx.moveTo(plotX, plotY);
                            pathStarted = true;
                        } else {
                            this.ctx.lineTo(plotX, plotY);
                        }
                    } else if (pathStarted) {
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        pathStarted = false;
                    }
                });
                if (pathStarted) this.ctx.stroke();
                
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.9)';
                this.ctx.beginPath();
                pathStarted = false;
                user.forEach((point, i) => {
                    const plotX = x + (point.time / maxTime) * width;
                    const plotY = y + height - ((point[formant] - minFreq) / (maxFreq - minFreq)) * height;
                    
                    if (point.voiced) {
                        if (!pathStarted) {
                            this.ctx.moveTo(plotX, plotY);
                            pathStarted = true;
                        } else {
                            this.ctx.lineTo(plotX, plotY);
                        }
                    } else if (pathStarted) {
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        pathStarted = false;
                    }
                });
                if (pathStarted) this.ctx.stroke();
            }
            
            drawPitch(results) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const nativeRaw = results.features.nativePitch;
                const userRaw = results.features.userPitch;
                
                const plotWidth = width - 100;
                const plotHeight = height - 80;
                const offsetX = 60;
                const offsetY = 20;
                
                // Get preferences
                const confidenceThreshold = scalePreferences.pitchConfidenceThreshold;
                const smoothingMode = scalePreferences.pitchSmoothingMode;
                const smoothingWindow = scalePreferences.pitchSmoothingWindow;
                const pitchScale = scalePreferences.pitchScale;
                const normalizeMode = scalePreferences.pitchNormalize;
                const showConfidence = scalePreferences.pitchShowConfidence;
                const showUnvoiced = scalePreferences.pitchShowUnvoiced;
                const manualYMin = scalePreferences.pitchYMin;
                const manualYMax = scalePreferences.pitchYMax;
                
                // Helper: Apply smoothing filter
                const applySmoothing = (pitchValues) => {
                    if (smoothingMode === 'none') return pitchValues;
                    
                    const window = smoothingWindow;
                    const halfWindow = Math.floor(window / 2);
                    const result = [...pitchValues];
                    
                    if (smoothingMode === 'median') {
                        for (let i = 0; i < pitchValues.length; i++) {
                            const start = Math.max(0, i - halfWindow);
                            const end = Math.min(pitchValues.length, i + halfWindow + 1);
                            const windowVals = pitchValues.slice(start, end).filter(v => v > 0).sort((a, b) => a - b);
                            if (windowVals.length > 0) {
                                result[i] = windowVals[Math.floor(windowVals.length / 2)];
                            }
                        }
                    } else if (smoothingMode === 'moving-avg') {
                        for (let i = 0; i < pitchValues.length; i++) {
                            const start = Math.max(0, i - halfWindow);
                            const end = Math.min(pitchValues.length, i + halfWindow + 1);
                            const windowVals = pitchValues.slice(start, end).filter(v => v > 0);
                            if (windowVals.length > 0) {
                                result[i] = windowVals.reduce((a, b) => a + b, 0) / windowVals.length;
                            }
                        }
                    } else if (smoothingMode === 'savitzky-golay') {
                        // Simplified Savitzky-Golay (quadratic, 5-point default)
                        const coeffs = window === 5 ? [-3, 12, 17, 12, -3] : 
                                       window === 7 ? [-2, 3, 6, 7, 6, 3, -2] :
                                       window === 9 ? [-21, 14, 39, 54, 59, 54, 39, 14, -21] :
                                       [1]; // fallback to no filter
                        const norm = coeffs.reduce((a, b) => a + Math.abs(b), 0);
                        
                        for (let i = halfWindow; i < pitchValues.length - halfWindow; i++) {
                            if (pitchValues[i] === 0) continue;
                            let sum = 0;
                            let validCount = 0;
                            for (let j = 0; j < coeffs.length; j++) {
                                const idx = i - halfWindow + j;
                                if (pitchValues[idx] > 0) {
                                    sum += coeffs[j] * pitchValues[idx];
                                    validCount += Math.abs(coeffs[j]);
                                }
                            }
                            if (validCount > 0) {
                                result[i] = sum / validCount * (norm / validCount);
                            }
                        }
                    }
                    
                    return result;
                };
                
                // Helper: Convert Hz to semitones (relative to reference)
                const hzToSemitone = (hz, refHz) => {
                    if (hz <= 0 || refHz <= 0) return 0;
                    return 12 * Math.log2(hz / refHz);
                };
                
                // Process native pitch
                let nativePitches = nativeRaw.map(p => p.pitch);
                let nativeConfidences = nativeRaw.map(p => p.confidence || 0);
                
                // Apply confidence threshold
                nativePitches = nativePitches.map((p, i) => 
                    (nativeConfidences[i] >= confidenceThreshold || confidenceThreshold === 0) ? p : 0
                );
                
                // Apply smoothing
                nativePitches = applySmoothing(nativePitches);
                
                // Process user pitch
                let userPitches = userRaw.map(p => p.pitch);
                let userConfidences = userRaw.map(p => p.confidence || 0);
                
                // Apply confidence threshold
                userPitches = userPitches.map((p, i) => 
                    (userConfidences[i] >= confidenceThreshold || confidenceThreshold === 0) ? p : 0
                );
                
                // Apply smoothing
                userPitches = applySmoothing(userPitches);
                
                // Calculate means for normalization
                const nativeVoiced = nativePitches.filter(p => p > 0);
                const userVoiced = userPitches.filter(p => p > 0);
                const nativeMean = nativeVoiced.length > 0 ? nativeVoiced.reduce((a, b) => a + b, 0) / nativeVoiced.length : 100;
                const userMean = userVoiced.length > 0 ? userVoiced.reduce((a, b) => a + b, 0) / userVoiced.length : 100;
                
                // Determine Y axis range and units
                let minY, maxY, yLabel;
                
                if (pitchScale === 'semitone') {
                    // Convert to semitones
                    const refPitch = normalizeMode === 'mean' ? nativeMean : 100;
                    nativePitches = nativePitches.map(p => p > 0 ? hzToSemitone(p, refPitch) : 0);
                    userPitches = userPitches.map(p => p > 0 ? hzToSemitone(p, normalizeMode === 'mean' ? userMean : refPitch) : 0);
                    
                    const allSemitones = [...nativePitches, ...userPitches].filter(p => p !== 0);
                    if (allSemitones.length > 0) {
                        const dataMin = Math.min(...allSemitones);
                        const dataMax = Math.max(...allSemitones);
                        const range = dataMax - dataMin;
                        minY = dataMin - range * 0.1;
                        maxY = dataMax + range * 0.1;
                    } else {
                        minY = -12;
                        maxY = 12;
                    }
                    yLabel = normalizeMode === 'mean' ? 'Semitones (from mean)' : 'Semitones (from 100Hz)';
                } else {
                    // Linear Hz scale
                    if (normalizeMode === 'mean') {
                        // Normalize both to their means (show deviation)
                        nativePitches = nativePitches.map(p => p > 0 ? p - nativeMean : 0);
                        userPitches = userPitches.map(p => p > 0 ? p - userMean : 0);
                        
                        const allDevs = [...nativePitches, ...userPitches].filter(p => p !== 0);
                        if (allDevs.length > 0) {
                            const absMax = Math.max(...allDevs.map(Math.abs));
                            minY = -absMax * 1.1;
                            maxY = absMax * 1.1;
                        } else {
                            minY = -50;
                            maxY = 50;
                        }
                        yLabel = 'Hz (deviation from mean)';
                    } else {
                        // Normal Hz
                        const allHz = [...nativePitches, ...userPitches].filter(p => p > 0);
                        if (allHz.length > 0) {
                            const dataMin = Math.min(...allHz);
                            const dataMax = Math.max(...allHz);
                            const range = dataMax - dataMin;
                            minY = Math.max(50, dataMin - range * 0.1);
                            maxY = dataMax + range * 0.1;
                        } else {
                            minY = 50;
                            maxY = 400;
                        }
                        yLabel = 'Pitch (Hz)';
                    }
                }
                
                // Apply manual Y range if set
                if (manualYMin > 0) minY = manualYMin;
                if (manualYMax > 0) maxY = manualYMax;
                
                // Draw axes
                this.drawAxes(offsetX, offsetY, plotWidth, plotHeight, 'Time (seconds)', yLabel, minY, maxY, '');
                
                const maxTime = Math.max(
                    nativeRaw[nativeRaw.length - 1].time,
                    userRaw[userRaw.length - 1].time
                );
                
                // Helper: Draw pitch track with options
                const drawTrack = (pitches, times, confidences, color, colorRgb) => {
                    if (showConfidence) {
                        // Draw with variable opacity based on confidence
                        for (let i = 1; i < pitches.length; i++) {
                            if (pitches[i] === 0 || pitches[i-1] === 0) continue;
                            
                            const opacity = 0.3 + 0.7 * (confidences[i] || 0.5);
                            this.ctx.strokeStyle = `rgba(${colorRgb}, ${opacity})`;
                            this.ctx.lineWidth = 1 + 2 * (confidences[i] || 0.5);
                            this.ctx.beginPath();
                            
                            const x1 = offsetX + (times[i-1] / maxTime) * plotWidth;
                            const y1 = offsetY + plotHeight - ((pitches[i-1] - minY) / (maxY - minY)) * plotHeight;
                            const x2 = offsetX + (times[i] / maxTime) * plotWidth;
                            const y2 = offsetY + plotHeight - ((pitches[i] - minY) / (maxY - minY)) * plotHeight;
                            
                            this.ctx.moveTo(x1, y1);
                            this.ctx.lineTo(x2, y2);
                            this.ctx.stroke();
                        }
                    } else {
                        // Standard drawing
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = 2.5;
                        
                        if (showUnvoiced) {
                            // Break line at unvoiced segments
                            this.ctx.beginPath();
                            let started = false;
                            for (let i = 0; i < pitches.length; i++) {
                                if (pitches[i] !== 0) {
                                    const plotX = offsetX + (times[i] / maxTime) * plotWidth;
                                    const plotY = offsetY + plotHeight - ((pitches[i] - minY) / (maxY - minY)) * plotHeight;
                                    if (!started) {
                                        this.ctx.moveTo(plotX, plotY);
                                        started = true;
                                    } else {
                                        this.ctx.lineTo(plotX, plotY);
                                    }
                                } else if (started) {
                                    this.ctx.stroke();
                                    this.ctx.beginPath();
                                    started = false;
                                }
                            }
                            if (started) this.ctx.stroke();
                        } else {
                            // Connect through unvoiced
                            this.ctx.beginPath();
                            let started = false;
                            let lastX = 0, lastY = 0;
                            for (let i = 0; i < pitches.length; i++) {
                                if (pitches[i] !== 0) {
                                    const plotX = offsetX + (times[i] / maxTime) * plotWidth;
                                    const plotY = offsetY + plotHeight - ((pitches[i] - minY) / (maxY - minY)) * plotHeight;
                                    if (!started) {
                                        this.ctx.moveTo(plotX, plotY);
                                        started = true;
                                    } else {
                                        this.ctx.lineTo(plotX, plotY);
                                    }
                                    lastX = plotX;
                                    lastY = plotY;
                                }
                            }
                            this.ctx.stroke();
                        }
                    }
                };
                
                // Draw native pitch
                const nativeTimes = nativeRaw.map(p => p.time);
                drawTrack(nativePitches, nativeTimes, nativeConfidences, 'rgba(59, 130, 246, 0.9)', '59, 130, 246');
                
                // Draw user pitch
                const userTimes = userRaw.map(p => p.time);
                drawTrack(userPitches, userTimes, userConfidences, 'rgba(239, 68, 68, 0.9)', '239, 68, 68');
                
                // Legend
                this.ctx.fillStyle = '#3B82F6';
                this.ctx.font = 'bold 13px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('‚ñ† Native Speaker', offsetX, offsetY - 5);
                this.ctx.fillStyle = '#EF4444';
                this.ctx.fillText('‚ñ† Your Recording', offsetX + 150, offsetY - 5);
                
                // Info
                this.ctx.fillStyle = 'rgba(156, 163, 175, 0.7)';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'right';
                const infoText = `${smoothingMode !== 'none' ? smoothingMode + '(' + smoothingWindow + ')' : 'raw'} | ${pitchScale}${normalizeMode === 'mean' ? ' normalized' : ''}`;
                this.ctx.fillText(infoText, width - 10, offsetY + plotHeight / 2);
                
                // Show means if normalized
                if (normalizeMode === 'mean') {
                    this.ctx.fillText(`Native mean: ${nativeMean.toFixed(0)}Hz | User mean: ${userMean.toFixed(0)}Hz`, width - 10, offsetY + plotHeight / 2 + 15);
                }
            }
            
            drawIntensity(results) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const native = results.features.nativeIntensity;
                const user = results.features.userIntensity;
                
                const plotWidth = width - 100;
                const plotHeight = height - 100;
                const offsetX = 60;
                const offsetY = 40;
                
                const useDB = scalePreferences.amplitude === 'db';
                
                let maxIntensity;
                if (useDB) {
                    maxIntensity = 1;
                } else {
                    maxIntensity = Math.max(
                        ...native.map(d => d.intensity),
                        ...user.map(d => d.intensity)
                    );
                }
                
                const maxTime = Math.max(
                    native[native.length - 1].time,
                    user[user.length - 1].time
                );
                
                this.ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(offsetX, offsetY + plotHeight / 2);
                this.ctx.lineTo(offsetX + plotWidth, offsetY + plotHeight / 2);
                this.ctx.stroke();
                
                this.ctx.fillStyle = 'rgba(209, 213, 219, 0.8)';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'right';
                
                if (useDB) {
                    this.ctx.fillText('0 dB', offsetX - 5, offsetY + plotHeight / 2 + 3);
                    this.ctx.fillText('-30', offsetX - 5, offsetY + plotHeight / 4 + 3);
                    this.ctx.fillText('-30', offsetX - 5, offsetY + 3 * plotHeight / 4 + 3);
                    this.ctx.fillText('-60', offsetX - 5, offsetY + 3);
                    this.ctx.fillText('-60', offsetX - 5, offsetY + plotHeight + 3);
                } else {
                    this.ctx.fillText('0', offsetX - 5, offsetY + plotHeight / 2 + 3);
                }
                
                const barWidth = plotWidth / Math.max(native.length, user.length);
                this.ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                native.forEach((point, i) => {
                    const x = offsetX + (point.time / maxTime) * plotWidth;
                    let barHeight;
                    
                    if (useDB) {
                        const db = 20 * Math.log10(Math.max(point.intensity, 1e-6));
                        const normalizedDB = Math.max(0, (db + 60) / 60);
                        barHeight = normalizedDB * (plotHeight / 2);
                    } else {
                        barHeight = (point.intensity / maxIntensity) * (plotHeight / 2);
                    }
                    
                    this.ctx.fillRect(
                        x,
                        offsetY + plotHeight / 2 - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                });
                
                this.ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                user.forEach((point, i) => {
                    const x = offsetX + (point.time / maxTime) * plotWidth;
                    let barHeight;
                    
                    if (useDB) {
                        const db = 20 * Math.log10(Math.max(point.intensity, 1e-6));
                        const normalizedDB = Math.max(0, (db + 60) / 60);
                        barHeight = normalizedDB * (plotHeight / 2);
                    } else {
                        barHeight = (point.intensity / maxIntensity) * (plotHeight / 2);
                    }
                    
                    this.ctx.fillRect(
                        x,
                        offsetY + plotHeight / 2,
                        barWidth - 1,
                        barHeight
                    );
                });
                
                this.ctx.fillStyle = '#3B82F6';
                this.ctx.font = 'bold 14px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Native Speaker`, offsetX, offsetY - 10);
                
                this.ctx.fillStyle = '#EF4444';
                this.ctx.fillText(`Your Recording`, offsetX, offsetY + plotHeight + 25);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Time (seconds)', width / 2, height - 10);
            }
            
            drawMFCCs(results) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                const native = results.features.nativeMFCCs;
                const user = results.features.userMFCCs;
                
                if (!native || !user || native.length === 0 || user.length === 0) {
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '16px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('No MFCC data available', width / 2, height / 2);
                    return;
                }
                
                // Get settings
                const coeffStart = scalePreferences.mfccCoeffStart;
                const coeffEnd = scalePreferences.mfccCoeffEnd;
                const showDelta = scalePreferences.mfccShowDelta;
                const showDeltaDelta = scalePreferences.mfccShowDeltaDelta;
                const lifter = scalePreferences.mfccLifter;
                const filterMode = scalePreferences.mfccFilterMode;
                const filterValue = scalePreferences.mfccFilterValue;
                const perBinNorm = scalePreferences.mfccPerBinNorm;
                const zoomX = scalePreferences.mfccZoomX;
                const zoomY = scalePreferences.mfccZoomY;
                const colormap = scalePreferences.mfccColormap;
                const symmetric = scalePreferences.mfccSymmetric;
                
                // Calculate delta coefficients if needed
                const computeDeltas = (mfccs) => {
                    const deltas = [];
                    for (let i = 0; i < mfccs.length; i++) {
                        const delta = { time: mfccs[i].time, coeffs: [] };
                        for (let c = 0; c < mfccs[i].coeffs.length; c++) {
                            let sum = 0;
                            const N = 2;
                            for (let n = 1; n <= N; n++) {
                                const prev = i - n >= 0 ? mfccs[i - n].coeffs[c] : mfccs[0].coeffs[c];
                                const next = i + n < mfccs.length ? mfccs[i + n].coeffs[c] : mfccs[mfccs.length - 1].coeffs[c];
                                sum += n * (next - prev);
                            }
                            delta.coeffs[c] = sum / (2 * N * (N + 1) * (2 * N + 1) / 6);
                        }
                        deltas.push(delta);
                    }
                    return deltas;
                };
                
                // Apply liftering
                const applyLifter = (value, coeff, L) => {
                    if (L === 0) return value;
                    const lifterCoeff = 1 + (L / 2) * Math.sin(Math.PI * coeff / L);
                    return value * lifterCoeff;
                };
                
                // Process MFCCs with options
                const processMFCCs = (mfccs) => {
                    let processed = mfccs.map(frame => ({
                        time: frame.time,
                        coeffs: frame.coeffs.slice()
                    }));
                    
                    // Apply liftering
                    if (lifter > 0) {
                        processed = processed.map(frame => ({
                            time: frame.time,
                            coeffs: frame.coeffs.map((v, c) => applyLifter(v, c, lifter))
                        }));
                    }
                    
                    return processed;
                };
                
                let processedNative = processMFCCs(native);
                let processedUser = processMFCCs(user);
                
                // Compute deltas if needed
                let nativeDeltas = showDelta ? computeDeltas(processedNative) : null;
                let userDeltas = showDelta ? computeDeltas(processedUser) : null;
                let nativeDeltaDeltas = showDeltaDelta && nativeDeltas ? computeDeltas(nativeDeltas) : null;
                let userDeltaDeltas = showDeltaDelta && userDeltas ? computeDeltas(userDeltas) : null;
                
                // Apply zoom X (show only first portion)
                const nativeFrames = Math.floor(processedNative.length / zoomX);
                const userFrames = Math.floor(processedUser.length / zoomX);
                processedNative = processedNative.slice(0, nativeFrames);
                processedUser = processedUser.slice(0, userFrames);
                if (nativeDeltas) nativeDeltas = nativeDeltas.slice(0, nativeFrames);
                if (userDeltas) userDeltas = userDeltas.slice(0, userFrames);
                if (nativeDeltaDeltas) nativeDeltaDeltas = nativeDeltaDeltas.slice(0, nativeFrames);
                if (userDeltaDeltas) userDeltaDeltas = userDeltaDeltas.slice(0, userFrames);
                
                const numCoeffs = coeffEnd - coeffStart + 1;
                const offsetX = 100;
                const offsetY = 25;
                const plotWidth = width - offsetX - 40;
                const plotHeight = (height - 100) / 3 - 5;
                
                // Find normalization values
                let maxVal = 0;
                let binMax = {};
                let allValues = [];
                
                const collectValues = (mfccs) => {
                    mfccs.forEach(frame => {
                        for (let c = coeffStart; c <= coeffEnd; c++) {
                            const val = frame.coeffs[c] || 0;
                            allValues.push(Math.abs(val));
                            maxVal = Math.max(maxVal, Math.abs(val));
                            if (!binMax[c]) binMax[c] = 0;
                            binMax[c] = Math.max(binMax[c], Math.abs(val));
                        }
                    });
                };
                
                collectValues(processedNative);
                collectValues(processedUser);
                
                // Calculate filter threshold
                let threshold = 0;
                if (filterMode === 'percentile' && allValues.length > 0) {
                    const sorted = allValues.slice().sort((a, b) => a - b);
                    const idx = Math.floor(sorted.length * (1 - filterValue / 100));
                    threshold = sorted[Math.max(0, idx)];
                } else if (filterMode === 'statistical' && allValues.length > 0) {
                    const mean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                    const variance = allValues.reduce((a, b) => a + (b - mean) ** 2, 0) / allValues.length;
                    const stdDev = Math.sqrt(variance);
                    threshold = mean + filterValue * stdDev;
                }
                
                // Color mapping function
                const getColor = (normalized) => {
                    switch (colormap) {
                        case 'viridis':
                            return this.viridisColor(normalized);
                        case 'plasma':
                            return this.plasmaColor(normalized);
                        case 'grayscale':
                            const g = Math.floor(normalized * 255);
                            return `rgb(${g}, ${g}, ${g})`;
                        case 'jet':
                            return this.jetColor(normalized);
                        case 'bluered':
                        default:
                            return this.mfccToColor(normalized);
                    }
                };
                
                // Draw MFCC panel
                const drawPanel = (mfccs, panelY, label, labelColor) => {
                    const cellWidth = plotWidth / mfccs.length;
                    const cellHeight = plotHeight / numCoeffs;
                    
                    mfccs.forEach((frame, i) => {
                        for (let c = coeffStart; c <= coeffEnd; c++) {
                            let val = frame.coeffs[c] || 0;
                            
                            // Apply per-bin normalization or global
                            let normalizer = perBinNorm ? (binMax[c] || 1) : maxVal;
                            if (normalizer === 0) normalizer = 1;
                            
                            let normVal = val / normalizer;
                            
                            // Apply filter
                            if (filterMode !== 'none' && Math.abs(val) < threshold) {
                                normVal = 0;
                            }
                            
                            // Apply zoom Y
                            normVal *= zoomY;
                            normVal = Math.max(-1, Math.min(1, normVal));
                            
                            // Map to 0-1 for colormap
                            let colorVal;
                            if (symmetric) {
                                colorVal = (normVal + 1) / 2;
                            } else {
                                colorVal = (normVal + 1) / 2;
                            }
                            
                            const color = getColor(colorVal);
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(
                                offsetX + i * cellWidth,
                                panelY + (coeffEnd - c) * cellHeight,
                                Math.max(1, cellWidth),
                                cellHeight
                            );
                        }
                    });
                    
                    // Label
                    this.ctx.fillStyle = labelColor;
                    this.ctx.font = 'bold 12px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(label, offsetX, panelY - 8);
                };
                
                // Draw native panel
                drawPanel(processedNative, offsetY, 'Native Speaker', '#3B82F6');
                
                // Draw user panel
                const userOffsetY = offsetY + plotHeight + 25;
                drawPanel(processedUser, userOffsetY, 'Your Recording', '#EF4444');
                
                // Draw difference panel
                const diffOffsetY = userOffsetY + plotHeight + 25;
                const numFrames = Math.min(processedNative.length, processedUser.length);
                const diffCellWidth = plotWidth / numFrames;
                const cellHeight = plotHeight / numCoeffs;
                
                for (let i = 0; i < numFrames; i++) {
                    const nativeIdx = Math.floor(i * processedNative.length / numFrames);
                    const userIdx = Math.floor(i * processedUser.length / numFrames);
                    
                    for (let c = coeffStart; c <= coeffEnd; c++) {
                        let normalizer = perBinNorm ? (binMax[c] || 1) : maxVal;
                        if (normalizer === 0) normalizer = 1;
                        
                        const nativeVal = (processedNative[nativeIdx].coeffs[c] || 0) / normalizer;
                        const userVal = (processedUser[userIdx].coeffs[c] || 0) / normalizer;
                        const diff = (nativeVal - userVal + 1) / 2;
                        
                        this.ctx.fillStyle = this.differenceToColor(diff);
                        this.ctx.fillRect(
                            offsetX + i * diffCellWidth,
                            diffOffsetY + (coeffEnd - c) * cellHeight,
                            Math.max(1, diffCellWidth),
                            cellHeight
                        );
                    }
                }
                
                this.ctx.fillStyle = '#10B981';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Difference (Native - User)', offsetX, diffOffsetY - 8);
                
                // Y-axis labels
                this.ctx.fillStyle = 'rgba(209, 213, 219, 0.9)';
                this.ctx.font = '9px sans-serif';
                this.ctx.textAlign = 'right';
                for (let c = coeffStart; c <= coeffEnd; c++) {
                    const y2 = userOffsetY + (coeffEnd - c + 0.5) * cellHeight;
                    this.ctx.fillText(`c${c}`, offsetX - 5, y2 + 3);
                }
                
                // X-axis label
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 11px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Time (frames)', width / 2, height - 8);
                
                // Color scale legend
                const legendX = width - 30;
                const legendY = diffOffsetY;
                const legendHeight = plotHeight;
                
                for (let i = 0; i < legendHeight; i++) {
                    const normalized = 1 - i / legendHeight;
                    this.ctx.fillStyle = this.differenceToColor(normalized);
                    this.ctx.fillRect(legendX, legendY + i, 12, 1);
                }
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '9px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('+', legendX + 15, legendY + 5);
                this.ctx.fillText('0', legendX + 15, legendY + legendHeight / 2 + 3);
                this.ctx.fillText('-', legendX + 15, legendY + legendHeight);
            }
            
            // Additional colormap functions
            viridisColor(t) {
                const c0 = [0.267004, 0.004874, 0.329415];
                const c1 = [0.282327, 0.140926, 0.457517];
                const c2 = [0.253935, 0.265254, 0.529983];
                const c3 = [0.206756, 0.371758, 0.553117];
                const c4 = [0.163625, 0.471133, 0.558148];
                const c5 = [0.127568, 0.566949, 0.550556];
                const c6 = [0.134692, 0.658636, 0.517649];
                const c7 = [0.266941, 0.748751, 0.440573];
                const c8 = [0.477504, 0.821444, 0.318195];
                const c9 = [0.741388, 0.873449, 0.149561];
                const c10 = [0.993248, 0.906157, 0.143936];
                
                const colors = [c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10];
                const idx = t * (colors.length - 1);
                const i = Math.floor(idx);
                const f = idx - i;
                
                if (i >= colors.length - 1) {
                    return `rgb(${Math.floor(c10[0]*255)}, ${Math.floor(c10[1]*255)}, ${Math.floor(c10[2]*255)})`;
                }
                
                const r = Math.floor((colors[i][0] * (1 - f) + colors[i + 1][0] * f) * 255);
                const g = Math.floor((colors[i][1] * (1 - f) + colors[i + 1][1] * f) * 255);
                const b = Math.floor((colors[i][2] * (1 - f) + colors[i + 1][2] * f) * 255);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            plasmaColor(t) {
                const c0 = [0.050383, 0.029803, 0.527975];
                const c1 = [0.254627, 0.013882, 0.615419];
                const c2 = [0.417642, 0.000564, 0.658390];
                const c3 = [0.562738, 0.051545, 0.641509];
                const c4 = [0.692840, 0.165141, 0.564522];
                const c5 = [0.798216, 0.280197, 0.469538];
                const c6 = [0.881443, 0.392529, 0.383229];
                const c7 = [0.949217, 0.517763, 0.295662];
                const c8 = [0.988648, 0.652325, 0.211364];
                const c9 = [0.988648, 0.809579, 0.145357];
                const c10 = [0.940015, 0.975158, 0.131326];
                
                const colors = [c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10];
                const idx = t * (colors.length - 1);
                const i = Math.floor(idx);
                const f = idx - i;
                
                if (i >= colors.length - 1) {
                    return `rgb(${Math.floor(c10[0]*255)}, ${Math.floor(c10[1]*255)}, ${Math.floor(c10[2]*255)})`;
                }
                
                const r = Math.floor((colors[i][0] * (1 - f) + colors[i + 1][0] * f) * 255);
                const g = Math.floor((colors[i][1] * (1 - f) + colors[i + 1][1] * f) * 255);
                const b = Math.floor((colors[i][2] * (1 - f) + colors[i + 1][2] * f) * 255);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            jetColor(t) {
                let r, g, b;
                if (t < 0.125) {
                    r = 0; g = 0; b = 0.5 + t * 4;
                } else if (t < 0.375) {
                    r = 0; g = (t - 0.125) * 4; b = 1;
                } else if (t < 0.625) {
                    r = (t - 0.375) * 4; g = 1; b = 1 - (t - 0.375) * 4;
                } else if (t < 0.875) {
                    r = 1; g = 1 - (t - 0.625) * 4; b = 0;
                } else {
                    r = 1 - (t - 0.875) * 4; g = 0; b = 0;
                }
                return `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
            }
            
            mfccToColor(normalized) {
                // Blue -> White -> Red colormap
                if (normalized < 0.5) {
                    const t = normalized * 2;
                    const r = Math.floor(t * 255);
                    const g = Math.floor(t * 255);
                    const b = 255;
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    const t = (normalized - 0.5) * 2;
                    const r = 255;
                    const g = Math.floor((1 - t) * 255);
                    const b = Math.floor((1 - t) * 255);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            
            drawAllFeatures(results) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.fillStyle = '#1f2937';
                this.ctx.fillRect(0, 0, width, height);
                
                // 3x2 grid
                const cols = 3;
                const rows = 2;
                const padding = 8;
                const panelWidth = (width - padding * (cols + 1)) / cols;
                const panelHeight = (height - padding * (rows + 1)) / rows;
                
                // Row 1: Waveform, Spectrum, Spectrogram
                this.drawMiniWaveform(results, padding, padding, panelWidth, panelHeight);
                this.drawMiniSpectrum(results, padding * 2 + panelWidth, padding, panelWidth, panelHeight);
                this.drawMiniSpectrogram(results, padding * 3 + panelWidth * 2, padding, panelWidth, panelHeight);
                
                // Row 2: Pitch, MFCCs, Intensity
                this.drawMiniPitch(results, padding, padding * 2 + panelHeight, panelWidth, panelHeight);
                this.drawMiniMFCCs(results, padding * 2 + panelWidth, padding * 2 + panelHeight, panelWidth, panelHeight);
                this.drawMiniIntensity(results, padding * 3 + panelWidth * 2, padding * 2 + panelHeight, panelWidth, panelHeight);
            }
            
            drawMiniWaveform(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Waveform', x + 8, y + 16);
                
                if (!nativeBuffer || !userBuffer) return;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                const nativeData = nativeBuffer.getChannelData(0);
                const userData = userBuffer.getChannelData(0);
                
                // Draw native waveform
                this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                const nativeStep = Math.ceil(nativeData.length / plotWidth);
                for (let i = 0; i < plotWidth; i++) {
                    const idx = i * nativeStep;
                    const val = nativeData[idx] || 0;
                    const py = offsetY + plotHeight / 2 - val * plotHeight / 2;
                    if (i === 0) this.ctx.moveTo(offsetX + i, py);
                    else this.ctx.lineTo(offsetX + i, py);
                }
                this.ctx.stroke();
                
                // Draw user waveform
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
                this.ctx.beginPath();
                const userStep = Math.ceil(userData.length / plotWidth);
                for (let i = 0; i < plotWidth; i++) {
                    const idx = i * userStep;
                    const val = userData[idx] || 0;
                    const py = offsetY + plotHeight / 2 - val * plotHeight / 2;
                    if (i === 0) this.ctx.moveTo(offsetX + i, py);
                    else this.ctx.lineTo(offsetX + i, py);
                }
                this.ctx.stroke();
            }
            
            drawMiniSpectrum(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Spectrum (FFT)', x + 8, y + 16);
                
                if (!nativeBuffer || !userBuffer) return;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                // Use cached spectrum if available, otherwise compute simplified version
                let nativeSpectrum, userSpectrum;
                
                if (spectrumCache.nativeSpectrum && spectrumCache.userSpectrum) {
                    nativeSpectrum = spectrumCache.nativeSpectrum;
                    userSpectrum = spectrumCache.userSpectrum;
                } else {
                    // Fast simplified spectrum - just one frame from middle
                    const computeQuickSpectrum = (buffer) => {
                        const data = buffer.getChannelData(0);
                        const fftSize = 512;
                        const start = Math.floor(data.length / 2) - fftSize / 2;
                        const numBins = 128;
                        const spectrum = new Float32Array(numBins);
                        
                        // Simple DFT on reduced bins
                        for (let k = 0; k < numBins; k++) {
                            let real = 0, imag = 0;
                            const freq = k * (fftSize / 2) / numBins;
                            for (let n = 0; n < fftSize; n++) {
                                const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (fftSize - 1));
                                const sample = data[start + n] * window;
                                const angle = 2 * Math.PI * freq * n / fftSize;
                                real += sample * Math.cos(angle);
                                imag -= sample * Math.sin(angle);
                            }
                            spectrum[k] = Math.sqrt(real * real + imag * imag);
                        }
                        return spectrum;
                    };
                    
                    nativeSpectrum = computeQuickSpectrum(nativeBuffer);
                    userSpectrum = computeQuickSpectrum(userBuffer);
                }
                
                // Downsample for display
                const displayBins = Math.min(plotWidth, nativeSpectrum.length);
                const binSize = Math.floor(nativeSpectrum.length / displayBins);
                
                const nativeDisplay = [];
                const userDisplay = [];
                for (let i = 0; i < displayBins; i++) {
                    const idx = Math.floor(i * nativeSpectrum.length / displayBins);
                    nativeDisplay.push(nativeSpectrum[idx]);
                    userDisplay.push(userSpectrum[idx]);
                }
                
                const maxVal = Math.max(...nativeDisplay, ...userDisplay, 0.001);
                
                // Draw native spectrum
                this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                nativeDisplay.forEach((val, i) => {
                    const px = offsetX + (i / displayBins) * plotWidth;
                    const py = offsetY + plotHeight - (val / maxVal) * plotHeight;
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                });
                this.ctx.stroke();
                
                // Draw user spectrum
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
                this.ctx.beginPath();
                userDisplay.forEach((val, i) => {
                    const px = offsetX + (i / displayBins) * plotWidth;
                    const py = offsetY + plotHeight - (val / maxVal) * plotHeight;
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                });
                this.ctx.stroke();
            }
            
            drawMiniSpectrogram(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Spectrogram', x + 8, y + 16);
                
                if (!nativeBuffer) return;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                const data = nativeBuffer.getChannelData(0);
                const fftSize = 128; // Smaller for speed
                const numCols = Math.min(plotWidth, 100); // Limit columns
                const hopSize = Math.floor(data.length / numCols);
                const numBins = 24; // Fewer frequency bins
                
                const frameWidth = plotWidth / numCols;
                const binHeight = plotHeight / numBins;
                
                for (let col = 0; col < numCols; col++) {
                    const start = col * hopSize;
                    if (start + fftSize > data.length) break;
                    
                    // Compute simplified spectrum
                    const spectrum = new Float32Array(numBins);
                    for (let k = 0; k < numBins; k++) {
                        let real = 0, imag = 0;
                        const freq = k * (fftSize / 2) / numBins;
                        for (let n = 0; n < fftSize; n++) {
                            const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (fftSize - 1));
                            const sample = data[start + n] * window;
                            const angle = 2 * Math.PI * freq * n / fftSize;
                            real += sample * Math.cos(angle);
                            imag -= sample * Math.sin(angle);
                        }
                        spectrum[k] = Math.sqrt(real * real + imag * imag);
                    }
                    
                    // Draw each frequency bin
                    for (let bin = 0; bin < numBins; bin++) {
                        const magnitude = spectrum[bin];
                        const db = 20 * Math.log10(magnitude + 1e-10);
                        const normalized = Math.max(0, Math.min(1, (db + 60) / 60));
                        
                        this.ctx.fillStyle = this.intensityToColor(normalized);
                        const yPos = offsetY + plotHeight - ((bin + 1) * binHeight);
                        this.ctx.fillRect(
                            offsetX + (col * frameWidth),
                            yPos,
                            frameWidth + 1,
                            binHeight + 1
                        );
                    }
                }
            }
            
            drawMiniMFCCs(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('MFCCs', x + 8, y + 16);
                
                const native = results.features.nativeMFCCs;
                const user = results.features.userMFCCs;
                
                if (!native || !user || native.length === 0) return;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                const numCoeffs = Math.min(12, native[0].coeffs.length - 1); // Skip c0
                
                // Draw MFCC heatmap for native (top half)
                const nativeHeight = plotHeight / 2 - 2;
                const cellWidth = plotWidth / native.length;
                const cellHeight = nativeHeight / numCoeffs;
                
                // Find max value for normalization
                let maxVal = 0;
                native.forEach(frame => {
                    for (let c = 1; c <= numCoeffs; c++) {
                        maxVal = Math.max(maxVal, Math.abs(frame.coeffs[c]));
                    }
                });
                user.forEach(frame => {
                    for (let c = 1; c <= numCoeffs; c++) {
                        maxVal = Math.max(maxVal, Math.abs(frame.coeffs[c]));
                    }
                });
                
                // Draw native MFCCs
                native.forEach((frame, i) => {
                    for (let c = 1; c <= numCoeffs; c++) {
                        const val = frame.coeffs[c] / maxVal;
                        const normalized = (val + 1) / 2; // Map -1..1 to 0..1
                        const color = this.mfccToColor(normalized);
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(
                            offsetX + i * cellWidth,
                            offsetY + (numCoeffs - c) * cellHeight,
                            Math.max(1, cellWidth),
                            cellHeight
                        );
                    }
                });
                
                // Draw user MFCCs (bottom half)
                const userCellWidth = plotWidth / user.length;
                user.forEach((frame, i) => {
                    for (let c = 1; c <= numCoeffs; c++) {
                        const val = frame.coeffs[c] / maxVal;
                        const normalized = (val + 1) / 2;
                        const color = this.mfccToColor(normalized);
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(
                            offsetX + i * userCellWidth,
                            offsetY + nativeHeight + 4 + (numCoeffs - c) * cellHeight,
                            Math.max(1, userCellWidth),
                            cellHeight
                        );
                    }
                });
                
                // Labels
                this.ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                this.ctx.font = '9px sans-serif';
                this.ctx.fillText('Native', x + width - 45, y + 16);
                this.ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
                this.ctx.fillText('User', x + width - 45, offsetY + nativeHeight + plotHeight / 2);
            }
            
            drawMiniPitch(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Pitch Contour', x + 8, y + 16);
                
                const native = results.features.nativePitch;
                const user = results.features.userPitch;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                // Auto-calculate pitch range
                const nativePitches = native.filter(p => p.pitch > 0).map(p => p.pitch);
                const userPitches = user.filter(p => p.pitch > 0).map(p => p.pitch);
                const allPitches = [...nativePitches, ...userPitches];
                
                let minPitch = 50, maxPitch = 400;
                if (allPitches.length > 0) {
                    const dataMin = Math.min(...allPitches);
                    const dataMax = Math.max(...allPitches);
                    const range = dataMax - dataMin;
                    const padding = range * 0.111;
                    minPitch = Math.max(50, dataMin - padding);
                    maxPitch = dataMax + padding;
                }
                
                const maxTime = Math.max(native[native.length - 1].time, user[user.length - 1].time);
                
                // Draw native pitch
                this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                let started = false;
                native.forEach(p => {
                    if (p.pitch > 0) {
                        const px = offsetX + (p.time / maxTime) * plotWidth;
                        const py = offsetY + plotHeight - ((p.pitch - minPitch) / (maxPitch - minPitch)) * plotHeight;
                        if (!started) { this.ctx.moveTo(px, py); started = true; }
                        else this.ctx.lineTo(px, py);
                    }
                });
                this.ctx.stroke();
                
                // Draw user pitch
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.9)';
                this.ctx.beginPath();
                started = false;
                user.forEach(p => {
                    if (p.pitch > 0) {
                        const px = offsetX + (p.time / maxTime) * plotWidth;
                        const py = offsetY + plotHeight - ((p.pitch - minPitch) / (maxPitch - minPitch)) * plotHeight;
                        if (!started) { this.ctx.moveTo(px, py); started = true; }
                        else this.ctx.lineTo(px, py);
                    }
                });
                this.ctx.stroke();
            }
            
            drawMiniIntensity(results, x, y, width, height) {
                this.ctx.fillStyle = 'rgba(55, 65, 81, 0.5)';
                this.ctx.fillRect(x, y, width, height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Intensity/Energy', x + 8, y + 16);
                
                const native = results.features.nativeIntensity;
                const user = results.features.userIntensity;
                
                const plotWidth = width - 16;
                const plotHeight = height - 28;
                const offsetX = x + 8;
                const offsetY = y + 22;
                
                const barWidth = plotWidth / Math.max(native.length, user.length);
                const maxIntensity = Math.max(
                    ...native.map(d => d.intensity),
                    ...user.map(d => d.intensity)
                );
                
                this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                native.forEach((p, i) => {
                    const barHeight = (p.intensity / maxIntensity) * (plotHeight / 2);
                    this.ctx.fillRect(
                        offsetX + (i / native.length) * plotWidth,
                        offsetY + plotHeight / 2 - barHeight,
                        Math.max(1, barWidth * 0.8),
                        barHeight
                    );
                });
                
                this.ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                user.forEach((p, i) => {
                    const barHeight = (p.intensity / maxIntensity) * (plotHeight / 2);
                    this.ctx.fillRect(
                        offsetX + (i / user.length) * plotWidth,
                        offsetY + plotHeight / 2,
                        Math.max(1, barWidth * 0.8),
                        barHeight
                    );
                });
            }
        }

        // ===================================================================
        // UI EVENT HANDLERS (Simplified initialization)
        // ===================================================================
        const visualizer = new Visualizer(document.getElementById('vizCanvas'));
        const comparator = new PronunciationComparator();
        
        debugLog.log('Initializing...');
        
        const micStatus = document.getElementById('micStatus');
        micStatus.style.display = 'block';
        
        navigator.mediaDevices.getUserMedia({ audio: true })
        .then(s => {
            stream = s;
            mediaRecorder = new MediaRecorder(stream);
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                if (audioChunks.length === 0) return;
                
                userAudioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                audioChunks = [];
                
                try {
                    const arrayBuffer = await userAudioBlob.arrayBuffer();
                    const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    userBuffer = trimSilence(decodedBuffer);
                    
                    // Clear user cache since we have new audio
                    spectrumCache.userSpectrum = null;
                    spectrumCache.userSpectrogram = null;
                    
                    document.getElementById('userRecordingSection').classList.add('show');
                    document.getElementById('userDurationText').textContent = 
                        `Duration: ${userBuffer.duration.toFixed(1)}s`;
                    
                    document.getElementById('compareBtn').disabled = false;
                } catch (err) {
                    debugLog.log(`Error: ${err.message}`, 'error');
                    alert('Error processing recording: ' + err.message);
                }
            };
            
            micStatus.textContent = '‚úÖ Microphone ready!';
            micStatus.classList.add('ready');
        })
        .catch(err => {
            debugLog.log(`Microphone error: ${err.message}`, 'error');
            micStatus.textContent = '‚ùå Microphone access denied';
            micStatus.classList.add('error');
        });
        
        document.getElementById('nativeAudioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            debugLog.log(`File selected: ${file.name} (${file.size} bytes)`);
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                nativeBuffer = trimSilence(decodedBuffer);
                
                // Clear native cache since we have new audio
                spectrumCache.nativeSpectrum = null;
                spectrumCache.nativeSpectrogram = null;
                
                debugLog.log(`Native audio loaded: ${nativeBuffer.duration.toFixed(2)}s`, 'success');
                
                nativeAudioElement = new Audio(URL.createObjectURL(file));
                
                document.getElementById('uploadSection').classList.add('has-file');
                document.getElementById('fileLoaded').classList.add('show');
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileDurationText').textContent = 
                    `Duration: ${nativeBuffer.duration.toFixed(1)}s`;
                
                const wordName = file.name.replace(/\.(mp3|m4a|wav|webm|ogg)$/i, '');
                document.getElementById('targetWord').textContent = wordName;
                document.getElementById('targetTranslation').textContent = 'Ready to practice!';
                
                document.getElementById('recordBtn').disabled = false;
                
                // Enable user audio upload
                document.getElementById('userAudioFile').disabled = false;
                document.getElementById('userUploadLabel').style.opacity = '1';
                document.getElementById('userUploadLabel').style.cursor = 'pointer';
                
                if (userBuffer) {
                    updateVisualization();
                }
            } catch (err) {
                debugLog.log(`Error loading file: ${err.message}`, 'error');
                alert('Could not load audio file. Please ensure it\'s a valid audio format.');
            }
        });
        
        // User audio file upload handler
        document.getElementById('userAudioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            debugLog.log(`User file selected: ${file.name} (${file.size} bytes)`);
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                userBuffer = trimSilence(decodedBuffer);
                
                // Create blob for playback
                userAudioBlob = file;
                
                // Clear user cache since we have new audio
                spectrumCache.userSpectrum = null;
                spectrumCache.userSpectrogram = null;
                
                debugLog.log(`User audio loaded: ${userBuffer.duration.toFixed(2)}s`, 'success');
                
                document.getElementById('userRecordingSection').classList.add('show');
                document.getElementById('userDurationText').textContent = 
                    `Duration: ${userBuffer.duration.toFixed(1)}s`;
                
                document.getElementById('compareBtn').disabled = false;
                
                if (nativeBuffer) {
                    updateVisualization();
                }
            } catch (err) {
                debugLog.log(`Error loading user file: ${err.message}`, 'error');
                alert('Could not load audio file. Please ensure it\'s a valid audio format.');
            }
        });
        
        document.getElementById('recordBtn').addEventListener('click', () => {
            if (!mediaRecorder) return;
            
            if (mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                document.getElementById('recordText').textContent = 'Record Your Voice';
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('recordBtn').classList.remove('recording');
            } else {
                audioChunks = [];
                mediaRecorder.start();
                document.getElementById('recordText').textContent = 'Stop Recording';
                document.getElementById('recordingIndicator').classList.add('active');
                document.getElementById('recordBtn').classList.add('recording');
            }
        });
        
        document.getElementById('compareBtn').addEventListener('click', async () => {
            if (!nativeBuffer || !userBuffer) return;
            
            debugLog.log('Starting comparison...');
            
            const userData = userBuffer.getChannelData(0);
            let maxAmp = 0;
            let rms = 0;
            for (let i = 0; i < userData.length; i++) {
                maxAmp = Math.max(maxAmp, Math.abs(userData[i]));
                rms += userData[i] * userData[i];
            }
            rms = Math.sqrt(rms / userData.length);
            
            debugLog.log(`Validation - Max: ${maxAmp.toFixed(4)}, RMS: ${rms.toFixed(4)}`);
            
            if (maxAmp < 0.01 || rms < 0.001) {
                alert('Your recording appears to be silent or too quiet. Please record again.');
                debugLog.log('Analysis rejected: invalid audio', 'error');
                return;
            }
            
            document.getElementById('feedback').textContent = 'Processing...';
            document.getElementById('results').classList.add('show');
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                analysisResults = comparator.compare(nativeBuffer, userBuffer);
                detailedAnalysis = analysisResults.detailedReport;
                
                showResults(analysisResults);
                showDetailedAnalysis(detailedAnalysis);
                updateVisualization();
                
                document.getElementById('exportAnalysis').disabled = false;
                
                // Enable AI analysis button if API is configured
                const aiBtn = document.getElementById('aiAnalysisBtn');
                if (aiBtn && anthropicApiKey) {
                    aiBtn.disabled = false;
                }
                
                debugLog.log('Analysis complete', 'success');
            } catch (err) {
                debugLog.log(`Error: ${err.message}`, 'error');
                console.error('Full error:', err);
                alert('Error during analysis: ' + err.message);
            }
        });
        
        document.getElementById('playNative').addEventListener('click', async () => {
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            if (nativeAudioElement) {
                nativeAudioElement.currentTime = 0;
                nativeAudioElement.volume = 1.0;
                nativeAudioElement.play()
                    .then(() => debugLog.log('Native playback started', 'success'))
                    .catch(err => alert('Could not play audio: ' + err.message));
            }
        });
        
        document.getElementById('playUser').addEventListener('click', async () => {
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            if (userAudioBlob) {
                const audioURL = URL.createObjectURL(userAudioBlob);
                const audio = new Audio(audioURL);
                audio.volume = 1.0;
                audio.play()
                    .then(() => debugLog.log('User playback started', 'success'))
                    .catch(err => alert('Could not play recording: ' + err.message));
            }
        });
        
        document.getElementById('tryAgain').addEventListener('click', () => {
            document.getElementById('results').classList.remove('show');
            userBuffer = null;
            userAudioBlob = null;
            // Clear user cache
            spectrumCache.userSpectrum = null;
            spectrumCache.userSpectrogram = null;
            document.getElementById('compareBtn').disabled = true;
            document.getElementById('exportAnalysis').disabled = true;
            document.getElementById('userRecordingSection').classList.remove('show');
            debugLog.log('Reset for new recording');
        });
        
        // Balanced Prompt button handler
        document.getElementById('copyBalancedPrompt').addEventListener('click', () => {
            if (!analysisResults) {
                alert('No analysis results available. Please analyze pronunciation first.');
                return;
            }
            
            // Prompt for word name
            const wordName = prompt('Enter the target word/phrase:', 'nagtudlo');
            if (!wordName) return;
            
            const promptText = generateAIPromptBalanced(analysisResults, wordName);
            
            navigator.clipboard.writeText(promptText).then(() => {
                const btn = document.getElementById('copyBalancedPrompt');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úÖ</span><span>Copied!</span>';
                btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%)';
                }, 2000);
                
                debugLog.log('Balanced AI prompt copied to clipboard (~30K)', 'success');
            }).catch(err => {
                alert('Failed to copy: ' + err.message);
            });
        });
        
        // Full Prompt button handler
        document.getElementById('copyFullPrompt').addEventListener('click', () => {
            if (!analysisResults) {
                alert('No analysis results available. Please analyze pronunciation first.');
                return;
            }
            
            // Prompt for word name
            const wordName = prompt('Enter the target word/phrase:', 'nagtudlo');
            if (!wordName) return;
            
            const promptText = generateAIPromptFull(analysisResults, wordName);
            
            navigator.clipboard.writeText(promptText).then(() => {
                const btn = document.getElementById('copyFullPrompt');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úÖ</span><span>Copied!</span>';
                btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)';
                }, 2000);
                
                debugLog.log('Full AI prompt copied to clipboard (~280K)', 'success');
            }).catch(err => {
                alert('Failed to copy: ' + err.message);
            });
        });
        
        function generateAIPromptLean(results, wordName) {
            const features = results.features;
            
            // Pitch data
            const nativePitch = features.nativePitch;
            const userPitch = features.userPitch;
            
            // Get basic pitch stats
            const getPitchStats = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0).map(p => p.pitch);
                if (voiced.length === 0) return { mean: 0, min: 0, max: 0, std: 0 };
                const mean = voiced.reduce((a, b) => a + b, 0) / voiced.length;
                const std = Math.sqrt(voiced.reduce((sum, x) => sum + (x - mean) ** 2, 0) / voiced.length);
                return {
                    mean: Math.round(mean),
                    min: Math.round(Math.min(...voiced)),
                    max: Math.round(Math.max(...voiced)),
                    std: Math.round(std)
                };
            };
            
            // Sample pitch contour (~20 points)
            const samplePitchContour = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length === 0) return [];
                const step = Math.max(1, Math.floor(voiced.length / 20));
                return voiced.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    hz: Math.round(p.pitch)
                }));
            };
            
            // Find pitch peaks and valleys
            const findPitchLandmarks = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length < 3) return { peaks: [], valleys: [], pattern: 'insufficient data' };
                
                const peaks = [];
                const valleys = [];
                
                // Find local maxima and minima with some smoothing
                for (let i = 2; i < voiced.length - 2; i++) {
                    const prev2 = voiced[i-2].pitch;
                    const prev1 = voiced[i-1].pitch;
                    const curr = voiced[i].pitch;
                    const next1 = voiced[i+1].pitch;
                    const next2 = voiced[i+2].pitch;
                    
                    // Peak: higher than neighbors
                    if (curr > prev1 && curr > next1 && curr > prev2 && curr > next2) {
                        // Only add if significantly different from last peak
                        if (peaks.length === 0 || Math.abs(curr - peaks[peaks.length-1].hz) > 20) {
                            peaks.push({ t: parseFloat(voiced[i].time.toFixed(2)), hz: Math.round(curr) });
                        }
                    }
                    // Valley: lower than neighbors
                    if (curr < prev1 && curr < next1 && curr < prev2 && curr < next2) {
                        if (valleys.length === 0 || Math.abs(curr - valleys[valleys.length-1].hz) > 20) {
                            valleys.push({ t: parseFloat(voiced[i].time.toFixed(2)), hz: Math.round(curr) });
                        }
                    }
                }
                
                // Find the main peak (highest)
                const allPitches = voiced.map(p => p.pitch);
                const maxPitch = Math.max(...allPitches);
                const maxIdx = allPitches.indexOf(maxPitch);
                const mainPeak = { t: parseFloat(voiced[maxIdx].time.toFixed(2)), hz: Math.round(maxPitch) };
                
                // Determine pattern based on peak location and contour shape
                const duration = voiced[voiced.length - 1].time;
                const peakPosition = mainPeak.t / duration;
                
                const startAvg = voiced.slice(0, Math.floor(voiced.length * 0.15)).reduce((a, b) => a + b.pitch, 0) / Math.floor(voiced.length * 0.15);
                const endAvg = voiced.slice(Math.floor(voiced.length * 0.85)).reduce((a, b) => a + b.pitch, 0) / (voiced.length - Math.floor(voiced.length * 0.85));
                
                let pattern;
                const range = maxPitch - Math.min(...allPitches);
                const isErratic = peaks.length > 2 || (peaks.length > 1 && valleys.length > 1);
                
                if (isErratic) {
                    if (peakPosition > 0.7) {
                        pattern = 'erratic-late-peak';
                    } else {
                        pattern = 'erratic';
                    }
                } else if (peakPosition < 0.3) {
                    pattern = endAvg < startAvg ? 'early-peak-falling' : 'early-peak';
                } else if (peakPosition > 0.7) {
                    pattern = 'late-peak';
                } else if (peakPosition > 0.4 && peakPosition < 0.6) {
                    if (endAvg < startAvg * 0.8) {
                        pattern = 'rising-falling';
                    } else if (endAvg > startAvg * 1.2) {
                        pattern = 'falling-rising';
                    } else {
                        pattern = 'mid-peak';
                    }
                } else if (endAvg > startAvg * 1.15) {
                    pattern = 'rising';
                } else if (endAvg < startAvg * 0.85) {
                    pattern = 'falling';
                } else {
                    pattern = 'relatively flat';
                }
                
                return { 
                    peaks: peaks.slice(0, 3), 
                    valleys: valleys.slice(0, 3), 
                    mainPeak,
                    pattern 
                };
            };
            
            // Intensity data
            const nativeIntensity = features.nativeIntensity;
            const userIntensity = features.userIntensity;
            
            const getIntensityProfile = (intensityData) => {
                if (!intensityData || intensityData.length === 0) return { peaks: [], hasGaps: false, samples: [] };
                
                const maxIntensity = Math.max(...intensityData.map(i => i.intensity));
                const meanIntensity = intensityData.reduce((a, b) => a + b.intensity, 0) / intensityData.length;
                
                // Use 50% of max for peak detection (more sensitive)
                const peakThreshold = maxIntensity * 0.5;
                
                // Find peaks (local maxima above threshold)
                const peaks = [];
                for (let i = 1; i < intensityData.length - 1; i++) {
                    if (intensityData[i].intensity > peakThreshold &&
                        intensityData[i].intensity > intensityData[i-1].intensity &&
                        intensityData[i].intensity > intensityData[i+1].intensity) {
                        // Avoid peaks too close together
                        if (peaks.length === 0 || intensityData[i].time - peaks[peaks.length-1].t > 0.08) {
                            peaks.push({
                                t: parseFloat(intensityData[i].time.toFixed(3)),
                                val: parseFloat((intensityData[i].intensity * 100).toFixed(1))
                            });
                        }
                    }
                }
                
                // Check for gaps (intensity drops below 15% of max)
                const gapThreshold = maxIntensity * 0.15;
                let hasGaps = false;
                const gaps = [];
                let inGap = false;
                let gapStart = 0;
                
                for (let i = 0; i < intensityData.length; i++) {
                    if (intensityData[i].intensity < gapThreshold) {
                        if (!inGap) {
                            inGap = true;
                            gapStart = intensityData[i].time;
                        }
                    } else {
                        if (inGap) {
                            const gapEnd = intensityData[i].time;
                            if (gapEnd - gapStart > 0.05) { // Gap must be > 50ms
                                gaps.push({
                                    start: parseFloat(gapStart.toFixed(2)),
                                    end: parseFloat(gapEnd.toFixed(2))
                                });
                                hasGaps = true;
                            }
                            inGap = false;
                        }
                    }
                }
                
                // Sample intensity profile (~20 points)
                const step = Math.max(1, Math.floor(intensityData.length / 20));
                const samples = intensityData.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    val: parseFloat((p.intensity * 100).toFixed(1))
                }));
                
                return { 
                    peaks: peaks.slice(0, 5), 
                    hasGaps, 
                    gaps: gaps.slice(0, 3),
                    samples,
                    mean: parseFloat((meanIntensity * 100).toFixed(1))
                };
            };
            
            // MFCC summary
            const nativeMFCCs = features.nativeMFCCs;
            const userMFCCs = features.userMFCCs;
            
            const getMFCCSummary = (mfccData) => {
                if (!mfccData || mfccData.length === 0) return {};
                
                const firstFrame = mfccData[0];
                const coeffArray = firstFrame.coeffs || firstFrame.coefficients || [];
                const numCoeffs = Math.min(6, coeffArray.length);
                const summary = {};
                
                for (let c = 0; c < numCoeffs; c++) {
                    const vals = mfccData.map(f => {
                        const arr = f.coeffs || f.coefficients || [];
                        return arr[c] || 0;
                    });
                    
                    const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                    const std = Math.sqrt(vals.reduce((sum, x) => sum + (x - mean) ** 2, 0) / vals.length);
                    
                    summary[`c${c}`] = {
                        mean: parseFloat(mean.toFixed(1)),
                        std: parseFloat(std.toFixed(1))
                    };
                }
                return summary;
            };
            
            // Calculate durations
            const nativeDuration = parseFloat((nativePitch[nativePitch.length - 1]?.time || 0).toFixed(3));
            const userDuration = parseFloat((userPitch[userPitch.length - 1]?.time || 0).toFixed(3));
            const durationRatio = parseFloat((Math.min(nativeDuration, userDuration) / Math.max(nativeDuration, userDuration)).toFixed(2));
            
            // Get all the analysis data
            const nativePitchStats = getPitchStats(nativePitch);
            const userPitchStats = getPitchStats(userPitch);
            const nativeLandmarks = findPitchLandmarks(nativePitch);
            const userLandmarks = findPitchLandmarks(userPitch);
            const nativeIntProfile = getIntensityProfile(nativeIntensity);
            const userIntProfile = getIntensityProfile(userIntensity);
            const nativeMFCCSummary = getMFCCSummary(nativeMFCCs);
            const userMFCCSummary = getMFCCSummary(userMFCCs);
            
            // Pre-calculate comparisons
            const comparisons = {
                durationDiff: Math.round((userDuration - nativeDuration) * 1000), // in ms
                pitchMeanDiff: userPitchStats.mean - nativePitchStats.mean,
                energyDiff: parseFloat(((userMFCCSummary.c0?.mean || 0) - (nativeMFCCSummary.c0?.mean || 0)).toFixed(1)),
                peakTimeDiff: nativeLandmarks.mainPeak && userLandmarks.mainPeak 
                    ? parseFloat((userLandmarks.mainPeak.t - nativeLandmarks.mainPeak.t).toFixed(2))
                    : null,
                userPeakLate: nativeLandmarks.mainPeak && userLandmarks.mainPeak 
                    ? userLandmarks.mainPeak.t > nativeLandmarks.mainPeak.t + 0.1
                    : false,
                patternMatch: nativeLandmarks.pattern === userLandmarks.pattern
            };
            
            // Build data object
            const data = {
                word: wordName,
                duration: {
                    native: nativeDuration,
                    user: userDuration,
                    ratio: durationRatio
                },
                pitch: {
                    native: { 
                        ...nativePitchStats, 
                        pattern: nativeLandmarks.pattern,
                        mainPeak: nativeLandmarks.mainPeak,
                        samples: samplePitchContour(nativePitch)
                    },
                    user: { 
                        ...userPitchStats, 
                        pattern: userLandmarks.pattern,
                        mainPeak: userLandmarks.mainPeak,
                        samples: samplePitchContour(userPitch)
                    }
                },
                intensity: {
                    native: nativeIntProfile,
                    user: userIntProfile
                },
                mfcc: {
                    native: nativeMFCCSummary,
                    user: userMFCCSummary
                },
                comparisons
            };
            
            const prompt = `You are a pronunciation coach for Cebuano language learners. Analyze this data and provide practical feedback suitable for a 10th grader (max 200 words).

## Target Word: "${wordName}"

## Analysis Data
\`\`\`json
${JSON.stringify(data, null, 2)}
\`\`\`

## How to Interpret
- **Duration**: ratio 1.0 = same speed; durationDiff in ms (positive = user slower)
- **Pitch**: 
  - pattern describes overall shape (rising-falling, late-peak, erratic, etc.)
  - mainPeak shows where the highest pitch occurs (t = time, hz = frequency)
  - peakTimeDiff shows if user's peak is early/late vs native
- **Intensity**: 
  - peaks show stressed syllable times and strength
  - gaps show syllable boundaries (start/end times)
  - mean shows overall loudness
- **MFCCs**: 
  - c0 mean = energy (energyDiff shows if user is quieter/louder)
  - c1-c4 std = vowel variation (higher = more dynamic)
- **Comparisons**: Pre-calculated differences to quickly identify issues

## Common English‚ÜíCebuano Issues
- Vowel reduction (schwa instead of full vowels)
- Flat pitch (Cebuano should be more musical)
- Wrong pitch pattern (should match native's rising-falling, etc.)
- Connected speech (should have clear syllable gaps)
- Aspirated stops (should be unaspirated)
- Dark /l/ (should be clear /l/)

## Your Task
Provide feedback with:
1. What they're doing well (1 sentence)
2. 3-4 specific issues to fix with practical instructions
3. One quick practice exercise

Keep it encouraging, specific, and actionable. No technical jargon.`;

            return prompt;
        }
        
        // BALANCED APPROACH: ~30K with per-syllable MFCC analysis
        function generateAIPromptBalanced(results, wordName) {
            const features = results.features;
            
            // Pitch data
            const nativePitch = features.nativePitch;
            const userPitch = features.userPitch;
            
            // Get basic pitch stats
            const getPitchStats = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0).map(p => p.pitch);
                if (voiced.length === 0) return { mean: 0, min: 0, max: 0, std: 0 };
                const mean = voiced.reduce((a, b) => a + b, 0) / voiced.length;
                const std = Math.sqrt(voiced.reduce((sum, x) => sum + (x - mean) ** 2, 0) / voiced.length);
                return {
                    mean: Math.round(mean),
                    min: Math.round(Math.min(...voiced)),
                    max: Math.round(Math.max(...voiced)),
                    std: Math.round(std)
                };
            };
            
            // Sample pitch contour (~20 points)
            const samplePitchContour = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length === 0) return [];
                const step = Math.max(1, Math.floor(voiced.length / 20));
                return voiced.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    hz: Math.round(p.pitch)
                }));
            };
            
            // Detect pitch artifacts (tracking errors)
            const detectPitchArtifacts = (pitchData) => {
                const artifacts = [];
                const voiced = pitchData.filter(p => p.pitch > 0);
                
                for (let i = 1; i < voiced.length; i++) {
                    const prev = voiced[i - 1];
                    const curr = voiced[i];
                    const jump = Math.abs(curr.pitch - prev.pitch);
                    
                    // Flag jumps > 150 Hz as potential artifacts
                    if (jump > 150) {
                        // Check if preceded by unvoiced section
                        const prevIdx = pitchData.findIndex(p => p.time === prev.time);
                        const currIdx = pitchData.findIndex(p => p.time === curr.time);
                        const gapSize = currIdx - prevIdx;
                        
                        if (gapSize > 5 || curr.pitch > 400) {
                            artifacts.push({
                                t: parseFloat(curr.time.toFixed(2)),
                                hz: Math.round(curr.pitch),
                                type: 'tracking_error',
                                reason: gapSize > 5 ? 'preceded_by_unvoiced' : 'extreme_jump'
                            });
                        }
                    }
                }
                
                return artifacts;
            };
            
            // Find pitch peaks and pattern
            const findPitchLandmarks = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length < 3) return { peaks: [], pattern: 'insufficient data' };
                
                const peaks = [];
                
                for (let i = 2; i < voiced.length - 2; i++) {
                    const prev2 = voiced[i-2].pitch;
                    const prev1 = voiced[i-1].pitch;
                    const curr = voiced[i].pitch;
                    const next1 = voiced[i+1].pitch;
                    const next2 = voiced[i+2].pitch;
                    
                    if (curr > prev1 && curr > next1 && curr > prev2 && curr > next2) {
                        if (peaks.length === 0 || Math.abs(curr - peaks[peaks.length-1].hz) > 20) {
                            peaks.push({ t: parseFloat(voiced[i].time.toFixed(2)), hz: Math.round(curr) });
                        }
                    }
                }
                
                const allPitches = voiced.map(p => p.pitch);
                const maxPitch = Math.max(...allPitches);
                const maxIdx = allPitches.indexOf(maxPitch);
                const mainPeak = { t: parseFloat(voiced[maxIdx].time.toFixed(2)), hz: Math.round(maxPitch) };
                
                const duration = voiced[voiced.length - 1].time;
                const peakPosition = mainPeak.t / duration;
                
                const startAvg = voiced.slice(0, Math.floor(voiced.length * 0.15)).reduce((a, b) => a + b.pitch, 0) / Math.floor(voiced.length * 0.15);
                const endAvg = voiced.slice(Math.floor(voiced.length * 0.85)).reduce((a, b) => a + b.pitch, 0) / (voiced.length - Math.floor(voiced.length * 0.85));
                
                let pattern;
                if (peakPosition < 0.3) {
                    pattern = endAvg < startAvg ? 'early-peak-falling' : 'early-peak';
                } else if (peakPosition > 0.7) {
                    pattern = 'late-peak';
                } else if (peakPosition > 0.4 && peakPosition < 0.6) {
                    pattern = endAvg < startAvg * 0.8 ? 'rising-falling' : 'mid-peak';
                } else if (endAvg > startAvg * 1.15) {
                    pattern = 'rising';
                } else if (endAvg < startAvg * 0.85) {
                    pattern = 'falling';
                } else {
                    pattern = 'relatively flat';
                }
                
                return { peaks: peaks.slice(0, 3), mainPeak, pattern };
            };
            
            // Intensity profile with gap detection
            const getIntensityProfile = (intensityData) => {
                if (!intensityData || intensityData.length === 0) return { peaks: [], hasGaps: false, samples: [] };
                
                const maxIntensity = Math.max(...intensityData.map(i => i.intensity));
                const meanIntensity = intensityData.reduce((a, b) => a + b.intensity, 0) / intensityData.length;
                const peakThreshold = maxIntensity * 0.5;
                
                const peaks = [];
                for (let i = 1; i < intensityData.length - 1; i++) {
                    if (intensityData[i].intensity > peakThreshold &&
                        intensityData[i].intensity > intensityData[i-1].intensity &&
                        intensityData[i].intensity > intensityData[i+1].intensity) {
                        if (peaks.length === 0 || intensityData[i].time - peaks[peaks.length-1].t > 0.08) {
                            peaks.push({
                                t: parseFloat(intensityData[i].time.toFixed(3)),
                                val: parseFloat((intensityData[i].intensity * 100).toFixed(1))
                            });
                        }
                    }
                }
                
                const gapThreshold = maxIntensity * 0.15;
                const gaps = [];
                let inGap = false;
                let gapStart = 0;
                
                for (let i = 0; i < intensityData.length; i++) {
                    if (intensityData[i].intensity < gapThreshold) {
                        if (!inGap) {
                            inGap = true;
                            gapStart = intensityData[i].time;
                        }
                    } else {
                        if (inGap) {
                            const gapEnd = intensityData[i].time;
                            if (gapEnd - gapStart > 0.05) {
                                gaps.push({
                                    start: parseFloat(gapStart.toFixed(2)),
                                    end: parseFloat(gapEnd.toFixed(2))
                                });
                            }
                            inGap = false;
                        }
                    }
                }
                
                const step = Math.max(1, Math.floor(intensityData.length / 20));
                const samples = intensityData.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    val: parseFloat((p.intensity * 100).toFixed(1))
                }));
                
                return { 
                    peaks: peaks.slice(0, 5), 
                    hasGaps: gaps.length > 0, 
                    gaps: gaps.slice(0, 3),
                    samples,
                    mean: parseFloat((meanIntensity * 100).toFixed(1))
                };
            };
            
            // Detect syllable boundaries using MFCC energy (c0) - more reliable than intensity
            const detectSyllableBoundaries = (mfccData, intensityData, duration, wordName) => {
                // Estimate expected syllables from word (rough heuristic: count vowel clusters)
                const vowels = (wordName || '').toLowerCase().match(/[aeiou]+/g) || [];
                const expectedSyllables = Math.max(1, vowels.length);
                
                // Try to detect boundaries from MFCC energy (c0)
                if (mfccData && mfccData.length > 10) {
                    // Get c0 (energy) values
                    const energyData = mfccData.map(f => {
                        const arr = f.coeffs || f.coefficients || f.c || [];
                        return {
                            time: f.time,
                            energy: arr[0] || 0
                        };
                    });
                    
                    // Smooth the energy contour
                    const smoothed = [];
                    const windowSize = 5;
                    for (let i = 0; i < energyData.length; i++) {
                        let sum = 0;
                        let count = 0;
                        for (let j = Math.max(0, i - windowSize); j < Math.min(energyData.length, i + windowSize + 1); j++) {
                            sum += energyData[j].energy;
                            count++;
                        }
                        smoothed.push({
                            time: energyData[i].time,
                            energy: sum / count
                        });
                    }
                    
                    // Find local minima in energy
                    const minima = [];
                    for (let i = 5; i < smoothed.length - 5; i++) {
                        const curr = smoothed[i].energy;
                        const before = smoothed.slice(i - 5, i).map(s => s.energy);
                        const after = smoothed.slice(i + 1, i + 6).map(s => s.energy);
                        
                        if (curr < Math.min(...before) && curr < Math.min(...after)) {
                            const time = smoothed[i].time;
                            // Avoid boundaries too close to edges or each other
                            if (time > 0.05 && time < duration - 0.05) {
                                if (minima.length === 0 || time - minima[minima.length - 1] > 0.08) {
                                    minima.push(time);
                                }
                            }
                        }
                    }
                    
                    // If we found reasonable boundaries, use them
                    if (minima.length > 0 && minima.length <= expectedSyllables + 1) {
                        const boundaries = [0, ...minima.map(t => parseFloat(t.toFixed(3))), duration];
                        return boundaries;
                    }
                }
                
                // Fallback: try intensity-based detection
                if (intensityData && intensityData.length > 0) {
                    const maxIntensity = Math.max(...intensityData.map(i => i.intensity));
                    const threshold = maxIntensity * 0.3;
                    
                    const boundaries = [0];
                    let inLow = false;
                    
                    for (let i = 1; i < intensityData.length - 1; i++) {
                        const curr = intensityData[i].intensity;
                        
                        if (curr < threshold && !inLow) {
                            inLow = true;
                        } else if (curr > threshold && inLow) {
                            const boundary = intensityData[i].time;
                            if (boundary - boundaries[boundaries.length - 1] > 0.08) {
                                boundaries.push(parseFloat(boundary.toFixed(3)));
                            }
                            inLow = false;
                        }
                    }
                    
                    boundaries.push(duration);
                    
                    // If we got reasonable boundaries, use them
                    if (boundaries.length - 1 >= expectedSyllables - 1) {
                        return boundaries;
                    }
                }
                
                // Final fallback: divide evenly based on expected syllables
                const boundaries = [0];
                const syllableDuration = duration / expectedSyllables;
                for (let i = 1; i < expectedSyllables; i++) {
                    boundaries.push(parseFloat((i * syllableDuration).toFixed(3)));
                }
                boundaries.push(duration);
                
                return boundaries;
            };
            
            // Get MFCC summary per syllable
            const getMFCCBySyllable = (mfccData, boundaries, prefix) => {
                if (!mfccData || mfccData.length === 0 || boundaries.length < 2) return [];
                
                const syllables = [];
                
                // Helper to get coefficients array from a frame
                const getCoeffs = (frame) => {
                    if (frame.coeffs && Array.isArray(frame.coeffs)) return frame.coeffs;
                    if (frame.coefficients && Array.isArray(frame.coefficients)) return frame.coefficients;
                    if (frame.c && Array.isArray(frame.c)) return frame.c;
                    return [];
                };
                
                for (let s = 0; s < boundaries.length - 1; s++) {
                    const start = boundaries[s];
                    const end = boundaries[s + 1];
                    
                    // Get frames within this syllable
                    const frames = mfccData.filter(f => f.time >= start && f.time < end);
                    if (frames.length === 0) continue;
                    
                    // Calculate mean for each coefficient
                    const firstCoeffs = getCoeffs(frames[0]);
                    const numCoeffs = Math.min(12, firstCoeffs.length);
                    
                    if (numCoeffs === 0) {
                        // If we can't find coefficients, skip this syllable
                        continue;
                    }
                    
                    const syllable = {
                        idx: s + 1,
                        tRange: [parseFloat(start.toFixed(2)), parseFloat(end.toFixed(2))],
                        frames: frames.length
                    };
                    
                    for (let c = 0; c < numCoeffs; c++) {
                        const vals = frames.map(f => {
                            const arr = getCoeffs(f);
                            // Don't use || 0 here as coefficient values can legitimately be 0
                            return arr.length > c ? arr[c] : 0;
                        });
                        const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                        syllable[`c${c}`] = parseFloat(mean.toFixed(1));
                    }
                    
                    syllables.push(syllable);
                }
                
                return syllables;
            };
            
            // Get data
            const nativeIntensity = features.nativeIntensity;
            const userIntensity = features.userIntensity;
            const nativeMFCCs = features.nativeMFCCs;
            const userMFCCs = features.userMFCCs;
            
            // Calculate durations
            const nativeDuration = parseFloat((nativePitch[nativePitch.length - 1]?.time || 0).toFixed(3));
            const userDuration = parseFloat((userPitch[userPitch.length - 1]?.time || 0).toFixed(3));
            const durationRatio = parseFloat((Math.min(nativeDuration, userDuration) / Math.max(nativeDuration, userDuration)).toFixed(2));
            
            // Get all analysis
            const nativePitchStats = getPitchStats(nativePitch);
            const userPitchStats = getPitchStats(userPitch);
            const nativeLandmarks = findPitchLandmarks(nativePitch);
            const userLandmarks = findPitchLandmarks(userPitch);
            const userArtifacts = detectPitchArtifacts(userPitch);
            const nativeIntProfile = getIntensityProfile(nativeIntensity);
            const userIntProfile = getIntensityProfile(userIntensity);
            
            // Detect syllable boundaries
            const nativeBoundaries = detectSyllableBoundaries(nativeMFCCs, nativeIntensity, nativeDuration, wordName);
            const userBoundaries = detectSyllableBoundaries(userMFCCs, userIntensity, userDuration, wordName);
            
            // Get per-syllable MFCC data
            const nativeSyllables = getMFCCBySyllable(nativeMFCCs, nativeBoundaries, 'native');
            const userSyllables = getMFCCBySyllable(userMFCCs, userBoundaries, 'user');
            
            // Pre-calculate comparisons
            const comparisons = {
                durationDiff: Math.round((userDuration - nativeDuration) * 1000),
                pitchMeanDiff: userPitchStats.mean - nativePitchStats.mean,
                peakTimeDiff: nativeLandmarks.mainPeak && userLandmarks.mainPeak 
                    ? parseFloat((userLandmarks.mainPeak.t - nativeLandmarks.mainPeak.t).toFixed(2))
                    : null,
                patternMatch: nativeLandmarks.pattern === userLandmarks.pattern,
                syllableCountMatch: nativeSyllables.length === userSyllables.length,
                nativeSyllables: nativeSyllables.length,
                userSyllables: userSyllables.length
            };
            
            // Build data object
            const data = {
                word: wordName,
                duration: {
                    native: nativeDuration,
                    user: userDuration,
                    ratio: durationRatio
                },
                pitch: {
                    native: { 
                        ...nativePitchStats, 
                        pattern: nativeLandmarks.pattern,
                        mainPeak: nativeLandmarks.mainPeak,
                        samples: samplePitchContour(nativePitch)
                    },
                    user: { 
                        ...userPitchStats, 
                        pattern: userLandmarks.pattern,
                        mainPeak: userLandmarks.mainPeak,
                        samples: samplePitchContour(userPitch),
                        artifacts: userArtifacts
                    }
                },
                intensity: {
                    native: nativeIntProfile,
                    user: userIntProfile
                },
                mfccBySyllable: {
                    native: nativeSyllables,
                    user: userSyllables
                },
                comparisons
            };
            
            const prompt = `You are a pronunciation coach for Cebuano language learners. Analyze this data and provide practical feedback suitable for a 10th grader (max 250 words).

## Target Word: "${wordName}"

## Analysis Data
\`\`\`json
${JSON.stringify(data, null, 2)}
\`\`\`

## How to Interpret

### Pitch
- **pattern**: Overall shape (rising-falling, late-peak, mid-peak, etc.)
- **mainPeak**: Where the highest pitch occurs (t = time in seconds, hz = frequency)
- **samples**: Pitch contour points to trace the melody
- **artifacts**: Tracking errors to IGNORE (e.g., 500Hz spikes after unvoiced sections are noise, not real speech)

### Intensity
- **peaks**: Stressed syllable locations (t = time, val = loudness 0-100)
- **gaps**: Silent boundaries between syllables
- **samples**: Loudness contour

### MFCCs by Syllable (KEY DIAGNOSTIC DATA)
Each syllable shows mean values for coefficients c0-c11:
- **c0**: Energy (loudness)
- **c1-c2**: Vowel quality (c1 = tongue height, c2 = tongue front/back position)
- **c3-c4**: Vowel shape refinement
- **c5+**: Consonant and transition details

Compare native vs user syllables:
- c2 too high = tongue too fronted (common for /a/, /o/, /u/)
- c2 too low = tongue too backed
- c1 differences = mouth opening issues

### Comparisons
- **durationDiff**: ms difference (positive = user slower)
- **syllableCountMatch**: Should be true if syllable count matches

## Common Issues
- Vowel reduction (schwa instead of full vowels)
- Flat pitch (Cebuano should be more musical)
- Wrong pitch pattern (ignore artifacts when assessing)
- Missing syllable boundaries

## Your Task
1. What's working well (1 sentence)
2. 2-3 specific syllable-level issues with practical fixes
3. One targeted practice exercise

Be specific about WHICH syllable has issues. Keep it encouraging and actionable.`;

            return prompt;
        }
        
        // FULL APPROACH: ~280K with all MFCC frames
        function generateAIPromptFull(results, wordName) {
            const features = results.features;
            
            // Pitch data
            const nativePitch = features.nativePitch;
            const userPitch = features.userPitch;
            
            // Get basic pitch stats
            const getPitchStats = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0).map(p => p.pitch);
                if (voiced.length === 0) return { mean: 0, min: 0, max: 0, std: 0 };
                const mean = voiced.reduce((a, b) => a + b, 0) / voiced.length;
                const std = Math.sqrt(voiced.reduce((sum, x) => sum + (x - mean) ** 2, 0) / voiced.length);
                return {
                    mean: Math.round(mean),
                    min: Math.round(Math.min(...voiced)),
                    max: Math.round(Math.max(...voiced)),
                    std: Math.round(std)
                };
            };
            
            // Sample pitch contour (~20 points)
            const samplePitchContour = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length === 0) return [];
                const step = Math.max(1, Math.floor(voiced.length / 20));
                return voiced.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    hz: Math.round(p.pitch)
                }));
            };
            
            // Detect pitch artifacts
            const detectPitchArtifacts = (pitchData) => {
                const artifacts = [];
                const voiced = pitchData.filter(p => p.pitch > 0);
                
                for (let i = 1; i < voiced.length; i++) {
                    const prev = voiced[i - 1];
                    const curr = voiced[i];
                    const jump = Math.abs(curr.pitch - prev.pitch);
                    
                    if (jump > 150) {
                        const prevIdx = pitchData.findIndex(p => p.time === prev.time);
                        const currIdx = pitchData.findIndex(p => p.time === curr.time);
                        const gapSize = currIdx - prevIdx;
                        
                        if (gapSize > 5 || curr.pitch > 400) {
                            artifacts.push({
                                t: parseFloat(curr.time.toFixed(2)),
                                hz: Math.round(curr.pitch),
                                type: 'tracking_error',
                                reason: gapSize > 5 ? 'preceded_by_unvoiced' : 'extreme_jump'
                            });
                        }
                    }
                }
                
                return artifacts;
            };
            
            // Find pitch pattern
            const findPitchLandmarks = (pitchData) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length < 3) return { pattern: 'insufficient data' };
                
                const allPitches = voiced.map(p => p.pitch);
                const maxPitch = Math.max(...allPitches);
                const maxIdx = allPitches.indexOf(maxPitch);
                const mainPeak = { t: parseFloat(voiced[maxIdx].time.toFixed(2)), hz: Math.round(maxPitch) };
                
                const duration = voiced[voiced.length - 1].time;
                const peakPosition = mainPeak.t / duration;
                
                const startAvg = voiced.slice(0, Math.floor(voiced.length * 0.15)).reduce((a, b) => a + b.pitch, 0) / Math.floor(voiced.length * 0.15);
                const endAvg = voiced.slice(Math.floor(voiced.length * 0.85)).reduce((a, b) => a + b.pitch, 0) / (voiced.length - Math.floor(voiced.length * 0.85));
                
                let pattern;
                if (peakPosition < 0.3) {
                    pattern = endAvg < startAvg ? 'early-peak-falling' : 'early-peak';
                } else if (peakPosition > 0.7) {
                    pattern = 'late-peak';
                } else if (peakPosition > 0.4 && peakPosition < 0.6) {
                    pattern = endAvg < startAvg * 0.8 ? 'rising-falling' : 'mid-peak';
                } else if (endAvg > startAvg * 1.15) {
                    pattern = 'rising';
                } else if (endAvg < startAvg * 0.85) {
                    pattern = 'falling';
                } else {
                    pattern = 'relatively flat';
                }
                
                return { mainPeak, pattern };
            };
            
            // Intensity profile
            const getIntensityProfile = (intensityData) => {
                if (!intensityData || intensityData.length === 0) return { peaks: [], samples: [] };
                
                const maxIntensity = Math.max(...intensityData.map(i => i.intensity));
                const meanIntensity = intensityData.reduce((a, b) => a + b.intensity, 0) / intensityData.length;
                const peakThreshold = maxIntensity * 0.5;
                
                const peaks = [];
                for (let i = 1; i < intensityData.length - 1; i++) {
                    if (intensityData[i].intensity > peakThreshold &&
                        intensityData[i].intensity > intensityData[i-1].intensity &&
                        intensityData[i].intensity > intensityData[i+1].intensity) {
                        if (peaks.length === 0 || intensityData[i].time - peaks[peaks.length-1].t > 0.08) {
                            peaks.push({
                                t: parseFloat(intensityData[i].time.toFixed(3)),
                                val: parseFloat((intensityData[i].intensity * 100).toFixed(1))
                            });
                        }
                    }
                }
                
                const gapThreshold = maxIntensity * 0.15;
                const gaps = [];
                let inGap = false;
                let gapStart = 0;
                
                for (let i = 0; i < intensityData.length; i++) {
                    if (intensityData[i].intensity < gapThreshold) {
                        if (!inGap) {
                            inGap = true;
                            gapStart = intensityData[i].time;
                        }
                    } else {
                        if (inGap) {
                            const gapEnd = intensityData[i].time;
                            if (gapEnd - gapStart > 0.05) {
                                gaps.push({
                                    start: parseFloat(gapStart.toFixed(2)),
                                    end: parseFloat(gapEnd.toFixed(2))
                                });
                            }
                            inGap = false;
                        }
                    }
                }
                
                const step = Math.max(1, Math.floor(intensityData.length / 20));
                const samples = intensityData.filter((_, i) => i % step === 0).map(p => ({
                    t: parseFloat(p.time.toFixed(2)),
                    val: parseFloat((p.intensity * 100).toFixed(1))
                }));
                
                return { 
                    peaks: peaks.slice(0, 5), 
                    hasGaps: gaps.length > 0, 
                    gaps: gaps.slice(0, 3),
                    samples,
                    mean: parseFloat((meanIntensity * 100).toFixed(1))
                };
            };
            
            // Get ALL MFCC frames (rounded to 1 decimal)
            const getAllMFCCFrames = (mfccData) => {
                if (!mfccData || mfccData.length === 0) return [];
                
                return mfccData.map(frame => {
                    const coeffArray = frame.coeffs || frame.coefficients || [];
                    return {
                        t: parseFloat(frame.time.toFixed(3)),
                        c: coeffArray.slice(0, 12).map(v => parseFloat(v.toFixed(1)))
                    };
                });
            };
            
            // Get data
            const nativeIntensity = features.nativeIntensity;
            const userIntensity = features.userIntensity;
            const nativeMFCCs = features.nativeMFCCs;
            const userMFCCs = features.userMFCCs;
            
            // Calculate durations
            const nativeDuration = parseFloat((nativePitch[nativePitch.length - 1]?.time || 0).toFixed(3));
            const userDuration = parseFloat((userPitch[userPitch.length - 1]?.time || 0).toFixed(3));
            const durationRatio = parseFloat((Math.min(nativeDuration, userDuration) / Math.max(nativeDuration, userDuration)).toFixed(2));
            
            // Get all analysis
            const nativePitchStats = getPitchStats(nativePitch);
            const userPitchStats = getPitchStats(userPitch);
            const nativeLandmarks = findPitchLandmarks(nativePitch);
            const userLandmarks = findPitchLandmarks(userPitch);
            const userArtifacts = detectPitchArtifacts(userPitch);
            const nativeIntProfile = getIntensityProfile(nativeIntensity);
            const userIntProfile = getIntensityProfile(userIntensity);
            
            // Get all MFCC frames
            const nativeMFCCFrames = getAllMFCCFrames(nativeMFCCs);
            const userMFCCFrames = getAllMFCCFrames(userMFCCs);
            
            // Build data object
            const data = {
                word: wordName,
                duration: {
                    native: nativeDuration,
                    user: userDuration,
                    ratio: durationRatio
                },
                pitch: {
                    native: { 
                        ...nativePitchStats, 
                        pattern: nativeLandmarks.pattern,
                        mainPeak: nativeLandmarks.mainPeak,
                        samples: samplePitchContour(nativePitch)
                    },
                    user: { 
                        ...userPitchStats, 
                        pattern: userLandmarks.pattern,
                        mainPeak: userLandmarks.mainPeak,
                        samples: samplePitchContour(userPitch),
                        artifacts: userArtifacts
                    }
                },
                intensity: {
                    native: nativeIntProfile,
                    user: userIntProfile
                },
                mfccFrames: {
                    native: {
                        numFrames: nativeMFCCFrames.length,
                        frames: nativeMFCCFrames
                    },
                    user: {
                        numFrames: userMFCCFrames.length,
                        frames: userMFCCFrames
                    }
                }
            };
            
            const prompt = `You are an expert pronunciation coach for Cebuano language learners. Analyze this COMPLETE frame-level data for detailed articulatory feedback.

## Target Word: "${wordName}"

## Analysis Data
\`\`\`json
${JSON.stringify(data, null, 2)}
\`\`\`

## Frame-Level MFCC Interpretation

Each frame in mfccFrames contains:
- **t**: Time in seconds
- **c**: Array of 12 coefficients [c0, c1, c2, ..., c11]

Coefficient meanings:
- **c0**: Frame energy
- **c1**: Spectral slope (tongue height indicator)
- **c2**: Spectral balance (tongue front/back - CRITICAL for vowels)
- **c3-c4**: Finer vowel shape
- **c5-c11**: Consonant articulation, transitions

## Analysis Approach

1. **Align by relative position**: Compare native frame N/total to user frame N/total
2. **Track trajectories**: Look for where coefficients change rapidly (transitions) vs stable (vowel nuclei)
3. **Compare slopes**: Native sharp transition = user should have sharp transition
4. **Flag artifacts**: Ignore pitch values marked as tracking_error

## Key Diagnostics

- **Vowel issues**: Compare c1 and c2 means during stable vowel regions
- **Transition sharpness**: Count frames for coefficient changes >5
- **Consonant clarity**: Check c5+ during stop closures and releases
- **Syllable boundaries**: Look for energy dips in c0

## Your Task

Provide DETAILED feedback (up to 400 words):
1. Overall assessment (2 sentences)
2. Frame-specific issues with exact time ranges
3. Articulatory explanations (tongue position, lip rounding, etc.)
4. 3-4 targeted practice exercises
5. Priority ranking of issues to fix

Be precise about frame numbers and coefficient values. This is for an advanced learner who wants detailed technical feedback.`;

            return prompt;
        }
        
        function generateAIPrompt(results) {
            const report = results.detailedReport;
            const features = results.features;
            
            // Get pitch contour data (sampled)
            const nativePitch = features.nativePitch;
            const userPitch = features.userPitch;
            
            const samplePitchContour = (pitchData, numSamples = 20) => {
                const voiced = pitchData.filter(p => p.pitch > 0);
                if (voiced.length === 0) return [];
                const step = Math.max(1, Math.floor(voiced.length / numSamples));
                return voiced.filter((_, i) => i % step === 0).map(p => ({
                    time: p.time.toFixed(3),
                    pitch: p.pitch.toFixed(1)
                }));
            };
            
            const nativePitchContour = samplePitchContour(nativePitch);
            const userPitchContour = samplePitchContour(userPitch);
            
            // Get pitch statistics
            const nativePitches = nativePitch.filter(p => p.pitch > 0).map(p => p.pitch);
            const userPitches = userPitch.filter(p => p.pitch > 0).map(p => p.pitch);
            
            const calcStats = (arr) => {
                if (arr.length === 0) return { mean: 0, min: 0, max: 0, std: 0 };
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = Math.sqrt(arr.reduce((sum, x) => sum + (x - mean) ** 2, 0) / arr.length);
                return {
                    mean: mean.toFixed(1),
                    min: Math.min(...arr).toFixed(1),
                    max: Math.max(...arr).toFixed(1),
                    std: std.toFixed(1)
                };
            };
            
            const nativePitchStats = calcStats(nativePitches);
            const userPitchStats = calcStats(userPitches);
            
            // Get MFCC data (averaged per coefficient)
            const nativeMFCCs = features.nativeMFCCs;
            const userMFCCs = features.userMFCCs;
            
            const calcMFCCAverages = (mfccData) => {
                if (!mfccData || mfccData.length === 0) return [];
                const numCoeffs = mfccData[0].coeffs.length;
                const avgs = [];
                for (let c = 0; c < numCoeffs; c++) {
                    const vals = mfccData.map(f => f.coeffs[c]);
                    const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                    const std = Math.sqrt(vals.reduce((sum, x) => sum + (x - mean) ** 2, 0) / vals.length);
                    avgs.push({ coeff: c, mean: mean.toFixed(2), std: std.toFixed(2) });
                }
                return avgs;
            };
            
            const nativeMFCCAvgs = calcMFCCAverages(nativeMFCCs);
            const userMFCCAvgs = calcMFCCAverages(userMFCCs);
            
            // Calculate MFCC differences
            const mfccDiffs = nativeMFCCAvgs.map((n, i) => ({
                coeff: i,
                diff: (parseFloat(n.mean) - parseFloat(userMFCCAvgs[i]?.mean || 0)).toFixed(2)
            }));
            
            // Get intensity/stress patterns with more detail
            const nativeIntensity = features.nativeIntensity;
            const userIntensity = features.userIntensity;
            
            const sampleIntensity = (intensityData, numSamples = 15) => {
                if (!intensityData || intensityData.length === 0) return [];
                const step = Math.max(1, Math.floor(intensityData.length / numSamples));
                return intensityData.filter((_, i) => i % step === 0).map(p => ({
                    time: p.time.toFixed(3),
                    intensity: p.intensity.toFixed(4)
                }));
            };
            
            const nativeIntensityProfile = sampleIntensity(nativeIntensity);
            const userIntensityProfile = sampleIntensity(userIntensity);
            
            // Find stress peaks (top 3 intensity moments)
            const findPeaks = (intensity, numPeaks = 3) => {
                if (!intensity || intensity.length === 0) return [];
                const sorted = [...intensity].sort((a, b) => b.intensity - a.intensity);
                return sorted.slice(0, numPeaks).map(p => ({
                    time: p.time.toFixed(3),
                    intensity: p.intensity.toFixed(4)
                }));
            };
            
            const nativePeaks = findPeaks(nativeIntensity);
            const userPeaks = findPeaks(userIntensity);
            
            // Get target word from the page
            const targetWord = document.querySelector('.word-display h2')?.textContent || 'Unknown';
            
            // Build detailed data object
            const analysisData = {
                target: targetWord,
                scores: {
                    overall: results.score,
                    pitch: results.breakdown.pitch,
                    mfcc: results.breakdown.mfcc,
                    spectral: results.breakdown.spectral,
                    duration: results.breakdown.duration,
                    stress: results.breakdown.stress,
                    quality: results.breakdown.quality
                },
                duration: {
                    native: parseFloat(report.metadata.nativeDuration.toFixed(3)),
                    user: parseFloat(report.metadata.userDuration.toFixed(3)),
                    ratio: parseFloat((Math.min(report.metadata.nativeDuration, report.metadata.userDuration) / 
                           Math.max(report.metadata.nativeDuration, report.metadata.userDuration)).toFixed(3))
                },
                pitch: {
                    native: {
                        stats: nativePitchStats,
                        contour: nativePitchContour
                    },
                    user: {
                        stats: userPitchStats,
                        contour: userPitchContour
                    }
                },
                mfcc: {
                    native: nativeMFCCAvgs,
                    user: userMFCCAvgs,
                    differences: mfccDiffs
                },
                intensity: {
                    native: {
                        profile: nativeIntensityProfile,
                        peaks: nativePeaks
                    },
                    user: {
                        profile: userIntensityProfile,
                        peaks: userPeaks
                    }
                },
                comparisonDetails: {
                    pitch: report.pitch?.comparison || {},
                    spectral: report.spectral || {},
                    quality: report.quality || {},
                    mfcc: report.mfcc?.comparison || {}
                }
            };
            
            const prompt = `You are an expert ESL pronunciation coach specializing in teaching English to Cebuano speakers from the Philippines. Analyze this pronunciation data and provide detailed, actionable feedback.

## Context
- Target word/phrase: "${targetWord}"
- The learner is a native Cebuano speaker learning English
- Common Cebuano-English challenges: syllable-timed vs stress-timed rhythm, vowel quality (especially /√¶/, /…õ/, /…™/), final consonant clusters, th-sounds

## Detailed Analysis Data

\`\`\`json
${JSON.stringify(analysisData, null, 2)}
\`\`\`

## How to Interpret the Data

**Scores**: 0-100 scale. Below 70 needs work, 70-85 is good, above 85 is excellent.

**Pitch contour**: Time-series of fundamental frequency. Look for:
- Overall pitch level differences (higher/lower)
- Contour shape (rising, falling, flat)
- Variability (std) - English has more pitch variation than Cebuano

**MFCCs**: Mel-frequency cepstral coefficients capture vowel/consonant quality.
- c0 = energy
- c1-c4 = vowel quality (most important)
- c5-c12 = finer spectral details
- Large differences indicate different sound quality

**Intensity profile**: Energy over time. Peaks indicate stressed syllables.
- Compare timing of peaks to see stress pattern alignment
- English content words have clear stress; Cebuano is more even

## Task
Provide detailed feedback including:

1. **Overall Assessment** (2-3 sentences)

2. **Detailed Score Analysis**: Explain what each score means for this specific attempt

3. **Pitch Pattern Analysis**: 
   - Compare the contours specifically
   - Note any intonation issues (questioning tone, flat, etc.)

4. **Vowel/Consonant Quality** (from MFCCs):
   - Which coefficients show biggest differences?
   - What does this suggest about articulation?

5. **Rhythm and Stress**:
   - Analyze the stress peak timing
   - Is the learner using English stress-timing or Cebuano syllable-timing?

6. **Specific Articulatory Recommendations**:
   - Tongue position
   - Lip rounding
   - Jaw opening
   - Timing adjustments

7. **Practice Exercises**: Concrete drills for the identified issues

8. **Cebuano-Specific Insights**: L1 transfer patterns you detect

Be encouraging but specific. Use IPA symbols when helpful.`;

            return prompt;
        }
        
        document.getElementById('toggleDebug').addEventListener('click', () => {
            document.getElementById('debugPanel').classList.toggle('show');
        });
        
        document.querySelectorAll('.viz-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.viz-tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                currentViz = e.target.dataset.viz;
                debugLog.log(`Switching to ${currentViz} visualization`);
                
                updateScaleControlsVisibility();
                updateVisualization();
            });
        });
        
        document.querySelectorAll('.scale-toggle button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const type = e.target.dataset.type;
                const scale = e.target.dataset.scale;
                
                e.target.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                if (type === 'amplitude') {
                    scalePreferences.amplitude = scale;
                } else if (type === 'waveform-mode') {
                    scalePreferences.waveformMode = scale;
                } else if (type === 'display-mode') {
                    scalePreferences.displayMode = scale;
                } else if (type === 'spectrogram-mag') {
                    scalePreferences.spectrogramMag = scale;
                } else if (type === 'spectrogram-freq') {
                    scalePreferences.spectrogramFreq = scale;
                    // Show/hide mel bins control
                    const melBinsGroup = document.getElementById('melBinsGroup');
                    if (scale === 'mel') {
                        melBinsGroup.style.display = 'flex';
                    } else {
                        melBinsGroup.style.display = 'none';
                    }
                } else if (type === 'mel-bins') {
                    scalePreferences.melBins = parseInt(scale);
                } else if (type === 'waveform-downsample') {
                    scalePreferences.waveformDownsample = scale;
                } else if (type === 'waveform-norm') {
                    scalePreferences.waveformNormalization = scale;
                }
                
                debugLog.log(`Scale changed: ${type} = ${scale}`);
                updateVisualization();
            });
        });
        
        // Filter mode and value handlers
        function updateFilterControls() {
            const mode = scalePreferences.filterMode;
            const slider = document.getElementById('filterValueSlider');
            const input = document.getElementById('filterValueInput');
            const label = document.getElementById('filterValueLabel');
            const unit = document.getElementById('filterValueUnit');
            
            switch (mode) {
                case 'global':
                    label.textContent = 'Peak %:';
                    slider.min = 0;
                    slider.max = 100;
                    slider.step = 1;
                    input.min = 0;
                    input.max = 100;
                    input.step = 1;
                    unit.textContent = '%';
                    break;
                case 'percentile':
                    label.textContent = 'Show Top:';
                    slider.min = 1;
                    slider.max = 100;
                    slider.step = 1;
                    input.min = 1;
                    input.max = 100;
                    input.step = 1;
                    unit.textContent = '%';
                    if (scalePreferences.filterValue === 0) {
                        scalePreferences.filterValue = 100;
                        slider.value = 100;
                        input.value = 100;
                    }
                    break;
                case 'perbin':
                    label.textContent = 'Bin Peak %:';
                    slider.min = 0;
                    slider.max = 100;
                    slider.step = 1;
                    input.min = 0;
                    input.max = 100;
                    input.step = 1;
                    unit.textContent = '%';
                    break;
                case 'db':
                    label.textContent = 'dB Floor:';
                    slider.min = -80;
                    slider.max = 0;
                    slider.step = 1;
                    input.min = -80;
                    input.max = 0;
                    input.step = 1;
                    unit.textContent = 'dB';
                    if (scalePreferences.filterValue >= 0) {
                        scalePreferences.filterValue = -60;
                        slider.value = -60;
                        input.value = -60;
                    }
                    break;
                case 'statistical':
                    label.textContent = 'Std Devs:';
                    slider.min = 0;
                    slider.max = 5;
                    slider.step = 0.1;
                    input.min = 0;
                    input.max = 5;
                    input.step = 0.1;
                    unit.textContent = 'œÉ';
                    if (scalePreferences.filterValue > 5 || scalePreferences.filterValue < 0) {
                        scalePreferences.filterValue = 1;
                        slider.value = 1;
                        input.value = 1;
                    }
                    break;
            }
        }
        
        document.getElementById('filterModeSelect').addEventListener('change', (e) => {
            scalePreferences.filterMode = e.target.value;
            updateFilterControls();
            debugLog.log(`Filter mode: ${e.target.value}`);
            updateVisualization();
        });
        
        document.getElementById('filterValueSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('filterValueInput').value = value;
            scalePreferences.filterValue = value;
            debugLog.log(`Filter value: ${value}`);
            updateVisualization();
        });
        
        document.getElementById('filterValueInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            const slider = document.getElementById('filterValueSlider');
            if (isNaN(value)) value = parseFloat(slider.min);
            value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
            e.target.value = value;
            slider.value = value;
            scalePreferences.filterValue = value;
            debugLog.log(`Filter value: ${value}`);
            updateVisualization();
        });
        
        // Zoom X handlers
        document.getElementById('zoomXSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('zoomXInput').value = value;
            scalePreferences.zoomX = value;
            debugLog.log(`Zoom X: ${value}√ó`);
            updateVisualization();
        });
        
        document.getElementById('zoomXInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            if (isNaN(value)) value = 1;
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('zoomXSlider').value = value;
            scalePreferences.zoomX = value;
            debugLog.log(`Zoom X: ${value}√ó`);
            updateVisualization();
        });
        
        // Zoom Y handlers
        document.getElementById('zoomYSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('zoomYInput').value = value;
            scalePreferences.zoomY = value;
            debugLog.log(`Zoom Y: ${value}√ó`);
            updateVisualization();
        });
        
        document.getElementById('zoomYInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            if (isNaN(value)) value = 1;
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('zoomYSlider').value = value;
            scalePreferences.zoomY = value;
            debugLog.log(`Zoom Y: ${value}√ó`);
            updateVisualization();
        });
        
        // FFT size handlers
        document.getElementById('fftSizeSlider').addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            const fftSize = fftSizeOptions[index];
            document.getElementById('fftSizeSelect').value = fftSize;
            scalePreferences.fftSize = fftSize;
            // Clear spectrum cache when FFT size changes
            spectrumCache.nativeSpectrum = null;
            spectrumCache.userSpectrum = null;
            debugLog.log(`FFT size: ${fftSize}`);
            updateVisualization();
        });
        
        document.getElementById('fftSizeSelect').addEventListener('change', (e) => {
            const fftSize = parseInt(e.target.value);
            const index = fftSizeOptions.indexOf(fftSize);
            document.getElementById('fftSizeSlider').value = index;
            scalePreferences.fftSize = fftSize;
            // Clear spectrum cache when FFT size changes
            spectrumCache.nativeSpectrum = null;
            spectrumCache.userSpectrum = null;
            debugLog.log(`FFT size: ${fftSize}`);
            updateVisualization();
        });
        
        // Hop size handler
        document.getElementById('hopSizeSelect').addEventListener('change', (e) => {
            scalePreferences.hopSize = e.target.value;
            debugLog.log(`Hop size: ${e.target.value}`);
            updateVisualization();
        });
        
        // ===== WAVEFORM CONTROL EVENT LISTENERS =====
        
        // Waveform filter mode
        document.getElementById('waveformFilterModeSelect').addEventListener('change', (e) => {
            scalePreferences.waveformFilterMode = e.target.value;
            updateScaleControlsVisibility();
            updateWaveformFilterControls();
            updateVisualization();
        });
        
        function updateWaveformFilterControls() {
            const mode = scalePreferences.waveformFilterMode;
            const slider = document.getElementById('waveformFilterValueSlider');
            const input = document.getElementById('waveformFilterValueInput');
            const label = document.getElementById('waveformFilterValueLabel');
            
            switch (mode) {
                case 'threshold':
                    slider.min = 0; slider.max = 0.5; slider.step = 0.001;
                    input.min = 0; input.max = 0.5; input.step = 0.001;
                    slider.value = scalePreferences.waveformThreshold;
                    input.value = scalePreferences.waveformThreshold;
                    label.textContent = 'Threshold:';
                    break;
                case 'noisegate':
                    slider.min = 0; slider.max = 0.5; slider.step = 0.001;
                    input.min = 0; input.max = 0.5; input.step = 0.001;
                    slider.value = scalePreferences.waveformThreshold;
                    input.value = scalePreferences.waveformThreshold;
                    label.textContent = 'Gate:';
                    break;
                case 'percentile':
                    slider.min = 0; slider.max = 100; slider.step = 1;
                    input.min = 0; input.max = 100; input.step = 1;
                    slider.value = scalePreferences.waveformPercentile;
                    input.value = scalePreferences.waveformPercentile;
                    label.textContent = 'Percentile:';
                    break;
                case 'rms':
                    slider.min = 16; slider.max = 512; slider.step = 16;
                    input.min = 16; input.max = 512; input.step = 16;
                    slider.value = scalePreferences.waveformRmsWindow;
                    input.value = scalePreferences.waveformRmsWindow;
                    label.textContent = 'Window:';
                    break;
            }
        }
        
        // Waveform filter value slider
        document.getElementById('waveformFilterValueSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('waveformFilterValueInput').value = value;
            const mode = scalePreferences.waveformFilterMode;
            if (mode === 'threshold' || mode === 'noisegate') {
                scalePreferences.waveformThreshold = value;
            } else if (mode === 'percentile') {
                scalePreferences.waveformPercentile = value;
            } else if (mode === 'rms') {
                scalePreferences.waveformRmsWindow = value;
            }
            updateVisualization();
        });
        
        // Waveform filter value input
        document.getElementById('waveformFilterValueInput').addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('waveformFilterValueSlider').value = value;
            const mode = scalePreferences.waveformFilterMode;
            if (mode === 'threshold' || mode === 'noisegate') {
                scalePreferences.waveformThreshold = value;
            } else if (mode === 'percentile') {
                scalePreferences.waveformPercentile = value;
            } else if (mode === 'rms') {
                scalePreferences.waveformRmsWindow = value;
            }
            updateVisualization();
        });
        
        // Waveform Zoom X
        document.getElementById('waveformZoomXSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('waveformZoomXInput').value = value;
            scalePreferences.waveformZoomX = value;
            updateVisualization();
        });
        
        document.getElementById('waveformZoomXInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('waveformZoomXSlider').value = value;
            scalePreferences.waveformZoomX = value;
            updateVisualization();
        });
        
        // Waveform Zoom Y
        document.getElementById('waveformZoomYSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('waveformZoomYInput').value = value;
            scalePreferences.waveformZoomY = value;
            updateVisualization();
        });
        
        document.getElementById('waveformZoomYInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('waveformZoomYSlider').value = value;
            scalePreferences.waveformZoomY = value;
            updateVisualization();
        });
        
        // Waveform time crop
        document.getElementById('waveformTimeStartInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(0, Math.min(scalePreferences.waveformTimeEnd - 0.01, value));
            e.target.value = value;
            scalePreferences.waveformTimeStart = value;
            updateVisualization();
        });
        
        document.getElementById('waveformTimeEndInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(scalePreferences.waveformTimeStart + 0.01, Math.min(1, value));
            e.target.value = value;
            scalePreferences.waveformTimeEnd = value;
            updateVisualization();
        });
        
        // ===== MFCC CONTROL EVENT LISTENERS =====
        
        // MFCC number of mel filters
        document.getElementById('mfccNumFiltersSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('mfccNumFiltersInput').value = value;
            scalePreferences.mfccNumFilters = value;
            // Note: This requires re-analysis to take effect
        });
        
        document.getElementById('mfccNumFiltersInput').addEventListener('change', (e) => {
            let value = parseInt(e.target.value);
            value = Math.max(20, Math.min(128, value));
            e.target.value = value;
            document.getElementById('mfccNumFiltersSlider').value = value;
            scalePreferences.mfccNumFilters = value;
            // Note: This requires re-analysis to take effect
        });
        
        // MFCC coefficient range
        document.getElementById('mfccCoeffStartInput').addEventListener('change', (e) => {
            let value = parseInt(e.target.value);
            value = Math.max(0, Math.min(scalePreferences.mfccCoeffEnd - 1, value));
            e.target.value = value;
            scalePreferences.mfccCoeffStart = value;
            updateVisualization();
        });
        
        document.getElementById('mfccCoeffEndInput').addEventListener('change', (e) => {
            let value = parseInt(e.target.value);
            value = Math.max(scalePreferences.mfccCoeffStart + 1, Math.min(12, value));
            e.target.value = value;
            scalePreferences.mfccCoeffEnd = value;
            updateVisualization();
        });
        
        // MFCC delta checkboxes
        document.getElementById('mfccDeltaCheck').addEventListener('change', (e) => {
            scalePreferences.mfccShowDelta = e.target.checked;
            updateVisualization();
        });
        
        document.getElementById('mfccDeltaDeltaCheck').addEventListener('change', (e) => {
            scalePreferences.mfccShowDeltaDelta = e.target.checked;
            updateVisualization();
        });
        
        // MFCC lifter
        document.getElementById('mfccLifterSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('mfccLifterInput').value = value;
            scalePreferences.mfccLifter = value;
            updateVisualization();
        });
        
        document.getElementById('mfccLifterInput').addEventListener('change', (e) => {
            let value = parseInt(e.target.value);
            value = Math.max(0, Math.min(22, value));
            e.target.value = value;
            document.getElementById('mfccLifterSlider').value = value;
            scalePreferences.mfccLifter = value;
            updateVisualization();
        });
        
        // MFCC filter mode
        document.getElementById('mfccFilterModeSelect').addEventListener('change', (e) => {
            scalePreferences.mfccFilterMode = e.target.value;
            updateScaleControlsVisibility();
            updateMfccFilterControls();
            updateVisualization();
        });
        
        function updateMfccFilterControls() {
            const mode = scalePreferences.mfccFilterMode;
            const slider = document.getElementById('mfccFilterValueSlider');
            const input = document.getElementById('mfccFilterValueInput');
            const label = document.getElementById('mfccFilterValueLabel');
            
            switch (mode) {
                case 'percentile':
                    slider.min = 0; slider.max = 100; slider.step = 1;
                    input.min = 0; input.max = 100; input.step = 1;
                    label.textContent = 'Percentile:';
                    break;
                case 'statistical':
                    slider.min = 0; slider.max = 5; slider.step = 0.1;
                    input.min = 0; input.max = 5; input.step = 0.1;
                    label.textContent = 'œÉ:';
                    break;
            }
            slider.value = scalePreferences.mfccFilterValue;
            input.value = scalePreferences.mfccFilterValue;
        }
        
        // MFCC filter value
        document.getElementById('mfccFilterValueSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('mfccFilterValueInput').value = value;
            scalePreferences.mfccFilterValue = value;
            updateVisualization();
        });
        
        document.getElementById('mfccFilterValueInput').addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('mfccFilterValueSlider').value = value;
            scalePreferences.mfccFilterValue = value;
            updateVisualization();
        });
        
        // MFCC per-bin normalization
        document.getElementById('mfccPerBinNormCheck').addEventListener('change', (e) => {
            scalePreferences.mfccPerBinNorm = e.target.checked;
            updateVisualization();
        });
        
        // MFCC Zoom X
        document.getElementById('mfccZoomXSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('mfccZoomXInput').value = value;
            scalePreferences.mfccZoomX = value;
            updateVisualization();
        });
        
        document.getElementById('mfccZoomXInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('mfccZoomXSlider').value = value;
            scalePreferences.mfccZoomX = value;
            updateVisualization();
        });
        
        // MFCC Zoom Y
        document.getElementById('mfccZoomYSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('mfccZoomYInput').value = value;
            scalePreferences.mfccZoomY = value;
            updateVisualization();
        });
        
        document.getElementById('mfccZoomYInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(1, Math.min(10, value));
            e.target.value = value;
            document.getElementById('mfccZoomYSlider').value = value;
            scalePreferences.mfccZoomY = value;
            updateVisualization();
        });
        
        // MFCC colormap
        document.getElementById('mfccColormapSelect').addEventListener('change', (e) => {
            scalePreferences.mfccColormap = e.target.value;
            updateVisualization();
        });
        
        // MFCC symmetric
        document.getElementById('mfccSymmetricCheck').addEventListener('change', (e) => {
            scalePreferences.mfccSymmetric = e.target.checked;
            updateVisualization();
        });
        
        // ===== PITCH CONTROL EVENT LISTENERS =====
        
        // Pitch confidence threshold
        document.getElementById('pitchConfidenceSlider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('pitchConfidenceInput').value = value;
            scalePreferences.pitchConfidenceThreshold = value;
            updateVisualization();
        });
        
        document.getElementById('pitchConfidenceInput').addEventListener('change', (e) => {
            let value = parseFloat(e.target.value);
            value = Math.max(0, Math.min(0.8, value));
            e.target.value = value;
            document.getElementById('pitchConfidenceSlider').value = value;
            scalePreferences.pitchConfidenceThreshold = value;
            updateVisualization();
        });
        
        // Pitch smoothing mode
        document.getElementById('pitchSmoothingSelect').addEventListener('change', (e) => {
            scalePreferences.pitchSmoothingMode = e.target.value;
            updateScaleControlsVisibility();
            updateVisualization();
        });
        
        // Pitch smoothing window
        document.getElementById('pitchSmoothingWindowSlider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('pitchSmoothingWindowInput').value = value;
            scalePreferences.pitchSmoothingWindow = value;
            updateVisualization();
        });
        
        document.getElementById('pitchSmoothingWindowInput').addEventListener('change', (e) => {
            let value = parseInt(e.target.value);
            // Ensure odd number
            if (value % 2 === 0) value = value + 1;
            value = Math.max(3, Math.min(15, value));
            e.target.value = value;
            document.getElementById('pitchSmoothingWindowSlider').value = value;
            scalePreferences.pitchSmoothingWindow = value;
            updateVisualization();
        });
        
        // Pitch scale
        document.getElementById('pitchScaleSelect').addEventListener('change', (e) => {
            scalePreferences.pitchScale = e.target.value;
            updateVisualization();
        });
        
        // Pitch normalize
        document.getElementById('pitchNormalizeSelect').addEventListener('change', (e) => {
            scalePreferences.pitchNormalize = e.target.value;
            updateVisualization();
        });
        
        // Pitch show confidence
        document.getElementById('pitchShowConfidenceCheck').addEventListener('change', (e) => {
            scalePreferences.pitchShowConfidence = e.target.checked;
            updateVisualization();
        });
        
        // Pitch show unvoiced
        document.getElementById('pitchShowUnvoicedCheck').addEventListener('change', (e) => {
            scalePreferences.pitchShowUnvoiced = e.target.checked;
            updateVisualization();
        });
        
        // Pitch Y range
        document.getElementById('pitchYMinInput').addEventListener('change', (e) => {
            scalePreferences.pitchYMin = parseInt(e.target.value) || 0;
            updateVisualization();
        });
        
        document.getElementById('pitchYMaxInput').addEventListener('change', (e) => {
            scalePreferences.pitchYMax = parseInt(e.target.value) || 0;
            updateVisualization();
        });
        
        document.getElementById('filterToggle').addEventListener('change', (e) => {
            useFilter = e.target.checked;
            debugLog.log(`Speech filter: ${useFilter ? 'enabled' : 'disabled'}`, 'info');
        });
        
        document.getElementById('dtwToggle').addEventListener('change', (e) => {
            useDTW = e.target.checked;
            debugLog.log(`DTW: ${useDTW ? 'enabled' : 'disabled'}`, 'info');
        });
        
        document.getElementById('exportAnalysis').addEventListener('click', () => {
            if (!detailedAnalysis) {
                alert('No analysis data available');
                return;
            }
            
            const json = JSON.stringify(detailedAnalysis, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `pronunciation-analysis-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            debugLog.log('Analysis exported', 'success');
        });
        
        document.getElementById('copyAnalysis').addEventListener('click', () => {
            if (!detailedAnalysis) return;
            
            const text = JSON.stringify(detailedAnalysis, null, 2);
            navigator.clipboard.writeText(text).then(() => {
                debugLog.log('Analysis copied to clipboard', 'success');
                alert('Detailed analysis copied to clipboard!');
            }).catch(err => {
                debugLog.log('Failed to copy: ' + err.message, 'error');
            });
        });
        
        function updateScaleControlsVisibility() {
            const scaleControls = document.getElementById('scaleControls');
            const amplitudeGroup = document.getElementById('amplitudeScaleGroup');
            const waveformModeGroup = document.getElementById('waveformModeGroup');
            const displayModeGroup = document.getElementById('displayModeGroup');
            const spectrogramMagGroup = document.getElementById('spectrogramMagScaleGroup');
            const spectrogramFreqGroup = document.getElementById('spectrogramFreqScaleGroup');
            const melBinsGroup = document.getElementById('melBinsGroup');
            const peakFilterGroup = document.getElementById('peakFilterGroup');
            const filterValueGroup = document.getElementById('filterValueGroup');
            const zoomXGroup = document.getElementById('zoomXGroup');
            const zoomYGroup = document.getElementById('zoomYGroup');
            const fftSizeGroup = document.getElementById('fftSizeGroup');
            const hopSizeGroup = document.getElementById('hopSizeGroup');
            
            // Waveform-specific controls
            const waveformFilterModeGroup = document.getElementById('waveformFilterModeGroup');
            const waveformFilterValueGroup = document.getElementById('waveformFilterValueGroup');
            const waveformZoomXGroup = document.getElementById('waveformZoomXGroup');
            const waveformZoomYGroup = document.getElementById('waveformZoomYGroup');
            const waveformTimeCropGroup = document.getElementById('waveformTimeCropGroup');
            const waveformDownsampleGroup = document.getElementById('waveformDownsampleGroup');
            const waveformNormGroup = document.getElementById('waveformNormGroup');
            
            // MFCC-specific controls
            const mfccNumFiltersGroup = document.getElementById('mfccNumFiltersGroup');
            const mfccCoeffGroup = document.getElementById('mfccCoeffGroup');
            const mfccDeltaGroup = document.getElementById('mfccDeltaGroup');
            const mfccLifterGroup = document.getElementById('mfccLifterGroup');
            const mfccFilterModeGroup = document.getElementById('mfccFilterModeGroup');
            const mfccFilterValueGroup = document.getElementById('mfccFilterValueGroup');
            const mfccPerBinNormGroup = document.getElementById('mfccPerBinNormGroup');
            const mfccZoomXGroup = document.getElementById('mfccZoomXGroup');
            const mfccZoomYGroup = document.getElementById('mfccZoomYGroup');
            const mfccColormapGroup = document.getElementById('mfccColormapGroup');
            const mfccSymmetricGroup = document.getElementById('mfccSymmetricGroup');
            
            // Pitch-specific controls
            const pitchConfidenceGroup = document.getElementById('pitchConfidenceGroup');
            const pitchSmoothingGroup = document.getElementById('pitchSmoothingGroup');
            const pitchSmoothingWindowGroup = document.getElementById('pitchSmoothingWindowGroup');
            const pitchScaleGroup = document.getElementById('pitchScaleGroup');
            const pitchNormalizeGroup = document.getElementById('pitchNormalizeGroup');
            const pitchShowConfidenceGroup = document.getElementById('pitchShowConfidenceGroup');
            const pitchShowUnvoicedGroup = document.getElementById('pitchShowUnvoicedGroup');
            const pitchYRangeGroup = document.getElementById('pitchYRangeGroup');
            
            // Hide all controls first
            scaleControls.style.display = 'none';
            amplitudeGroup.style.display = 'none';
            waveformModeGroup.style.display = 'none';
            displayModeGroup.style.display = 'none';
            spectrogramMagGroup.style.display = 'none';
            spectrogramFreqGroup.style.display = 'none';
            melBinsGroup.style.display = 'none';
            peakFilterGroup.style.display = 'none';
            filterValueGroup.style.display = 'none';
            zoomXGroup.style.display = 'none';
            zoomYGroup.style.display = 'none';
            fftSizeGroup.style.display = 'none';
            hopSizeGroup.style.display = 'none';
            
            // Hide waveform controls
            waveformFilterModeGroup.style.display = 'none';
            waveformFilterValueGroup.style.display = 'none';
            waveformZoomXGroup.style.display = 'none';
            waveformZoomYGroup.style.display = 'none';
            waveformTimeCropGroup.style.display = 'none';
            waveformDownsampleGroup.style.display = 'none';
            waveformNormGroup.style.display = 'none';
            
            // Hide MFCC controls
            mfccNumFiltersGroup.style.display = 'none';
            mfccCoeffGroup.style.display = 'none';
            mfccDeltaGroup.style.display = 'none';
            mfccLifterGroup.style.display = 'none';
            mfccFilterModeGroup.style.display = 'none';
            mfccFilterValueGroup.style.display = 'none';
            mfccPerBinNormGroup.style.display = 'none';
            mfccZoomXGroup.style.display = 'none';
            mfccZoomYGroup.style.display = 'none';
            mfccColormapGroup.style.display = 'none';
            mfccSymmetricGroup.style.display = 'none';
            
            // Hide Pitch controls
            pitchConfidenceGroup.style.display = 'none';
            pitchSmoothingGroup.style.display = 'none';
            pitchSmoothingWindowGroup.style.display = 'none';
            pitchScaleGroup.style.display = 'none';
            pitchNormalizeGroup.style.display = 'none';
            pitchShowConfidenceGroup.style.display = 'none';
            pitchShowUnvoicedGroup.style.display = 'none';
            pitchYRangeGroup.style.display = 'none';
            
            if (currentViz === 'waveform') {
                scaleControls.style.display = 'flex';
                amplitudeGroup.style.display = 'flex';
                waveformModeGroup.style.display = 'flex';
                displayModeGroup.style.display = 'flex';
                waveformFilterModeGroup.style.display = 'flex';
                if (scalePreferences.waveformFilterMode !== 'none') {
                    waveformFilterValueGroup.style.display = 'flex';
                }
                waveformZoomXGroup.style.display = 'flex';
                waveformZoomYGroup.style.display = 'flex';
                waveformTimeCropGroup.style.display = 'flex';
                waveformDownsampleGroup.style.display = 'flex';
                waveformNormGroup.style.display = 'flex';
            } else if (currentViz === 'spectrum') {
                scaleControls.style.display = 'flex';
                displayModeGroup.style.display = 'flex';
                peakFilterGroup.style.display = 'flex';
                filterValueGroup.style.display = 'flex';
                zoomXGroup.style.display = 'flex';
                zoomYGroup.style.display = 'flex';
                fftSizeGroup.style.display = 'flex';
            } else if (currentViz === 'spectrogram') {
                scaleControls.style.display = 'flex';
                spectrogramMagGroup.style.display = 'flex';
                spectrogramFreqGroup.style.display = 'flex';
                // Show mel bins control only when mel is selected
                if (scalePreferences.spectrogramFreq === 'mel') {
                    melBinsGroup.style.display = 'flex';
                }
                peakFilterGroup.style.display = 'flex';
                filterValueGroup.style.display = 'flex';
                zoomXGroup.style.display = 'flex';
                zoomYGroup.style.display = 'flex';
                fftSizeGroup.style.display = 'flex';
                hopSizeGroup.style.display = 'flex';
            } else if (currentViz === 'intensity') {
                scaleControls.style.display = 'flex';
                amplitudeGroup.style.display = 'flex';
            } else if (currentViz === 'pitch') {
                scaleControls.style.display = 'flex';
                pitchConfidenceGroup.style.display = 'flex';
                pitchSmoothingGroup.style.display = 'flex';
                if (scalePreferences.pitchSmoothingMode !== 'none') {
                    pitchSmoothingWindowGroup.style.display = 'flex';
                }
                pitchScaleGroup.style.display = 'flex';
                pitchNormalizeGroup.style.display = 'flex';
                pitchShowConfidenceGroup.style.display = 'flex';
                pitchShowUnvoicedGroup.style.display = 'flex';
                pitchYRangeGroup.style.display = 'flex';
            } else if (currentViz === 'mfcc') {
                scaleControls.style.display = 'flex';
                mfccNumFiltersGroup.style.display = 'flex';
                mfccCoeffGroup.style.display = 'flex';
                mfccDeltaGroup.style.display = 'flex';
                mfccLifterGroup.style.display = 'flex';
                mfccFilterModeGroup.style.display = 'flex';
                if (scalePreferences.mfccFilterMode !== 'none') {
                    mfccFilterValueGroup.style.display = 'flex';
                }
                mfccPerBinNormGroup.style.display = 'flex';
                mfccZoomXGroup.style.display = 'flex';
                mfccZoomYGroup.style.display = 'flex';
                mfccColormapGroup.style.display = 'flex';
                mfccSymmetricGroup.style.display = 'flex';
            }
        }
        
        function updateVisualization() {
            if (!nativeBuffer || !userBuffer) {
                debugLog.log('Buffers not ready for visualization');
                return;
            }
            
            debugLog.log(`Rendering ${currentViz} visualization`);
            
            switch (currentViz) {
                case 'waveform':
                    visualizer.drawWaveform(nativeBuffer, userBuffer);
                    break;
                case 'spectrum':
                    visualizer.drawSpectrum(nativeBuffer, userBuffer);
                    break;
                case 'spectrogram':
                    visualizer.drawSpectrogram(nativeBuffer, userBuffer);
                    break;
                case 'pitch':
                    if (analysisResults && analysisResults.features) {
                        visualizer.drawPitch(analysisResults);
                    } else {
                        visualizer.ctx.fillStyle = '#1f2937';
                        visualizer.ctx.fillRect(0, 0, visualizer.canvas.width, visualizer.canvas.height);
                        visualizer.ctx.fillStyle = 'white';
                        visualizer.ctx.font = '16px sans-serif';
                        visualizer.ctx.textAlign = 'center';
                        visualizer.ctx.fillText('Click "Analyze Pronunciation" to see pitch analysis', 
                            visualizer.canvas.width / 2, visualizer.canvas.height / 2);
                    }
                    break;
                case 'intensity':
                    if (analysisResults && analysisResults.features) {
                        visualizer.drawIntensity(analysisResults);
                    } else {
                        visualizer.ctx.fillStyle = '#1f2937';
                        visualizer.ctx.fillRect(0, 0, visualizer.canvas.width, visualizer.canvas.height);
                        visualizer.ctx.fillStyle = 'white';
                        visualizer.ctx.font = '16px sans-serif';
                        visualizer.ctx.textAlign = 'center';
                        visualizer.ctx.fillText('Click "Analyze Pronunciation" to see intensity analysis', 
                            visualizer.canvas.width / 2, visualizer.canvas.height / 2);
                    }
                    break;
                case 'mfcc':
                    if (analysisResults && analysisResults.features) {
                        visualizer.drawMFCCs(analysisResults);
                    } else {
                        visualizer.ctx.fillStyle = '#1f2937';
                        visualizer.ctx.fillRect(0, 0, visualizer.canvas.width, visualizer.canvas.height);
                        visualizer.ctx.fillStyle = 'white';
                        visualizer.ctx.font = '16px sans-serif';
                        visualizer.ctx.textAlign = 'center';
                        visualizer.ctx.fillText('Click "Analyze Pronunciation" to see MFCC analysis', 
                            visualizer.canvas.width / 2, visualizer.canvas.height / 2);
                    }
                    break;
                case 'features':
                    if (analysisResults && analysisResults.features) {
                        visualizer.drawAllFeatures(analysisResults);
                    } else {
                        visualizer.ctx.fillStyle = '#1f2937';
                        visualizer.ctx.fillRect(0, 0, visualizer.canvas.width, visualizer.canvas.height);
                        visualizer.ctx.fillStyle = 'white';
                        visualizer.ctx.font = '16px sans-serif';
                        visualizer.ctx.textAlign = 'center';
                        visualizer.ctx.fillText('Click "Analyze Pronunciation" to see all features', 
                            visualizer.canvas.width / 2, visualizer.canvas.height / 2);
                    }
                    break;
            }
            
            // Show/hide raw data export button based on available data
            updateRawDataExportButton();
        }
        
        function updateRawDataExportButton() {
            const container = document.getElementById('rawDataExportContainer');
            let hasData = false;
            
            if (currentViz === 'waveform' || currentViz === 'spectrum' || currentViz === 'spectrogram') {
                hasData = nativeBuffer && userBuffer;
            } else {
                hasData = analysisResults && analysisResults.features;
            }
            
            container.style.display = hasData ? 'block' : 'none';
        }
        
        function extractRawDataForCurrentViz(exportFiltered = false) {
            const data = {
                visualization: currentViz,
                timestamp: new Date().toISOString(),
                native: {},
                user: {}
            };
            
            switch (currentViz) {
                case 'waveform': {
                    const nativeData = nativeBuffer.getChannelData(0);
                    const userData = userBuffer.getChannelData(0);
                    
                    // Process waveform with filters
                    const processWaveform = (rawSamples, sampleRate) => {
                        // Apply time cropping
                        const timeStart = scalePreferences.waveformTimeStart;
                        const timeEnd = scalePreferences.waveformTimeEnd;
                        const startSample = Math.floor(timeStart * rawSamples.length);
                        const endSample = Math.floor(timeEnd * rawSamples.length);
                        let samples = Array.from(rawSamples.slice(startSample, endSample));
                        
                        // Apply zoom X (focus on first portion)
                        const zoomX = scalePreferences.waveformZoomX;
                        const zoomLength = Math.floor(samples.length / zoomX);
                        samples = samples.slice(0, zoomLength);
                        
                        if (!exportFiltered) {
                            return samples;
                        }
                        
                        // Apply filter based on mode
                        const filterMode = scalePreferences.waveformFilterMode;
                        
                        if (filterMode === 'none') {
                            return samples;
                        }
                        
                        // Apply RMS smoothing if selected
                        if (filterMode === 'rms') {
                            const windowSize = Math.floor(scalePreferences.waveformRmsWindow);
                            const smoothed = new Array(samples.length);
                            for (let i = 0; i < samples.length; i++) {
                                let rms = 0;
                                const start = Math.max(0, i - Math.floor(windowSize / 2));
                                const end = Math.min(samples.length, i + Math.floor(windowSize / 2));
                                for (let j = start; j < end; j++) {
                                    rms += samples[j] * samples[j];
                                }
                                rms = Math.sqrt(rms / (end - start));
                                smoothed[i] = samples[i] >= 0 ? rms : -rms;
                            }
                            samples = smoothed;
                        }
                        
                        // Calculate threshold based on filter mode
                        let threshold = 0;
                        if (filterMode === 'threshold' || filterMode === 'noisegate') {
                            threshold = scalePreferences.waveformThreshold;
                        } else if (filterMode === 'percentile') {
                            const absValues = samples.map(v => Math.abs(v)).sort((a, b) => a - b);
                            const percentileIdx = Math.floor(absValues.length * (1 - scalePreferences.waveformPercentile / 100));
                            threshold = absValues[Math.max(0, percentileIdx)];
                        }
                        
                        // Apply threshold - zero out samples below threshold
                        if (filterMode === 'threshold' || filterMode === 'noisegate' || filterMode === 'percentile') {
                            samples = samples.map(sample => 
                                Math.abs(sample) >= threshold ? sample : 0
                            );
                        }
                        
                        return samples;
                    };
                    
                    // Calculate statistics
                    const calcWaveformStats = (samples) => {
                        let peak = 0, rms = 0, nonZeroCount = 0;
                        for (let i = 0; i < samples.length; i++) {
                            const abs = Math.abs(samples[i]);
                            if (abs > peak) peak = abs;
                            rms += samples[i] * samples[i];
                            if (samples[i] !== 0) nonZeroCount++;
                        }
                        rms = Math.sqrt(rms / samples.length);
                        return { peak, rms, nonZeroCount, totalSamples: samples.length };
                    };
                    
                    const processedNative = processWaveform(nativeData, nativeBuffer.sampleRate);
                    const processedUser = processWaveform(userData, userBuffer.sampleRate);
                    
                    const nativeStats = calcWaveformStats(processedNative);
                    const userStats = calcWaveformStats(processedUser);
                    
                    // Build export structure
                    if (exportFiltered) {
                        data.exportType = 'filtered';
                        data.filter = {
                            mode: scalePreferences.waveformFilterMode,
                            threshold: scalePreferences.waveformThreshold,
                            percentile: scalePreferences.waveformPercentile,
                            rmsWindow: scalePreferences.waveformRmsWindow,
                            zoomX: scalePreferences.waveformZoomX,
                            timeRange: {
                                start: scalePreferences.waveformTimeStart,
                                end: scalePreferences.waveformTimeEnd
                            }
                        };
                    } else {
                        data.exportType = 'raw';
                    }
                    
                    data.summary = {
                        native: {
                            sampleRate: nativeBuffer.sampleRate,
                            duration: processedNative.length / nativeBuffer.sampleRate,
                            numSamples: processedNative.length,
                            peakAmplitude: nativeStats.peak,
                            rmsAmplitude: nativeStats.rms,
                            nonZeroSamples: nativeStats.nonZeroCount
                        },
                        user: {
                            sampleRate: userBuffer.sampleRate,
                            duration: processedUser.length / userBuffer.sampleRate,
                            numSamples: processedUser.length,
                            peakAmplitude: userStats.peak,
                            rmsAmplitude: userStats.rms,
                            nonZeroSamples: userStats.nonZeroCount
                        }
                    };
                    data.data = {
                        native: processedNative,
                        user: processedUser
                    };
                    break;
                }
                
                case 'spectrum': {
                    const fftSize = scalePreferences.fftSize;
                    const nativeData = nativeBuffer.getChannelData(0);
                    const userData = userBuffer.getChannelData(0);
                    
                    const computeSpectrum = (audioData, sampleRate) => {
                        const frame = Array.from(audioData.slice(0, fftSize));
                        while (frame.length < fftSize) frame.push(0);
                        
                        // Apply Hamming window
                        const windowed = frame.map((s, i) => 
                            s * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (fftSize - 1)))
                        );
                        
                        // Simple FFT magnitude computation
                        const spectrum = visualizer.computeFFT(windowed);
                        const freqStep = sampleRate / fftSize;
                        
                        let result = spectrum.map((mag, i) => ({
                            frequency: i * freqStep,
                            magnitude: mag
                        }));
                        
                        // Apply filter if requested
                        if (exportFiltered) {
                            const filterMode = scalePreferences.filterMode;
                            const filterValue = scalePreferences.filterValue;
                            const mags = spectrum;
                            let threshold = 0;
                            
                            switch (filterMode) {
                                case 'global':
                                case 'perbin': {
                                    const maxMag = Math.max(...mags);
                                    threshold = maxMag * (filterValue / 100);
                                    break;
                                }
                                case 'percentile': {
                                    if (filterValue < 100) {
                                        const sorted = [...mags].sort((a, b) => a - b);
                                        const idx = Math.floor(sorted.length * (1 - filterValue / 100));
                                        threshold = sorted[Math.min(idx, sorted.length - 1)];
                                    }
                                    break;
                                }
                                case 'db': {
                                    threshold = Math.pow(10, filterValue / 20);
                                    break;
                                }
                                case 'statistical': {
                                    const mean = mags.reduce((a, b) => a + b, 0) / mags.length;
                                    const variance = mags.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / mags.length;
                                    const stdDev = Math.sqrt(variance);
                                    threshold = mean + (filterValue * stdDev);
                                    break;
                                }
                            }
                            
                            result = result.filter(item => item.magnitude >= threshold);
                        }
                        
                        return result;
                    };
                    
                    // Compute spectra
                    const nativeSpectrum = computeSpectrum(nativeData, nativeBuffer.sampleRate);
                    const userSpectrum = computeSpectrum(userData, userBuffer.sampleRate);
                    
                    // Calculate summary statistics
                    const calcStats = (spectrum) => {
                        const mags = spectrum.map(s => s.magnitude);
                        const max = Math.max(...mags);
                        const mean = mags.reduce((a, b) => a + b, 0) / mags.length;
                        const peakFreq = spectrum.find(s => s.magnitude === max)?.frequency || 0;
                        return { max, mean, peakFreq };
                    };
                    
                    const nativeStats = calcStats(nativeSpectrum);
                    const userStats = calcStats(userSpectrum);
                    
                    // Build AI-friendly structure
                    data.exportType = exportFiltered ? 'filtered' : 'raw';
                    data.settings = {
                        fftSize: fftSize,
                        filterMode: scalePreferences.filterMode,
                        filterValue: scalePreferences.filterValue
                    };
                    data.summary = {
                        native: {
                            sampleRate: nativeBuffer.sampleRate,
                            duration: nativeBuffer.duration,
                            numBins: nativeSpectrum.length,
                            maxMagnitude: nativeStats.max,
                            meanMagnitude: nativeStats.mean,
                            peakFrequency: nativeStats.peakFreq
                        },
                        user: {
                            sampleRate: userBuffer.sampleRate,
                            duration: userBuffer.duration,
                            numBins: userSpectrum.length,
                            maxMagnitude: userStats.max,
                            meanMagnitude: userStats.mean,
                            peakFrequency: userStats.peakFreq
                        }
                    };
                    data.data = {
                        native: nativeSpectrum,
                        user: userSpectrum
                    };
                    break;
                }
                
                case 'spectrogram': {
                    const fftSize = scalePreferences.fftSize;
                    
                    // Calculate hop size - use user setting or default to fftSize/4
                    let hopSize;
                    if (scalePreferences.hopSize === 'auto') {
                        hopSize = Math.floor(fftSize / 4);
                    } else {
                        hopSize = parseInt(scalePreferences.hopSize);
                        if (hopSize > fftSize) {
                            hopSize = Math.floor(fftSize / 4);
                        }
                    }
                    
                    const useMel = scalePreferences.spectrogramFreq === 'mel';
                    const numMelBins = scalePreferences.melBins;
                    const maxFreq = 8000;
                    
                    const computeSpectrogram = (buffer) => {
                        const audioData = buffer.getChannelData(0);
                        const sampleRate = buffer.sampleRate;
                        const numFrames = Math.floor((audioData.length - fftSize) / hopSize);
                        const frames = [];
                        
                        // Create mel filterbank if needed
                        let melFilterbank = null;
                        if (useMel) {
                            melFilterbank = visualizer.createMelFilterbank(numMelBins, fftSize, sampleRate, 0, maxFreq);
                        }
                        
                        for (let i = 0; i < numFrames; i++) {
                            const start = i * hopSize;
                            const frame = Array.from(audioData.slice(start, start + fftSize));
                            const windowed = frame.map((s, idx) =>
                                s * (0.54 - 0.46 * Math.cos(2 * Math.PI * idx / (fftSize - 1)))
                            );
                            const spectrum = visualizer.computeFFT(windowed);
                            
                            let magnitudes;
                            if (useMel && melFilterbank) {
                                // Apply mel filterbank
                                magnitudes = visualizer.applyMelFilterbank(spectrum, melFilterbank);
                            } else {
                                magnitudes = spectrum.slice(0, spectrum.length / 2);
                            }
                            
                            frames.push({
                                time: start / buffer.sampleRate,
                                magnitudes: magnitudes
                            });
                        }
                        
                        return frames;
                    };
                    
                    let nativeFrames = computeSpectrogram(nativeBuffer);
                    let userFrames = computeSpectrogram(userBuffer);
                    
                    // Apply filter if requested
                    if (exportFiltered && nativeFrames.length > 0) {
                        const filterMode = scalePreferences.filterMode;
                        const filterValue = scalePreferences.filterValue;
                        
                        const applyFilter = (frames) => {
                            const numBins = frames[0].magnitudes.length;
                            
                            if (filterMode === 'perbin') {
                                // Calculate threshold per bin
                                const binThresholds = new Array(numBins).fill(0);
                                for (let bin = 0; bin < numBins; bin++) {
                                    let binMax = 0;
                                    for (let i = 0; i < frames.length; i++) {
                                        if (frames[i].magnitudes[bin] > binMax) {
                                            binMax = frames[i].magnitudes[bin];
                                        }
                                    }
                                    binThresholds[bin] = binMax * (filterValue / 100);
                                }
                                
                                // Filter each frame
                                return frames.map(frame => ({
                                    time: frame.time,
                                    magnitudes: frame.magnitudes.map((mag, bin) => 
                                        mag >= binThresholds[bin] ? mag : 0
                                    ).filter((mag, bin, arr) => {
                                        // Only include non-zero values with their bin index
                                        return mag > 0;
                                    }),
                                    // Include sparse format with bin indices
                                    peaks: frame.magnitudes.map((mag, bin) => ({ bin, mag }))
                                        .filter(item => item.mag >= binThresholds[item.bin])
                                }));
                            } else {
                                // Global threshold calculation
                                const allValues = frames.flatMap(f => f.magnitudes);
                                let threshold = 0;
                                
                                switch (filterMode) {
                                    case 'global': {
                                        const globalMax = Math.max(...allValues);
                                        threshold = globalMax * (filterValue / 100);
                                        break;
                                    }
                                    case 'percentile': {
                                        if (filterValue < 100) {
                                            const sorted = [...allValues].sort((a, b) => a - b);
                                            const idx = Math.floor(sorted.length * (1 - filterValue / 100));
                                            threshold = sorted[Math.min(idx, sorted.length - 1)];
                                        }
                                        break;
                                    }
                                    case 'db': {
                                        threshold = Math.pow(10, filterValue / 20);
                                        break;
                                    }
                                    case 'statistical': {
                                        const mean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                                        const variance = allValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / allValues.length;
                                        const stdDev = Math.sqrt(variance);
                                        threshold = mean + (filterValue * stdDev);
                                        break;
                                    }
                                }
                                
                                // Return sparse format
                                return frames.map(frame => ({
                                    time: frame.time,
                                    peaks: frame.magnitudes.map((mag, bin) => ({ bin, mag }))
                                        .filter(item => item.mag >= threshold)
                                }));
                            }
                        };
                        
                        nativeFrames = applyFilter(nativeFrames);
                        userFrames = applyFilter(userFrames);
                    }
                    
                    // Calculate summary statistics for spectrogram
                    const calcSpectrogramStats = (frames) => {
                        if (!frames || frames.length === 0) return { numFrames: 0, maxMag: 0, meanMag: 0 };
                        let allMags = [];
                        frames.forEach(f => {
                            if (f.magnitudes) {
                                allMags = allMags.concat(f.magnitudes);
                            } else if (f.peaks) {
                                allMags = allMags.concat(f.peaks.map(p => p.mag));
                            }
                        });
                        const max = allMags.length > 0 ? Math.max(...allMags) : 0;
                        const mean = allMags.length > 0 ? allMags.reduce((a, b) => a + b, 0) / allMags.length : 0;
                        return { numFrames: frames.length, maxMag: max, meanMag: mean };
                    };
                    
                    const nativeStats = calcSpectrogramStats(nativeFrames);
                    const userStats = calcSpectrogramStats(userFrames);
                    
                    // Build AI-friendly structure
                    data.exportType = exportFiltered ? 'filtered' : 'raw';
                    data.settings = {
                        fftSize: fftSize,
                        hopSize: hopSize,
                        frequencyScale: useMel ? 'mel' : scalePreferences.spectrogramFreq,
                        numBins: useMel ? numMelBins : Math.floor(fftSize / 2),
                        filterMode: scalePreferences.filterMode,
                        filterValue: scalePreferences.filterValue
                    };
                    data.summary = {
                        native: {
                            sampleRate: nativeBuffer.sampleRate,
                            duration: nativeBuffer.duration,
                            numFrames: nativeStats.numFrames,
                            maxMagnitude: nativeStats.maxMag,
                            meanMagnitude: nativeStats.meanMag
                        },
                        user: {
                            sampleRate: userBuffer.sampleRate,
                            duration: userBuffer.duration,
                            numFrames: userStats.numFrames,
                            maxMagnitude: userStats.maxMag,
                            meanMagnitude: userStats.meanMag
                        }
                    };
                    data.data = {
                        native: nativeFrames,
                        user: userFrames
                    };
                    break;
                }
                
                case 'pitch': {
                    if (analysisResults && analysisResults.features) {
                        const nativePitch = analysisResults.features.nativePitch;
                        const userPitch = analysisResults.features.userPitch;
                        
                        // Calculate pitch statistics
                        const calcPitchStats = (pitchTrack) => {
                            const voiced = pitchTrack.filter(p => p.pitch > 0);
                            if (voiced.length === 0) return { numFrames: pitchTrack.length, voicedFrames: 0, meanPitch: 0, minPitch: 0, maxPitch: 0 };
                            const pitches = voiced.map(p => p.pitch);
                            return {
                                numFrames: pitchTrack.length,
                                voicedFrames: voiced.length,
                                meanPitch: pitches.reduce((a, b) => a + b, 0) / pitches.length,
                                minPitch: Math.min(...pitches),
                                maxPitch: Math.max(...pitches)
                            };
                        };
                        
                        const nativeStats = calcPitchStats(nativePitch);
                        const userStats = calcPitchStats(userPitch);
                        
                        data.exportType = 'raw';
                        data.summary = {
                            native: nativeStats,
                            user: userStats
                        };
                        data.data = {
                            native: nativePitch.map(p => ({ time: p.time, pitch: p.pitch })),
                            user: userPitch.map(p => ({ time: p.time, pitch: p.pitch }))
                        };
                    }
                    break;
                }
                
                case 'intensity': {
                    if (analysisResults && analysisResults.features) {
                        const nativeIntensity = analysisResults.features.nativeIntensity;
                        const userIntensity = analysisResults.features.userIntensity;
                        
                        // Calculate intensity statistics
                        const calcIntensityStats = (track) => {
                            const values = track.map(p => p.intensity);
                            return {
                                numFrames: track.length,
                                meanIntensity: values.reduce((a, b) => a + b, 0) / values.length,
                                maxIntensity: Math.max(...values),
                                minIntensity: Math.min(...values)
                            };
                        };
                        
                        const nativeStats = calcIntensityStats(nativeIntensity);
                        const userStats = calcIntensityStats(userIntensity);
                        
                        data.exportType = 'raw';
                        data.summary = {
                            native: nativeStats,
                            user: userStats
                        };
                        data.data = {
                            native: nativeIntensity.map(p => ({ time: p.time, intensity: p.intensity })),
                            user: userIntensity.map(p => ({ time: p.time, intensity: p.intensity }))
                        };
                    }
                    break;
                }
                
                case 'mfcc': {
                    if (analysisResults && analysisResults.features) {
                        const nativeMFCCs = analysisResults.features.nativeMFCCs;
                        const userMFCCs = analysisResults.features.userMFCCs;
                        
                        // Process MFCCs with filters
                        const processMFCCs = (mfccs) => {
                            if (!mfccs || mfccs.length === 0) return [];
                            
                            const coeffStart = scalePreferences.mfccCoeffStart;
                            const coeffEnd = scalePreferences.mfccCoeffEnd;
                            const lifter = scalePreferences.mfccLifter;
                            const zoomX = scalePreferences.mfccZoomX;
                            
                            // Apply zoom X (show only first portion)
                            const numFrames = Math.floor(mfccs.length / zoomX);
                            let processed = mfccs.slice(0, numFrames);
                            
                            // Apply liftering and coefficient selection
                            processed = processed.map(frame => {
                                const selectedCoeffs = [];
                                for (let c = coeffStart; c <= coeffEnd; c++) {
                                    let value = frame.coeffs[c] || 0;
                                    // Apply lifter
                                    if (lifter > 0) {
                                        const lifterCoeff = 1 + (lifter / 2) * Math.sin(Math.PI * c / lifter);
                                        value *= lifterCoeff;
                                    }
                                    selectedCoeffs.push(value);
                                }
                                return { time: frame.time, coefficients: selectedCoeffs };
                            });
                            
                            if (!exportFiltered) {
                                return processed;
                            }
                            
                            // Apply filtering
                            const filterMode = scalePreferences.mfccFilterMode;
                            const filterValue = scalePreferences.mfccFilterValue;
                            
                            if (filterMode === 'none') {
                                return processed;
                            }
                            
                            // Collect all values for threshold calculation
                            const allValues = [];
                            processed.forEach(f => f.coefficients.forEach(c => allValues.push(Math.abs(c))));
                            
                            let threshold = 0;
                            if (filterMode === 'percentile') {
                                const sorted = allValues.slice().sort((a, b) => a - b);
                                const idx = Math.floor(sorted.length * (1 - filterValue / 100));
                                threshold = sorted[Math.max(0, idx)];
                            } else if (filterMode === 'statistical') {
                                const mean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                                const variance = allValues.reduce((a, b) => a + (b - mean) ** 2, 0) / allValues.length;
                                const stdDev = Math.sqrt(variance);
                                threshold = mean + filterValue * stdDev;
                            }
                            
                            // Apply threshold - zero out values below threshold
                            processed = processed.map(frame => ({
                                time: frame.time,
                                coefficients: frame.coefficients.map(c => 
                                    Math.abs(c) >= threshold ? c : 0
                                )
                            }));
                            
                            return processed;
                        };
                        
                        const processedNative = processMFCCs(nativeMFCCs);
                        const processedUser = processMFCCs(userMFCCs);
                        
                        // Calculate statistics
                        const calcMfccStats = (processed) => {
                            if (!processed || processed.length === 0) return { numFrames: 0, numCoeffs: 0 };
                            const numCoeffs = processed[0].coefficients.length;
                            let nonZeroCount = 0;
                            const coeffMeans = new Array(numCoeffs).fill(0);
                            processed.forEach(f => {
                                f.coefficients.forEach((c, i) => {
                                    coeffMeans[i] += c;
                                    if (c !== 0) nonZeroCount++;
                                });
                            });
                            coeffMeans.forEach((v, i) => coeffMeans[i] = v / processed.length);
                            return {
                                numFrames: processed.length,
                                numCoeffs: numCoeffs,
                                coefficientMeans: coeffMeans,
                                nonZeroValues: nonZeroCount,
                                totalValues: processed.length * numCoeffs
                            };
                        };
                        
                        const nativeStats = calcMfccStats(processedNative);
                        const userStats = calcMfccStats(processedUser);
                        
                        if (exportFiltered) {
                            data.exportType = 'filtered';
                            data.filter = {
                                mode: scalePreferences.mfccFilterMode,
                                value: scalePreferences.mfccFilterValue,
                                coeffRange: {
                                    start: scalePreferences.mfccCoeffStart,
                                    end: scalePreferences.mfccCoeffEnd
                                },
                                lifter: scalePreferences.mfccLifter,
                                zoomX: scalePreferences.mfccZoomX,
                                perBinNorm: scalePreferences.mfccPerBinNorm
                            };
                        } else {
                            data.exportType = 'raw';
                        }
                        
                        data.summary = {
                            native: nativeStats,
                            user: userStats
                        };
                        data.data = {
                            native: processedNative,
                            user: processedUser
                        };
                    }
                    break;
                }
                
                case 'features': {
                    if (analysisResults && analysisResults.features) {
                        // Include all features
                        data.native = {
                            pitch: analysisResults.features.nativePitch.map(p => ({
                                time: p.time,
                                pitch: p.pitch
                            })),
                            intensity: analysisResults.features.nativeIntensity.map(p => ({
                                time: p.time,
                                intensity: p.intensity
                            })),
                            mfcc: analysisResults.features.nativeMFCCs.map(f => ({
                                time: f.time,
                                coefficients: f.coeffs
                            })),
                            deltaMfcc: analysisResults.features.nativeDeltaMFCCs ? 
                                analysisResults.features.nativeDeltaMFCCs.map(f => ({
                                    time: f.time,
                                    coefficients: f.coeffs
                                })) : [],
                            zcr: analysisResults.features.nativeZCR ? 
                                analysisResults.features.nativeZCR.map(z => ({
                                    time: z.time,
                                    zcr: z.zcr
                                })) : [],
                            spectralTilt: analysisResults.features.nativeTilt ? 
                                analysisResults.features.nativeTilt.map(t => ({
                                    time: t.time,
                                    tilt: t.tilt
                                })) : []
                        };
                        data.user = {
                            pitch: analysisResults.features.userPitch.map(p => ({
                                time: p.time,
                                pitch: p.pitch
                            })),
                            intensity: analysisResults.features.userIntensity.map(p => ({
                                time: p.time,
                                intensity: p.intensity
                            })),
                            mfcc: analysisResults.features.userMFCCs.map(f => ({
                                time: f.time,
                                coefficients: f.coeffs
                            })),
                            deltaMfcc: analysisResults.features.userDeltaMFCCs ? 
                                analysisResults.features.userDeltaMFCCs.map(f => ({
                                    time: f.time,
                                    coefficients: f.coeffs
                                })) : [],
                            zcr: analysisResults.features.userZCR ? 
                                analysisResults.features.userZCR.map(z => ({
                                    time: z.time,
                                    zcr: z.zcr
                                })) : [],
                            spectralTilt: analysisResults.features.userTilt ? 
                                analysisResults.features.userTilt.map(t => ({
                                    time: t.time,
                                    tilt: t.tilt
                                })) : []
                        };
                    }
                    break;
                }
            }
            
            return data;
        }
        
        // Event handler for raw data export
        document.getElementById('exportRawData').addEventListener('click', () => {
            // Show modal for visualizations with filtering options
            if (currentViz === 'waveform' || currentViz === 'spectrum' || currentViz === 'spectrogram' || currentViz === 'mfcc') {
                document.getElementById('exportModal').style.display = 'flex';
            } else {
                // For other visualizations, export directly
                performExport(false);
            }
        });
        
        // Export modal button handlers
        document.getElementById('exportRawBtn').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'none';
            performExport(false);
        });
        
        document.getElementById('exportFilteredBtn').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'none';
            performExport(true);
        });
        
        document.getElementById('exportCancelBtn').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'none';
        });
        
        // Close modal on background click
        document.getElementById('exportModal').addEventListener('click', (e) => {
            if (e.target.id === 'exportModal') {
                document.getElementById('exportModal').style.display = 'none';
            }
        });
        
        function performExport(exportFiltered) {
            try {
                const rawData = extractRawDataForCurrentViz(exportFiltered);
                const jsonString = JSON.stringify(rawData, null, 2);
                
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const suffix = exportFiltered ? '_filtered' : '_raw';
                a.download = `${currentViz}${suffix}_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                debugLog.log(`Exported ${currentViz} ${exportFiltered ? 'filtered' : 'raw'} data`, 'success');
            } catch (err) {
                debugLog.log(`Error exporting raw data: ${err.message}`, 'error');
                alert('Error exporting data: ' + err.message);
            }
        }
        
        function showDetailedAnalysis(report) {
            if (!report) {
                debugLog.log('No detailed report to show', 'error');
                return;
            }
            
            const output = document.getElementById('analysisOutput');
            document.getElementById('analysisPanel').classList.add('show');
            
            const safeGet = (obj, path, defaultValue = 'N/A') => {
                try {
                    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
                    return value !== undefined && value !== null ? value : defaultValue;
                } catch (e) {
                    return defaultValue;
                }
            };
            
            let html = `
                <div style="font-family: monospace; font-size: 11px; line-height: 1.6;">
                    <h3 style="color: #059669; margin-bottom: 10px;">üìä DETAILED ANALYSIS REPORT</h3>
                    
                    <div style="background: #f9fafb; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                        <strong>METADATA:</strong><br>
                        Timestamp: ${safeGet(report, 'metadata.timestamp')}<br>
                        Native Duration: ${safeGet(report, 'metadata.nativeDuration', 0).toFixed(3)}s | User Duration: ${safeGet(report, 'metadata.userDuration', 0).toFixed(3)}s
                    </div>
                    
                    <div style="background: #eff6ff; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                        <strong>üéØ PITCH ANALYSIS:</strong><br>
                        Method: ${safeGet(report, 'pitch.comparison.method')}<br>
                        Native mean: ${safeGet(report, 'pitch.comparison.nativeMean')}<br>
                        User mean: ${safeGet(report, 'pitch.comparison.userMean')}
                    </div>
                    
                    <div style="background: #d1fae5; padding: 10px; border-radius: 5px;">
                        <strong>üèÜ FINAL SCORING:</strong><br>
                        Overall Score: ${safeGet(report, 'scoring.overallScore')}%
                    </div>
                </div>
            `;
            
            output.innerHTML = html;
        }
        
        function showResults(results) {
            document.getElementById('results').classList.add('show');
            
            const circumference = 2 * Math.PI * 45;
            const offset = circumference - (results.score / 100) * circumference;
            document.getElementById('scoreFill').style.strokeDashoffset = offset;
            document.getElementById('scoreText').textContent = results.score;
            
            document.getElementById('feedback').textContent = 
                results.score >= 85 ? "Excellent! üéâ" :
                results.score >= 70 ? "Great Job! üëç" :
                results.score >= 55 ? "Good Effort! üìö" : "Keep Practicing! üéØ";
            
            document.getElementById('detailedFeedback').textContent = results.feedback;
            
            const methodIndicator = document.getElementById('methodIndicator');
            if (methodIndicator) {
                if (useDTW) {
                    methodIndicator.textContent = 'üîÑ Using DTW - Pattern matching is tempo-invariant';
                    methodIndicator.style.color = '#10b981';
                } else {
                    methodIndicator.textContent = 'üìç Using Point-by-Point Comparison';
                    methodIndicator.style.color = '#6b7280';
                }
            }
            
            updateBreakdown('pitch', results.breakdown.pitch);
            updateBreakdown('mfcc', results.breakdown.mfcc);
            updateBreakdown('envelope', results.breakdown.envelope);
            updateBreakdown('duration', results.breakdown.duration);
            updateBreakdown('stressPosition', results.breakdown.stressPosition);
            updateBreakdown('stress', results.breakdown.stress);
            updateBreakdown('quality', results.breakdown.quality);
        }
        
        function updateBreakdown(type, score) {
            document.getElementById(`${type}Bar`).style.width = `${score}%`;
            document.getElementById(`${type}Score`).textContent = `${score}%`;
        }
        
        // ===================================================================
        // AI ANALYSIS FUNCTION
        // ===================================================================
        async function runAIAnalysis() {
            if (!anthropicApiKey || !analysisResults) {
                alert('Please configure API key and run analysis first.');
                return;
            }
            
            const section = document.getElementById('aiAnalysisSection');
            const content = document.getElementById('aiAnalysisContent');
            const btn = document.getElementById('aiAnalysisBtn');
            
            section.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; color: #6b7280;"><span style="animation: pulse 1.5s infinite;">üîÑ</span> Getting AI analysis...</div>';
            btn.disabled = true;
            
            // Build the prompt with detailed metrics
            const metrics = {
                overallScore: analysisResults.score,
                breakdown: analysisResults.breakdown,
                detailedReport: analysisResults.detailedReport
            };
            
            const prompt = `You are a pronunciation coach analyzing speech evaluation metrics for a language learner. Based on the following calculated metrics, provide detailed, actionable feedback for improving pronunciation.

## Target Language Context
The learner may be practicing Cebuano, Maranao, or Sinama - Philippine languages. If you have specific phonological knowledge about these languages (such as common sound patterns, stress rules, or vowel systems), include relevant guidance. If you don't have specific knowledge about the target language, provide general articulatory guidance without making up language-specific details.

## Calculated Metrics (scores out of 100)
${JSON.stringify(metrics, null, 2)}

## Your Task
1. **Interpret the scores** - Explain what each metric means in plain language
2. **Prioritize issues** - Focus on the lowest scores first (most critical improvements)
3. **Give specific, actionable advice** for each issue
4. **Include articulatory guidance** - Tongue position, lip shape, breath control, etc.
5. **Be encouraging but honest** - Acknowledge strengths while addressing weaknesses

Keep your response focused and practical. Use clear formatting but avoid excessive bullet points.`;

            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': anthropicApiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1500,
                        messages: [
                            { role: 'user', content: prompt }
                        ]
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API request failed');
                }
                
                const data = await response.json();
                const feedback = data.content[0].text;
                
                // Convert markdown to basic HTML
                const html = feedback
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/^### (.*$)/gm, '<h5 style="margin: 15px 0 10px 0; color: #065f46;">$1</h5>')
                    .replace(/^## (.*$)/gm, '<h4 style="margin: 15px 0 10px 0; color: #047857;">$1</h4>')
                    .replace(/^- /gm, '‚Ä¢ ')
                    .replace(/^\d+\. /gm, (match) => `<strong>${match}</strong>`)
                    .replace(/\n\n/g, '</p><p style="margin: 10px 0;">')
                    .replace(/\n/g, '<br>');
                
                content.innerHTML = `<p style="margin: 10px 0;">${html}</p>`;
                debugLog.log('AI analysis complete', 'success');
                
            } catch (error) {
                content.innerHTML = `<div style="color: #dc2626; padding: 10px; background: #fee2e2; border-radius: 4px;">
                    <strong>Error:</strong> ${error.message}
                </div>`;
                debugLog.log(`AI analysis error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
            }
        }
        
        // Wire up AI analysis button
        document.getElementById('aiAnalysisBtn').addEventListener('click', runAIAnalysis);
        
        // Initialize API status on page load
        if (anthropicApiKey) {
            updateApiStatus(true);
            document.getElementById('apiKeyInput').value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
        }
        
        updateScaleControlsVisibility();
        updateFilterControls();
        updateWaveformFilterControls();
        updateMfccFilterControls();
        
        visualizer.ctx.fillStyle = '#1f2937';
        visualizer.ctx.fillRect(0, 0, visualizer.canvas.width, visualizer.canvas.height);
        visualizer.ctx.fillStyle = 'rgba(156, 163, 175, 0.5)';
        visualizer.ctx.font = '20px sans-serif';
        visualizer.ctx.textAlign = 'center';
        visualizer.ctx.fillText('Upload native audio and record your voice to begin', 
            visualizer.canvas.width / 2, visualizer.canvas.height / 2);
        
        debugLog.log('Initialization complete!', 'success');
    </script>
</body>
</html>